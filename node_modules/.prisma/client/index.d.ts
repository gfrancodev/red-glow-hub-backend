
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model user
 * 
 */
export type user = $Result.DefaultSelection<Prisma.$userPayload>
/**
 * Model profile
 * 
 */
export type profile = $Result.DefaultSelection<Prisma.$profilePayload>
/**
 * Model media
 * 
 */
export type media = $Result.DefaultSelection<Prisma.$mediaPayload>
/**
 * Model tag
 * 
 */
export type tag = $Result.DefaultSelection<Prisma.$tagPayload>
/**
 * Model player_tag
 * 
 */
export type player_tag = $Result.DefaultSelection<Prisma.$player_tagPayload>
/**
 * Model boost
 * 
 */
export type boost = $Result.DefaultSelection<Prisma.$boostPayload>
/**
 * Model report
 * 
 */
export type report = $Result.DefaultSelection<Prisma.$reportPayload>
/**
 * Model strike
 * 
 */
export type strike = $Result.DefaultSelection<Prisma.$strikePayload>
/**
 * Model user_note
 * 
 */
export type user_note = $Result.DefaultSelection<Prisma.$user_notePayload>
/**
 * Model announcement
 * 
 */
export type announcement = $Result.DefaultSelection<Prisma.$announcementPayload>
/**
 * Model feature_slot
 * 
 */
export type feature_slot = $Result.DefaultSelection<Prisma.$feature_slotPayload>
/**
 * Model featured_assignment
 * 
 */
export type featured_assignment = $Result.DefaultSelection<Prisma.$featured_assignmentPayload>
/**
 * Model setting
 * 
 */
export type setting = $Result.DefaultSelection<Prisma.$settingPayload>
/**
 * Model support_ticket
 * 
 */
export type support_ticket = $Result.DefaultSelection<Prisma.$support_ticketPayload>
/**
 * Model contact_event
 * 
 */
export type contact_event = $Result.DefaultSelection<Prisma.$contact_eventPayload>
/**
 * Model audit_log
 * 
 */
export type audit_log = $Result.DefaultSelection<Prisma.$audit_logPayload>
/**
 * Model webhook_event
 * 
 */
export type webhook_event = $Result.DefaultSelection<Prisma.$webhook_eventPayload>
/**
 * Model session
 * 
 */
export type session = $Result.DefaultSelection<Prisma.$sessionPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const user_role: {
  player: 'player',
  admin: 'admin',
  moderator: 'moderator',
  curator: 'curator',
  support: 'support',
  readonly: 'readonly'
};

export type user_role = (typeof user_role)[keyof typeof user_role]


export const user_status: {
  active: 'active',
  review: 'review',
  restricted: 'restricted',
  suspended: 'suspended',
  banned: 'banned',
  shadowban: 'shadowban'
};

export type user_status = (typeof user_status)[keyof typeof user_status]


export const profile_status: {
  active: 'active',
  review: 'review',
  suspended: 'suspended',
  banned: 'banned',
  shadowban: 'shadowban',
  archived: 'archived'
};

export type profile_status = (typeof profile_status)[keyof typeof profile_status]


export const media_status: {
  pending: 'pending',
  approved: 'approved',
  rejected: 'rejected',
  takedown: 'takedown',
  archived: 'archived'
};

export type media_status = (typeof media_status)[keyof typeof media_status]


export const media_type: {
  image: 'image',
  video: 'video'
};

export type media_type = (typeof media_type)[keyof typeof media_type]


export const media_source: {
  upload: 'upload',
  external: 'external'
};

export type media_source = (typeof media_source)[keyof typeof media_source]


export const boost_status: {
  scheduled: 'scheduled',
  active: 'active',
  expired: 'expired',
  canceled: 'canceled'
};

export type boost_status = (typeof boost_status)[keyof typeof boost_status]


export const provider_kind: {
  stripe: 'stripe',
  mercadopago: 'mercadopago',
  other: 'other'
};

export type provider_kind = (typeof provider_kind)[keyof typeof provider_kind]


export const report_status: {
  open: 'open',
  in_review: 'in_review',
  closed: 'closed'
};

export type report_status = (typeof report_status)[keyof typeof report_status]


export const report_reason: {
  abuse: 'abuse',
  harassment: 'harassment',
  spam: 'spam',
  fraud: 'fraud',
  nsfw: 'nsfw',
  illegal: 'illegal',
  other: 'other'
};

export type report_reason = (typeof report_reason)[keyof typeof report_reason]


export const severity_level: {
  low: 'low',
  medium: 'medium',
  high: 'high'
};

export type severity_level = (typeof severity_level)[keyof typeof severity_level]


export const ticket_status: {
  open: 'open',
  pending: 'pending',
  closed: 'closed'
};

export type ticket_status = (typeof ticket_status)[keyof typeof ticket_status]


export const ticket_priority: {
  low: 'low',
  medium: 'medium',
  high: 'high',
  urgent: 'urgent'
};

export type ticket_priority = (typeof ticket_priority)[keyof typeof ticket_priority]


export const announcement_status: {
  draft: 'draft',
  published: 'published',
  expired: 'expired'
};

export type announcement_status = (typeof announcement_status)[keyof typeof announcement_status]


export const feature_slot_key: {
  home_hero: 'home_hero',
  home_rail: 'home_rail',
  sidebar_banner: 'sidebar_banner'
};

export type feature_slot_key = (typeof feature_slot_key)[keyof typeof feature_slot_key]


export const setting_status: {
  active: 'active',
  inactive: 'inactive'
};

export type setting_status = (typeof setting_status)[keyof typeof setting_status]


export const audit_status: {
  success: 'success',
  failed: 'failed'
};

export type audit_status = (typeof audit_status)[keyof typeof audit_status]


export const webhook_status: {
  received: 'received',
  processed: 'processed',
  failed: 'failed'
};

export type webhook_status = (typeof webhook_status)[keyof typeof webhook_status]


export const contact_channel: {
  email: 'email',
  whatsapp: 'whatsapp',
  twitch: 'twitch',
  youtube: 'youtube',
  instagram: 'instagram',
  other: 'other'
};

export type contact_channel = (typeof contact_channel)[keyof typeof contact_channel]

}

export type user_role = $Enums.user_role

export const user_role: typeof $Enums.user_role

export type user_status = $Enums.user_status

export const user_status: typeof $Enums.user_status

export type profile_status = $Enums.profile_status

export const profile_status: typeof $Enums.profile_status

export type media_status = $Enums.media_status

export const media_status: typeof $Enums.media_status

export type media_type = $Enums.media_type

export const media_type: typeof $Enums.media_type

export type media_source = $Enums.media_source

export const media_source: typeof $Enums.media_source

export type boost_status = $Enums.boost_status

export const boost_status: typeof $Enums.boost_status

export type provider_kind = $Enums.provider_kind

export const provider_kind: typeof $Enums.provider_kind

export type report_status = $Enums.report_status

export const report_status: typeof $Enums.report_status

export type report_reason = $Enums.report_reason

export const report_reason: typeof $Enums.report_reason

export type severity_level = $Enums.severity_level

export const severity_level: typeof $Enums.severity_level

export type ticket_status = $Enums.ticket_status

export const ticket_status: typeof $Enums.ticket_status

export type ticket_priority = $Enums.ticket_priority

export const ticket_priority: typeof $Enums.ticket_priority

export type announcement_status = $Enums.announcement_status

export const announcement_status: typeof $Enums.announcement_status

export type feature_slot_key = $Enums.feature_slot_key

export const feature_slot_key: typeof $Enums.feature_slot_key

export type setting_status = $Enums.setting_status

export const setting_status: typeof $Enums.setting_status

export type audit_status = $Enums.audit_status

export const audit_status: typeof $Enums.audit_status

export type webhook_status = $Enums.webhook_status

export const webhook_status: typeof $Enums.webhook_status

export type contact_channel = $Enums.contact_channel

export const contact_channel: typeof $Enums.contact_channel

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P]): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number }): $Utils.JsPromise<R>

  /**
   * Executes a raw MongoDB command and returns the result of it.
   * @example
   * ```
   * const user = await prisma.$runCommandRaw({
   *   aggregate: 'User',
   *   pipeline: [{ $match: { name: 'Bob' } }, { $project: { email: true, _id: false } }],
   *   explain: false,
   * })
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $runCommandRaw(command: Prisma.InputJsonObject): Prisma.PrismaPromise<Prisma.JsonObject>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **user** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.userDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.profile`: Exposes CRUD operations for the **profile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Profiles
    * const profiles = await prisma.profile.findMany()
    * ```
    */
  get profile(): Prisma.profileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.media`: Exposes CRUD operations for the **media** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Media
    * const media = await prisma.media.findMany()
    * ```
    */
  get media(): Prisma.mediaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tag`: Exposes CRUD operations for the **tag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tags
    * const tags = await prisma.tag.findMany()
    * ```
    */
  get tag(): Prisma.tagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.player_tag`: Exposes CRUD operations for the **player_tag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Player_tags
    * const player_tags = await prisma.player_tag.findMany()
    * ```
    */
  get player_tag(): Prisma.player_tagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.boost`: Exposes CRUD operations for the **boost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Boosts
    * const boosts = await prisma.boost.findMany()
    * ```
    */
  get boost(): Prisma.boostDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.report`: Exposes CRUD operations for the **report** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reports
    * const reports = await prisma.report.findMany()
    * ```
    */
  get report(): Prisma.reportDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.strike`: Exposes CRUD operations for the **strike** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Strikes
    * const strikes = await prisma.strike.findMany()
    * ```
    */
  get strike(): Prisma.strikeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user_note`: Exposes CRUD operations for the **user_note** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_notes
    * const user_notes = await prisma.user_note.findMany()
    * ```
    */
  get user_note(): Prisma.user_noteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.announcement`: Exposes CRUD operations for the **announcement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Announcements
    * const announcements = await prisma.announcement.findMany()
    * ```
    */
  get announcement(): Prisma.announcementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.feature_slot`: Exposes CRUD operations for the **feature_slot** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Feature_slots
    * const feature_slots = await prisma.feature_slot.findMany()
    * ```
    */
  get feature_slot(): Prisma.feature_slotDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.featured_assignment`: Exposes CRUD operations for the **featured_assignment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Featured_assignments
    * const featured_assignments = await prisma.featured_assignment.findMany()
    * ```
    */
  get featured_assignment(): Prisma.featured_assignmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.setting`: Exposes CRUD operations for the **setting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Settings
    * const settings = await prisma.setting.findMany()
    * ```
    */
  get setting(): Prisma.settingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.support_ticket`: Exposes CRUD operations for the **support_ticket** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Support_tickets
    * const support_tickets = await prisma.support_ticket.findMany()
    * ```
    */
  get support_ticket(): Prisma.support_ticketDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contact_event`: Exposes CRUD operations for the **contact_event** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contact_events
    * const contact_events = await prisma.contact_event.findMany()
    * ```
    */
  get contact_event(): Prisma.contact_eventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.audit_log`: Exposes CRUD operations for the **audit_log** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Audit_logs
    * const audit_logs = await prisma.audit_log.findMany()
    * ```
    */
  get audit_log(): Prisma.audit_logDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.webhook_event`: Exposes CRUD operations for the **webhook_event** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Webhook_events
    * const webhook_events = await prisma.webhook_event.findMany()
    * ```
    */
  get webhook_event(): Prisma.webhook_eventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.sessionDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.17.1
   * Query Engine version: 272a37d34178c2894197e17273bf937f25acdeac
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    user: 'user',
    profile: 'profile',
    media: 'media',
    tag: 'tag',
    player_tag: 'player_tag',
    boost: 'boost',
    report: 'report',
    strike: 'strike',
    user_note: 'user_note',
    announcement: 'announcement',
    feature_slot: 'feature_slot',
    featured_assignment: 'featured_assignment',
    setting: 'setting',
    support_ticket: 'support_ticket',
    contact_event: 'contact_event',
    audit_log: 'audit_log',
    webhook_event: 'webhook_event',
    session: 'session'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "profile" | "media" | "tag" | "player_tag" | "boost" | "report" | "strike" | "user_note" | "announcement" | "feature_slot" | "featured_assignment" | "setting" | "support_ticket" | "contact_event" | "audit_log" | "webhook_event" | "session"
      txIsolationLevel: never
    }
    model: {
      user: {
        payload: Prisma.$userPayload<ExtArgs>
        fields: Prisma.userFieldRefs
        operations: {
          findUnique: {
            args: Prisma.userFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.userFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          findFirst: {
            args: Prisma.userFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.userFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          findMany: {
            args: Prisma.userFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>[]
          }
          create: {
            args: Prisma.userCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          createMany: {
            args: Prisma.userCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.userDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          update: {
            args: Prisma.userUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          deleteMany: {
            args: Prisma.userDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.userUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.userUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.userGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.userFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.userAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.userCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      profile: {
        payload: Prisma.$profilePayload<ExtArgs>
        fields: Prisma.profileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.profileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$profilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.profileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$profilePayload>
          }
          findFirst: {
            args: Prisma.profileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$profilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.profileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$profilePayload>
          }
          findMany: {
            args: Prisma.profileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$profilePayload>[]
          }
          create: {
            args: Prisma.profileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$profilePayload>
          }
          createMany: {
            args: Prisma.profileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.profileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$profilePayload>
          }
          update: {
            args: Prisma.profileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$profilePayload>
          }
          deleteMany: {
            args: Prisma.profileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.profileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.profileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$profilePayload>
          }
          aggregate: {
            args: Prisma.ProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProfile>
          }
          groupBy: {
            args: Prisma.profileGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProfileGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.profileFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.profileAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.profileCountArgs<ExtArgs>
            result: $Utils.Optional<ProfileCountAggregateOutputType> | number
          }
        }
      }
      media: {
        payload: Prisma.$mediaPayload<ExtArgs>
        fields: Prisma.mediaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.mediaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mediaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.mediaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mediaPayload>
          }
          findFirst: {
            args: Prisma.mediaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mediaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.mediaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mediaPayload>
          }
          findMany: {
            args: Prisma.mediaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mediaPayload>[]
          }
          create: {
            args: Prisma.mediaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mediaPayload>
          }
          createMany: {
            args: Prisma.mediaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.mediaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mediaPayload>
          }
          update: {
            args: Prisma.mediaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mediaPayload>
          }
          deleteMany: {
            args: Prisma.mediaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.mediaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.mediaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mediaPayload>
          }
          aggregate: {
            args: Prisma.MediaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedia>
          }
          groupBy: {
            args: Prisma.mediaGroupByArgs<ExtArgs>
            result: $Utils.Optional<MediaGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.mediaFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.mediaAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.mediaCountArgs<ExtArgs>
            result: $Utils.Optional<MediaCountAggregateOutputType> | number
          }
        }
      }
      tag: {
        payload: Prisma.$tagPayload<ExtArgs>
        fields: Prisma.tagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagPayload>
          }
          findFirst: {
            args: Prisma.tagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagPayload>
          }
          findMany: {
            args: Prisma.tagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagPayload>[]
          }
          create: {
            args: Prisma.tagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagPayload>
          }
          createMany: {
            args: Prisma.tagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.tagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagPayload>
          }
          update: {
            args: Prisma.tagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagPayload>
          }
          deleteMany: {
            args: Prisma.tagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagPayload>
          }
          aggregate: {
            args: Prisma.TagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTag>
          }
          groupBy: {
            args: Prisma.tagGroupByArgs<ExtArgs>
            result: $Utils.Optional<TagGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.tagFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.tagAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.tagCountArgs<ExtArgs>
            result: $Utils.Optional<TagCountAggregateOutputType> | number
          }
        }
      }
      player_tag: {
        payload: Prisma.$player_tagPayload<ExtArgs>
        fields: Prisma.player_tagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.player_tagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$player_tagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.player_tagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$player_tagPayload>
          }
          findFirst: {
            args: Prisma.player_tagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$player_tagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.player_tagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$player_tagPayload>
          }
          findMany: {
            args: Prisma.player_tagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$player_tagPayload>[]
          }
          create: {
            args: Prisma.player_tagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$player_tagPayload>
          }
          createMany: {
            args: Prisma.player_tagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.player_tagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$player_tagPayload>
          }
          update: {
            args: Prisma.player_tagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$player_tagPayload>
          }
          deleteMany: {
            args: Prisma.player_tagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.player_tagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.player_tagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$player_tagPayload>
          }
          aggregate: {
            args: Prisma.Player_tagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlayer_tag>
          }
          groupBy: {
            args: Prisma.player_tagGroupByArgs<ExtArgs>
            result: $Utils.Optional<Player_tagGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.player_tagFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.player_tagAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.player_tagCountArgs<ExtArgs>
            result: $Utils.Optional<Player_tagCountAggregateOutputType> | number
          }
        }
      }
      boost: {
        payload: Prisma.$boostPayload<ExtArgs>
        fields: Prisma.boostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.boostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$boostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.boostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$boostPayload>
          }
          findFirst: {
            args: Prisma.boostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$boostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.boostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$boostPayload>
          }
          findMany: {
            args: Prisma.boostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$boostPayload>[]
          }
          create: {
            args: Prisma.boostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$boostPayload>
          }
          createMany: {
            args: Prisma.boostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.boostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$boostPayload>
          }
          update: {
            args: Prisma.boostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$boostPayload>
          }
          deleteMany: {
            args: Prisma.boostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.boostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.boostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$boostPayload>
          }
          aggregate: {
            args: Prisma.BoostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBoost>
          }
          groupBy: {
            args: Prisma.boostGroupByArgs<ExtArgs>
            result: $Utils.Optional<BoostGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.boostFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.boostAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.boostCountArgs<ExtArgs>
            result: $Utils.Optional<BoostCountAggregateOutputType> | number
          }
        }
      }
      report: {
        payload: Prisma.$reportPayload<ExtArgs>
        fields: Prisma.reportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.reportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.reportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reportPayload>
          }
          findFirst: {
            args: Prisma.reportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.reportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reportPayload>
          }
          findMany: {
            args: Prisma.reportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reportPayload>[]
          }
          create: {
            args: Prisma.reportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reportPayload>
          }
          createMany: {
            args: Prisma.reportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.reportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reportPayload>
          }
          update: {
            args: Prisma.reportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reportPayload>
          }
          deleteMany: {
            args: Prisma.reportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.reportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.reportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reportPayload>
          }
          aggregate: {
            args: Prisma.ReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReport>
          }
          groupBy: {
            args: Prisma.reportGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReportGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.reportFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.reportAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.reportCountArgs<ExtArgs>
            result: $Utils.Optional<ReportCountAggregateOutputType> | number
          }
        }
      }
      strike: {
        payload: Prisma.$strikePayload<ExtArgs>
        fields: Prisma.strikeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.strikeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$strikePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.strikeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$strikePayload>
          }
          findFirst: {
            args: Prisma.strikeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$strikePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.strikeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$strikePayload>
          }
          findMany: {
            args: Prisma.strikeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$strikePayload>[]
          }
          create: {
            args: Prisma.strikeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$strikePayload>
          }
          createMany: {
            args: Prisma.strikeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.strikeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$strikePayload>
          }
          update: {
            args: Prisma.strikeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$strikePayload>
          }
          deleteMany: {
            args: Prisma.strikeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.strikeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.strikeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$strikePayload>
          }
          aggregate: {
            args: Prisma.StrikeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStrike>
          }
          groupBy: {
            args: Prisma.strikeGroupByArgs<ExtArgs>
            result: $Utils.Optional<StrikeGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.strikeFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.strikeAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.strikeCountArgs<ExtArgs>
            result: $Utils.Optional<StrikeCountAggregateOutputType> | number
          }
        }
      }
      user_note: {
        payload: Prisma.$user_notePayload<ExtArgs>
        fields: Prisma.user_noteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.user_noteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_notePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.user_noteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_notePayload>
          }
          findFirst: {
            args: Prisma.user_noteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_notePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.user_noteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_notePayload>
          }
          findMany: {
            args: Prisma.user_noteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_notePayload>[]
          }
          create: {
            args: Prisma.user_noteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_notePayload>
          }
          createMany: {
            args: Prisma.user_noteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.user_noteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_notePayload>
          }
          update: {
            args: Prisma.user_noteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_notePayload>
          }
          deleteMany: {
            args: Prisma.user_noteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.user_noteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.user_noteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_notePayload>
          }
          aggregate: {
            args: Prisma.User_noteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser_note>
          }
          groupBy: {
            args: Prisma.user_noteGroupByArgs<ExtArgs>
            result: $Utils.Optional<User_noteGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.user_noteFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.user_noteAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.user_noteCountArgs<ExtArgs>
            result: $Utils.Optional<User_noteCountAggregateOutputType> | number
          }
        }
      }
      announcement: {
        payload: Prisma.$announcementPayload<ExtArgs>
        fields: Prisma.announcementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.announcementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$announcementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.announcementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$announcementPayload>
          }
          findFirst: {
            args: Prisma.announcementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$announcementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.announcementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$announcementPayload>
          }
          findMany: {
            args: Prisma.announcementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$announcementPayload>[]
          }
          create: {
            args: Prisma.announcementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$announcementPayload>
          }
          createMany: {
            args: Prisma.announcementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.announcementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$announcementPayload>
          }
          update: {
            args: Prisma.announcementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$announcementPayload>
          }
          deleteMany: {
            args: Prisma.announcementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.announcementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.announcementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$announcementPayload>
          }
          aggregate: {
            args: Prisma.AnnouncementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnnouncement>
          }
          groupBy: {
            args: Prisma.announcementGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnnouncementGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.announcementFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.announcementAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.announcementCountArgs<ExtArgs>
            result: $Utils.Optional<AnnouncementCountAggregateOutputType> | number
          }
        }
      }
      feature_slot: {
        payload: Prisma.$feature_slotPayload<ExtArgs>
        fields: Prisma.feature_slotFieldRefs
        operations: {
          findUnique: {
            args: Prisma.feature_slotFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feature_slotPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.feature_slotFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feature_slotPayload>
          }
          findFirst: {
            args: Prisma.feature_slotFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feature_slotPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.feature_slotFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feature_slotPayload>
          }
          findMany: {
            args: Prisma.feature_slotFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feature_slotPayload>[]
          }
          create: {
            args: Prisma.feature_slotCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feature_slotPayload>
          }
          createMany: {
            args: Prisma.feature_slotCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.feature_slotDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feature_slotPayload>
          }
          update: {
            args: Prisma.feature_slotUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feature_slotPayload>
          }
          deleteMany: {
            args: Prisma.feature_slotDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.feature_slotUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.feature_slotUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feature_slotPayload>
          }
          aggregate: {
            args: Prisma.Feature_slotAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeature_slot>
          }
          groupBy: {
            args: Prisma.feature_slotGroupByArgs<ExtArgs>
            result: $Utils.Optional<Feature_slotGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.feature_slotFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.feature_slotAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.feature_slotCountArgs<ExtArgs>
            result: $Utils.Optional<Feature_slotCountAggregateOutputType> | number
          }
        }
      }
      featured_assignment: {
        payload: Prisma.$featured_assignmentPayload<ExtArgs>
        fields: Prisma.featured_assignmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.featured_assignmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$featured_assignmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.featured_assignmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$featured_assignmentPayload>
          }
          findFirst: {
            args: Prisma.featured_assignmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$featured_assignmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.featured_assignmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$featured_assignmentPayload>
          }
          findMany: {
            args: Prisma.featured_assignmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$featured_assignmentPayload>[]
          }
          create: {
            args: Prisma.featured_assignmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$featured_assignmentPayload>
          }
          createMany: {
            args: Prisma.featured_assignmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.featured_assignmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$featured_assignmentPayload>
          }
          update: {
            args: Prisma.featured_assignmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$featured_assignmentPayload>
          }
          deleteMany: {
            args: Prisma.featured_assignmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.featured_assignmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.featured_assignmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$featured_assignmentPayload>
          }
          aggregate: {
            args: Prisma.Featured_assignmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeatured_assignment>
          }
          groupBy: {
            args: Prisma.featured_assignmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<Featured_assignmentGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.featured_assignmentFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.featured_assignmentAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.featured_assignmentCountArgs<ExtArgs>
            result: $Utils.Optional<Featured_assignmentCountAggregateOutputType> | number
          }
        }
      }
      setting: {
        payload: Prisma.$settingPayload<ExtArgs>
        fields: Prisma.settingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.settingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.settingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settingPayload>
          }
          findFirst: {
            args: Prisma.settingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.settingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settingPayload>
          }
          findMany: {
            args: Prisma.settingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settingPayload>[]
          }
          create: {
            args: Prisma.settingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settingPayload>
          }
          createMany: {
            args: Prisma.settingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.settingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settingPayload>
          }
          update: {
            args: Prisma.settingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settingPayload>
          }
          deleteMany: {
            args: Prisma.settingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.settingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.settingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settingPayload>
          }
          aggregate: {
            args: Prisma.SettingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSetting>
          }
          groupBy: {
            args: Prisma.settingGroupByArgs<ExtArgs>
            result: $Utils.Optional<SettingGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.settingFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.settingAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.settingCountArgs<ExtArgs>
            result: $Utils.Optional<SettingCountAggregateOutputType> | number
          }
        }
      }
      support_ticket: {
        payload: Prisma.$support_ticketPayload<ExtArgs>
        fields: Prisma.support_ticketFieldRefs
        operations: {
          findUnique: {
            args: Prisma.support_ticketFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_ticketPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.support_ticketFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_ticketPayload>
          }
          findFirst: {
            args: Prisma.support_ticketFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_ticketPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.support_ticketFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_ticketPayload>
          }
          findMany: {
            args: Prisma.support_ticketFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_ticketPayload>[]
          }
          create: {
            args: Prisma.support_ticketCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_ticketPayload>
          }
          createMany: {
            args: Prisma.support_ticketCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.support_ticketDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_ticketPayload>
          }
          update: {
            args: Prisma.support_ticketUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_ticketPayload>
          }
          deleteMany: {
            args: Prisma.support_ticketDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.support_ticketUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.support_ticketUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_ticketPayload>
          }
          aggregate: {
            args: Prisma.Support_ticketAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSupport_ticket>
          }
          groupBy: {
            args: Prisma.support_ticketGroupByArgs<ExtArgs>
            result: $Utils.Optional<Support_ticketGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.support_ticketFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.support_ticketAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.support_ticketCountArgs<ExtArgs>
            result: $Utils.Optional<Support_ticketCountAggregateOutputType> | number
          }
        }
      }
      contact_event: {
        payload: Prisma.$contact_eventPayload<ExtArgs>
        fields: Prisma.contact_eventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.contact_eventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contact_eventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.contact_eventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contact_eventPayload>
          }
          findFirst: {
            args: Prisma.contact_eventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contact_eventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.contact_eventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contact_eventPayload>
          }
          findMany: {
            args: Prisma.contact_eventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contact_eventPayload>[]
          }
          create: {
            args: Prisma.contact_eventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contact_eventPayload>
          }
          createMany: {
            args: Prisma.contact_eventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.contact_eventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contact_eventPayload>
          }
          update: {
            args: Prisma.contact_eventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contact_eventPayload>
          }
          deleteMany: {
            args: Prisma.contact_eventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.contact_eventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.contact_eventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contact_eventPayload>
          }
          aggregate: {
            args: Prisma.Contact_eventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContact_event>
          }
          groupBy: {
            args: Prisma.contact_eventGroupByArgs<ExtArgs>
            result: $Utils.Optional<Contact_eventGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.contact_eventFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.contact_eventAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.contact_eventCountArgs<ExtArgs>
            result: $Utils.Optional<Contact_eventCountAggregateOutputType> | number
          }
        }
      }
      audit_log: {
        payload: Prisma.$audit_logPayload<ExtArgs>
        fields: Prisma.audit_logFieldRefs
        operations: {
          findUnique: {
            args: Prisma.audit_logFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$audit_logPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.audit_logFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$audit_logPayload>
          }
          findFirst: {
            args: Prisma.audit_logFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$audit_logPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.audit_logFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$audit_logPayload>
          }
          findMany: {
            args: Prisma.audit_logFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$audit_logPayload>[]
          }
          create: {
            args: Prisma.audit_logCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$audit_logPayload>
          }
          createMany: {
            args: Prisma.audit_logCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.audit_logDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$audit_logPayload>
          }
          update: {
            args: Prisma.audit_logUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$audit_logPayload>
          }
          deleteMany: {
            args: Prisma.audit_logDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.audit_logUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.audit_logUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$audit_logPayload>
          }
          aggregate: {
            args: Prisma.Audit_logAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAudit_log>
          }
          groupBy: {
            args: Prisma.audit_logGroupByArgs<ExtArgs>
            result: $Utils.Optional<Audit_logGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.audit_logFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.audit_logAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.audit_logCountArgs<ExtArgs>
            result: $Utils.Optional<Audit_logCountAggregateOutputType> | number
          }
        }
      }
      webhook_event: {
        payload: Prisma.$webhook_eventPayload<ExtArgs>
        fields: Prisma.webhook_eventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.webhook_eventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$webhook_eventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.webhook_eventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$webhook_eventPayload>
          }
          findFirst: {
            args: Prisma.webhook_eventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$webhook_eventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.webhook_eventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$webhook_eventPayload>
          }
          findMany: {
            args: Prisma.webhook_eventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$webhook_eventPayload>[]
          }
          create: {
            args: Prisma.webhook_eventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$webhook_eventPayload>
          }
          createMany: {
            args: Prisma.webhook_eventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.webhook_eventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$webhook_eventPayload>
          }
          update: {
            args: Prisma.webhook_eventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$webhook_eventPayload>
          }
          deleteMany: {
            args: Prisma.webhook_eventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.webhook_eventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.webhook_eventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$webhook_eventPayload>
          }
          aggregate: {
            args: Prisma.Webhook_eventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWebhook_event>
          }
          groupBy: {
            args: Prisma.webhook_eventGroupByArgs<ExtArgs>
            result: $Utils.Optional<Webhook_eventGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.webhook_eventFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.webhook_eventAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.webhook_eventCountArgs<ExtArgs>
            result: $Utils.Optional<Webhook_eventCountAggregateOutputType> | number
          }
        }
      }
      session: {
        payload: Prisma.$sessionPayload<ExtArgs>
        fields: Prisma.sessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.sessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.sessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionPayload>
          }
          findFirst: {
            args: Prisma.sessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.sessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionPayload>
          }
          findMany: {
            args: Prisma.sessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionPayload>[]
          }
          create: {
            args: Prisma.sessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionPayload>
          }
          createMany: {
            args: Prisma.sessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.sessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionPayload>
          }
          update: {
            args: Prisma.sessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionPayload>
          }
          deleteMany: {
            args: Prisma.sessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.sessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.sessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.sessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.sessionFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.sessionAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.sessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $runCommandRaw: {
          args: Prisma.InputJsonObject,
          result: Prisma.JsonObject
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: userOmit
    profile?: profileOmit
    media?: mediaOmit
    tag?: tagOmit
    player_tag?: player_tagOmit
    boost?: boostOmit
    report?: reportOmit
    strike?: strikeOmit
    user_note?: user_noteOmit
    announcement?: announcementOmit
    feature_slot?: feature_slotOmit
    featured_assignment?: featured_assignmentOmit
    setting?: settingOmit
    support_ticket?: support_ticketOmit
    contact_event?: contact_eventOmit
    audit_log?: audit_logOmit
    webhook_event?: webhook_eventOmit
    session?: sessionOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    tickets: number
    assigned_tickets: number
    reports_made: number
    notes_authored: number
    sessions: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tickets?: boolean | UserCountOutputTypeCountTicketsArgs
    assigned_tickets?: boolean | UserCountOutputTypeCountAssigned_ticketsArgs
    reports_made?: boolean | UserCountOutputTypeCountReports_madeArgs
    notes_authored?: boolean | UserCountOutputTypeCountNotes_authoredArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: support_ticketWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssigned_ticketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: support_ticketWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReports_madeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: reportWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotes_authoredArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_noteWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sessionWhereInput
  }


  /**
   * Count Type ProfileCountOutputType
   */

  export type ProfileCountOutputType = {
    media: number
    boosts: number
    strikes: number
    notes: number
    contact_events: number
    reports_against: number
    player_tags: number
    featured_assignments: number
  }

  export type ProfileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    media?: boolean | ProfileCountOutputTypeCountMediaArgs
    boosts?: boolean | ProfileCountOutputTypeCountBoostsArgs
    strikes?: boolean | ProfileCountOutputTypeCountStrikesArgs
    notes?: boolean | ProfileCountOutputTypeCountNotesArgs
    contact_events?: boolean | ProfileCountOutputTypeCountContact_eventsArgs
    reports_against?: boolean | ProfileCountOutputTypeCountReports_againstArgs
    player_tags?: boolean | ProfileCountOutputTypeCountPlayer_tagsArgs
    featured_assignments?: boolean | ProfileCountOutputTypeCountFeatured_assignmentsArgs
  }

  // Custom InputTypes
  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileCountOutputType
     */
    select?: ProfileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountMediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: mediaWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountBoostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: boostWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountStrikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: strikeWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_noteWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountContact_eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: contact_eventWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountReports_againstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: reportWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountPlayer_tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: player_tagWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountFeatured_assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: featured_assignmentWhereInput
  }


  /**
   * Count Type MediaCountOutputType
   */

  export type MediaCountOutputType = {
    reports_against: number
    featured_assignments: number
  }

  export type MediaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reports_against?: boolean | MediaCountOutputTypeCountReports_againstArgs
    featured_assignments?: boolean | MediaCountOutputTypeCountFeatured_assignmentsArgs
  }

  // Custom InputTypes
  /**
   * MediaCountOutputType without action
   */
  export type MediaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaCountOutputType
     */
    select?: MediaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MediaCountOutputType without action
   */
  export type MediaCountOutputTypeCountReports_againstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: reportWhereInput
  }

  /**
   * MediaCountOutputType without action
   */
  export type MediaCountOutputTypeCountFeatured_assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: featured_assignmentWhereInput
  }


  /**
   * Count Type TagCountOutputType
   */

  export type TagCountOutputType = {
    player_tags: number
  }

  export type TagCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player_tags?: boolean | TagCountOutputTypeCountPlayer_tagsArgs
  }

  // Custom InputTypes
  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagCountOutputType
     */
    select?: TagCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountPlayer_tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: player_tagWhereInput
  }


  /**
   * Models
   */

  /**
   * Model user
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    password_hash: string | null
    role: $Enums.user_role | null
    status: $Enums.user_status | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password_hash: string | null
    role: $Enums.user_role | null
    status: $Enums.user_status | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password_hash: number
    role: number
    status: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password_hash?: true
    role?: true
    status?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password_hash?: true
    role?: true
    status?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password_hash?: true
    role?: true
    status?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user to aggregate.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type userGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userWhereInput
    orderBy?: userOrderByWithAggregationInput | userOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: userScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    password_hash: string
    role: $Enums.user_role
    status: $Enums.user_status
    created_at: Date
    updated_at: Date
    deleted_at: Date | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends userGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type userSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password_hash?: boolean
    role?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    profile?: boolean | user$profileArgs<ExtArgs>
    tickets?: boolean | user$ticketsArgs<ExtArgs>
    assigned_tickets?: boolean | user$assigned_ticketsArgs<ExtArgs>
    reports_made?: boolean | user$reports_madeArgs<ExtArgs>
    notes_authored?: boolean | user$notes_authoredArgs<ExtArgs>
    sessions?: boolean | user$sessionsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>



  export type userSelectScalar = {
    id?: boolean
    email?: boolean
    password_hash?: boolean
    role?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }

  export type userOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "password_hash" | "role" | "status" | "created_at" | "updated_at" | "deleted_at", ExtArgs["result"]["user"]>
  export type userInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | user$profileArgs<ExtArgs>
    tickets?: boolean | user$ticketsArgs<ExtArgs>
    assigned_tickets?: boolean | user$assigned_ticketsArgs<ExtArgs>
    reports_made?: boolean | user$reports_madeArgs<ExtArgs>
    notes_authored?: boolean | user$notes_authoredArgs<ExtArgs>
    sessions?: boolean | user$sessionsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $userPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user"
    objects: {
      profile: Prisma.$profilePayload<ExtArgs> | null
      tickets: Prisma.$support_ticketPayload<ExtArgs>[]
      assigned_tickets: Prisma.$support_ticketPayload<ExtArgs>[]
      reports_made: Prisma.$reportPayload<ExtArgs>[]
      notes_authored: Prisma.$user_notePayload<ExtArgs>[]
      sessions: Prisma.$sessionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      password_hash: string
      role: $Enums.user_role
      status: $Enums.user_status
      created_at: Date
      updated_at: Date
      deleted_at: Date | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type userGetPayload<S extends boolean | null | undefined | userDefaultArgs> = $Result.GetResult<Prisma.$userPayload, S>

  type userCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<userFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface userDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user'], meta: { name: 'user' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {userFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends userFindUniqueArgs>(args: SelectSubset<T, userFindUniqueArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {userFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends userFindUniqueOrThrowArgs>(args: SelectSubset<T, userFindUniqueOrThrowArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends userFindFirstArgs>(args?: SelectSubset<T, userFindFirstArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends userFindFirstOrThrowArgs>(args?: SelectSubset<T, userFindFirstOrThrowArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends userFindManyArgs>(args?: SelectSubset<T, userFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {userCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends userCreateArgs>(args: SelectSubset<T, userCreateArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {userCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends userCreateManyArgs>(args?: SelectSubset<T, userCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {userDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends userDeleteArgs>(args: SelectSubset<T, userDeleteArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {userUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends userUpdateArgs>(args: SelectSubset<T, userUpdateArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {userDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends userDeleteManyArgs>(args?: SelectSubset<T, userDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends userUpdateManyArgs>(args: SelectSubset<T, userUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {userUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends userUpsertArgs>(args: SelectSubset<T, userUpsertArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * @param {userFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const user = await prisma.user.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: userFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a User.
     * @param {userAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const user = await prisma.user.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: userAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends userCountArgs>(
      args?: Subset<T, userCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends userGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: userGroupByArgs['orderBy'] }
        : { orderBy?: userGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, userGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user model
   */
  readonly fields: userFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__userClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profile<T extends user$profileArgs<ExtArgs> = {}>(args?: Subset<T, user$profileArgs<ExtArgs>>): Prisma__profileClient<$Result.GetResult<Prisma.$profilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    tickets<T extends user$ticketsArgs<ExtArgs> = {}>(args?: Subset<T, user$ticketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$support_ticketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    assigned_tickets<T extends user$assigned_ticketsArgs<ExtArgs> = {}>(args?: Subset<T, user$assigned_ticketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$support_ticketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reports_made<T extends user$reports_madeArgs<ExtArgs> = {}>(args?: Subset<T, user$reports_madeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notes_authored<T extends user$notes_authoredArgs<ExtArgs> = {}>(args?: Subset<T, user$notes_authoredArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_notePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends user$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, user$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the user model
   */
  interface userFieldRefs {
    readonly id: FieldRef<"user", 'String'>
    readonly email: FieldRef<"user", 'String'>
    readonly password_hash: FieldRef<"user", 'String'>
    readonly role: FieldRef<"user", 'user_role'>
    readonly status: FieldRef<"user", 'user_status'>
    readonly created_at: FieldRef<"user", 'DateTime'>
    readonly updated_at: FieldRef<"user", 'DateTime'>
    readonly deleted_at: FieldRef<"user", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * user findUnique
   */
  export type userFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }

  /**
   * user findUniqueOrThrow
   */
  export type userFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }

  /**
   * user findFirst
   */
  export type userFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user findFirstOrThrow
   */
  export type userFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user findMany
   */
  export type userFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user create
   */
  export type userCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The data needed to create a user.
     */
    data: XOR<userCreateInput, userUncheckedCreateInput>
  }

  /**
   * user createMany
   */
  export type userCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: userCreateManyInput | userCreateManyInput[]
  }

  /**
   * user update
   */
  export type userUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The data needed to update a user.
     */
    data: XOR<userUpdateInput, userUncheckedUpdateInput>
    /**
     * Choose, which user to update.
     */
    where: userWhereUniqueInput
  }

  /**
   * user updateMany
   */
  export type userUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<userUpdateManyMutationInput, userUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: userWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * user upsert
   */
  export type userUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The filter to search for the user to update in case it exists.
     */
    where: userWhereUniqueInput
    /**
     * In case the user found by the `where` argument doesn't exist, create a new user with this data.
     */
    create: XOR<userCreateInput, userUncheckedCreateInput>
    /**
     * In case the user was found with the provided `where` argument, update it with this data.
     */
    update: XOR<userUpdateInput, userUncheckedUpdateInput>
  }

  /**
   * user delete
   */
  export type userDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter which user to delete.
     */
    where: userWhereUniqueInput
  }

  /**
   * user deleteMany
   */
  export type userDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: userWhereInput
    /**
     * Limit how many users to delete.
     */
    limit?: number
  }

  /**
   * user findRaw
   */
  export type userFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * user aggregateRaw
   */
  export type userAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * user.profile
   */
  export type user$profileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the profile
     */
    omit?: profileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: profileInclude<ExtArgs> | null
    where?: profileWhereInput
  }

  /**
   * user.tickets
   */
  export type user$ticketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_ticket
     */
    select?: support_ticketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_ticket
     */
    omit?: support_ticketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: support_ticketInclude<ExtArgs> | null
    where?: support_ticketWhereInput
    orderBy?: support_ticketOrderByWithRelationInput | support_ticketOrderByWithRelationInput[]
    cursor?: support_ticketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Support_ticketScalarFieldEnum | Support_ticketScalarFieldEnum[]
  }

  /**
   * user.assigned_tickets
   */
  export type user$assigned_ticketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_ticket
     */
    select?: support_ticketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_ticket
     */
    omit?: support_ticketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: support_ticketInclude<ExtArgs> | null
    where?: support_ticketWhereInput
    orderBy?: support_ticketOrderByWithRelationInput | support_ticketOrderByWithRelationInput[]
    cursor?: support_ticketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Support_ticketScalarFieldEnum | Support_ticketScalarFieldEnum[]
  }

  /**
   * user.reports_made
   */
  export type user$reports_madeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the report
     */
    select?: reportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the report
     */
    omit?: reportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reportInclude<ExtArgs> | null
    where?: reportWhereInput
    orderBy?: reportOrderByWithRelationInput | reportOrderByWithRelationInput[]
    cursor?: reportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * user.notes_authored
   */
  export type user$notes_authoredArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_note
     */
    select?: user_noteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_note
     */
    omit?: user_noteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_noteInclude<ExtArgs> | null
    where?: user_noteWhereInput
    orderBy?: user_noteOrderByWithRelationInput | user_noteOrderByWithRelationInput[]
    cursor?: user_noteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: User_noteScalarFieldEnum | User_noteScalarFieldEnum[]
  }

  /**
   * user.sessions
   */
  export type user$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionInclude<ExtArgs> | null
    where?: sessionWhereInput
    orderBy?: sessionOrderByWithRelationInput | sessionOrderByWithRelationInput[]
    cursor?: sessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * user without action
   */
  export type userDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
  }


  /**
   * Model profile
   */

  export type AggregateProfile = {
    _count: ProfileCountAggregateOutputType | null
    _avg: ProfileAvgAggregateOutputType | null
    _sum: ProfileSumAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  export type ProfileAvgAggregateOutputType = {
    tags_count: number | null
  }

  export type ProfileSumAggregateOutputType = {
    tags_count: number | null
  }

  export type ProfileMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    username: string | null
    display_name: string | null
    bio: string | null
    avatar_url: string | null
    state: string | null
    city: string | null
    city_slug: string | null
    contact_email: string | null
    whatsapp: string | null
    twitch: string | null
    youtube: string | null
    instagram: string | null
    featured_media_id: string | null
    tags_count: number | null
    status: $Enums.profile_status | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type ProfileMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    username: string | null
    display_name: string | null
    bio: string | null
    avatar_url: string | null
    state: string | null
    city: string | null
    city_slug: string | null
    contact_email: string | null
    whatsapp: string | null
    twitch: string | null
    youtube: string | null
    instagram: string | null
    featured_media_id: string | null
    tags_count: number | null
    status: $Enums.profile_status | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type ProfileCountAggregateOutputType = {
    id: number
    user_id: number
    username: number
    display_name: number
    bio: number
    avatar_url: number
    state: number
    city: number
    city_slug: number
    contact_email: number
    whatsapp: number
    twitch: number
    youtube: number
    instagram: number
    featured_media_id: number
    tags_count: number
    status: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type ProfileAvgAggregateInputType = {
    tags_count?: true
  }

  export type ProfileSumAggregateInputType = {
    tags_count?: true
  }

  export type ProfileMinAggregateInputType = {
    id?: true
    user_id?: true
    username?: true
    display_name?: true
    bio?: true
    avatar_url?: true
    state?: true
    city?: true
    city_slug?: true
    contact_email?: true
    whatsapp?: true
    twitch?: true
    youtube?: true
    instagram?: true
    featured_media_id?: true
    tags_count?: true
    status?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type ProfileMaxAggregateInputType = {
    id?: true
    user_id?: true
    username?: true
    display_name?: true
    bio?: true
    avatar_url?: true
    state?: true
    city?: true
    city_slug?: true
    contact_email?: true
    whatsapp?: true
    twitch?: true
    youtube?: true
    instagram?: true
    featured_media_id?: true
    tags_count?: true
    status?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type ProfileCountAggregateInputType = {
    id?: true
    user_id?: true
    username?: true
    display_name?: true
    bio?: true
    avatar_url?: true
    state?: true
    city?: true
    city_slug?: true
    contact_email?: true
    whatsapp?: true
    twitch?: true
    youtube?: true
    instagram?: true
    featured_media_id?: true
    tags_count?: true
    status?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type ProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which profile to aggregate.
     */
    where?: profileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of profiles to fetch.
     */
    orderBy?: profileOrderByWithRelationInput | profileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: profileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned profiles
    **/
    _count?: true | ProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfileMaxAggregateInputType
  }

  export type GetProfileAggregateType<T extends ProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfile[P]>
      : GetScalarType<T[P], AggregateProfile[P]>
  }




  export type profileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: profileWhereInput
    orderBy?: profileOrderByWithAggregationInput | profileOrderByWithAggregationInput[]
    by: ProfileScalarFieldEnum[] | ProfileScalarFieldEnum
    having?: profileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfileCountAggregateInputType | true
    _avg?: ProfileAvgAggregateInputType
    _sum?: ProfileSumAggregateInputType
    _min?: ProfileMinAggregateInputType
    _max?: ProfileMaxAggregateInputType
  }

  export type ProfileGroupByOutputType = {
    id: string
    user_id: string
    username: string
    display_name: string
    bio: string | null
    avatar_url: string | null
    state: string
    city: string
    city_slug: string | null
    contact_email: string | null
    whatsapp: string | null
    twitch: string | null
    youtube: string | null
    instagram: string | null
    featured_media_id: string | null
    tags_count: number | null
    status: $Enums.profile_status
    created_at: Date
    updated_at: Date
    deleted_at: Date | null
    _count: ProfileCountAggregateOutputType | null
    _avg: ProfileAvgAggregateOutputType | null
    _sum: ProfileSumAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  type GetProfileGroupByPayload<T extends profileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfileGroupByOutputType[P]>
            : GetScalarType<T[P], ProfileGroupByOutputType[P]>
        }
      >
    >


  export type profileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    username?: boolean
    display_name?: boolean
    bio?: boolean
    avatar_url?: boolean
    state?: boolean
    city?: boolean
    city_slug?: boolean
    contact_email?: boolean
    whatsapp?: boolean
    twitch?: boolean
    youtube?: boolean
    instagram?: boolean
    featured_media_id?: boolean
    tags_count?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
    media?: boolean | profile$mediaArgs<ExtArgs>
    boosts?: boolean | profile$boostsArgs<ExtArgs>
    strikes?: boolean | profile$strikesArgs<ExtArgs>
    notes?: boolean | profile$notesArgs<ExtArgs>
    contact_events?: boolean | profile$contact_eventsArgs<ExtArgs>
    reports_against?: boolean | profile$reports_againstArgs<ExtArgs>
    player_tags?: boolean | profile$player_tagsArgs<ExtArgs>
    featured_assignments?: boolean | profile$featured_assignmentsArgs<ExtArgs>
    _count?: boolean | ProfileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profile"]>



  export type profileSelectScalar = {
    id?: boolean
    user_id?: boolean
    username?: boolean
    display_name?: boolean
    bio?: boolean
    avatar_url?: boolean
    state?: boolean
    city?: boolean
    city_slug?: boolean
    contact_email?: boolean
    whatsapp?: boolean
    twitch?: boolean
    youtube?: boolean
    instagram?: boolean
    featured_media_id?: boolean
    tags_count?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }

  export type profileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "username" | "display_name" | "bio" | "avatar_url" | "state" | "city" | "city_slug" | "contact_email" | "whatsapp" | "twitch" | "youtube" | "instagram" | "featured_media_id" | "tags_count" | "status" | "created_at" | "updated_at" | "deleted_at", ExtArgs["result"]["profile"]>
  export type profileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
    media?: boolean | profile$mediaArgs<ExtArgs>
    boosts?: boolean | profile$boostsArgs<ExtArgs>
    strikes?: boolean | profile$strikesArgs<ExtArgs>
    notes?: boolean | profile$notesArgs<ExtArgs>
    contact_events?: boolean | profile$contact_eventsArgs<ExtArgs>
    reports_against?: boolean | profile$reports_againstArgs<ExtArgs>
    player_tags?: boolean | profile$player_tagsArgs<ExtArgs>
    featured_assignments?: boolean | profile$featured_assignmentsArgs<ExtArgs>
    _count?: boolean | ProfileCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $profilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "profile"
    objects: {
      user: Prisma.$userPayload<ExtArgs>
      media: Prisma.$mediaPayload<ExtArgs>[]
      boosts: Prisma.$boostPayload<ExtArgs>[]
      strikes: Prisma.$strikePayload<ExtArgs>[]
      notes: Prisma.$user_notePayload<ExtArgs>[]
      contact_events: Prisma.$contact_eventPayload<ExtArgs>[]
      reports_against: Prisma.$reportPayload<ExtArgs>[]
      player_tags: Prisma.$player_tagPayload<ExtArgs>[]
      featured_assignments: Prisma.$featured_assignmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      username: string
      display_name: string
      bio: string | null
      avatar_url: string | null
      state: string
      city: string
      city_slug: string | null
      contact_email: string | null
      whatsapp: string | null
      twitch: string | null
      youtube: string | null
      instagram: string | null
      featured_media_id: string | null
      tags_count: number | null
      status: $Enums.profile_status
      created_at: Date
      updated_at: Date
      deleted_at: Date | null
    }, ExtArgs["result"]["profile"]>
    composites: {}
  }

  type profileGetPayload<S extends boolean | null | undefined | profileDefaultArgs> = $Result.GetResult<Prisma.$profilePayload, S>

  type profileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<profileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProfileCountAggregateInputType | true
    }

  export interface profileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['profile'], meta: { name: 'profile' } }
    /**
     * Find zero or one Profile that matches the filter.
     * @param {profileFindUniqueArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends profileFindUniqueArgs>(args: SelectSubset<T, profileFindUniqueArgs<ExtArgs>>): Prisma__profileClient<$Result.GetResult<Prisma.$profilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Profile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {profileFindUniqueOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends profileFindUniqueOrThrowArgs>(args: SelectSubset<T, profileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__profileClient<$Result.GetResult<Prisma.$profilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Profile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {profileFindFirstArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends profileFindFirstArgs>(args?: SelectSubset<T, profileFindFirstArgs<ExtArgs>>): Prisma__profileClient<$Result.GetResult<Prisma.$profilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Profile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {profileFindFirstOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends profileFindFirstOrThrowArgs>(args?: SelectSubset<T, profileFindFirstOrThrowArgs<ExtArgs>>): Prisma__profileClient<$Result.GetResult<Prisma.$profilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Profiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {profileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Profiles
     * const profiles = await prisma.profile.findMany()
     * 
     * // Get first 10 Profiles
     * const profiles = await prisma.profile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const profileWithIdOnly = await prisma.profile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends profileFindManyArgs>(args?: SelectSubset<T, profileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$profilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Profile.
     * @param {profileCreateArgs} args - Arguments to create a Profile.
     * @example
     * // Create one Profile
     * const Profile = await prisma.profile.create({
     *   data: {
     *     // ... data to create a Profile
     *   }
     * })
     * 
     */
    create<T extends profileCreateArgs>(args: SelectSubset<T, profileCreateArgs<ExtArgs>>): Prisma__profileClient<$Result.GetResult<Prisma.$profilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Profiles.
     * @param {profileCreateManyArgs} args - Arguments to create many Profiles.
     * @example
     * // Create many Profiles
     * const profile = await prisma.profile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends profileCreateManyArgs>(args?: SelectSubset<T, profileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Profile.
     * @param {profileDeleteArgs} args - Arguments to delete one Profile.
     * @example
     * // Delete one Profile
     * const Profile = await prisma.profile.delete({
     *   where: {
     *     // ... filter to delete one Profile
     *   }
     * })
     * 
     */
    delete<T extends profileDeleteArgs>(args: SelectSubset<T, profileDeleteArgs<ExtArgs>>): Prisma__profileClient<$Result.GetResult<Prisma.$profilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Profile.
     * @param {profileUpdateArgs} args - Arguments to update one Profile.
     * @example
     * // Update one Profile
     * const profile = await prisma.profile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends profileUpdateArgs>(args: SelectSubset<T, profileUpdateArgs<ExtArgs>>): Prisma__profileClient<$Result.GetResult<Prisma.$profilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Profiles.
     * @param {profileDeleteManyArgs} args - Arguments to filter Profiles to delete.
     * @example
     * // Delete a few Profiles
     * const { count } = await prisma.profile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends profileDeleteManyArgs>(args?: SelectSubset<T, profileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {profileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Profiles
     * const profile = await prisma.profile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends profileUpdateManyArgs>(args: SelectSubset<T, profileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Profile.
     * @param {profileUpsertArgs} args - Arguments to update or create a Profile.
     * @example
     * // Update or create a Profile
     * const profile = await prisma.profile.upsert({
     *   create: {
     *     // ... data to create a Profile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Profile we want to update
     *   }
     * })
     */
    upsert<T extends profileUpsertArgs>(args: SelectSubset<T, profileUpsertArgs<ExtArgs>>): Prisma__profileClient<$Result.GetResult<Prisma.$profilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Profiles that matches the filter.
     * @param {profileFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const profile = await prisma.profile.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: profileFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Profile.
     * @param {profileAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const profile = await prisma.profile.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: profileAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {profileCountArgs} args - Arguments to filter Profiles to count.
     * @example
     * // Count the number of Profiles
     * const count = await prisma.profile.count({
     *   where: {
     *     // ... the filter for the Profiles we want to count
     *   }
     * })
    **/
    count<T extends profileCountArgs>(
      args?: Subset<T, profileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfileAggregateArgs>(args: Subset<T, ProfileAggregateArgs>): Prisma.PrismaPromise<GetProfileAggregateType<T>>

    /**
     * Group by Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {profileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends profileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: profileGroupByArgs['orderBy'] }
        : { orderBy?: profileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, profileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the profile model
   */
  readonly fields: profileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for profile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__profileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    media<T extends profile$mediaArgs<ExtArgs> = {}>(args?: Subset<T, profile$mediaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mediaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    boosts<T extends profile$boostsArgs<ExtArgs> = {}>(args?: Subset<T, profile$boostsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$boostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    strikes<T extends profile$strikesArgs<ExtArgs> = {}>(args?: Subset<T, profile$strikesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$strikePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notes<T extends profile$notesArgs<ExtArgs> = {}>(args?: Subset<T, profile$notesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_notePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    contact_events<T extends profile$contact_eventsArgs<ExtArgs> = {}>(args?: Subset<T, profile$contact_eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$contact_eventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reports_against<T extends profile$reports_againstArgs<ExtArgs> = {}>(args?: Subset<T, profile$reports_againstArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    player_tags<T extends profile$player_tagsArgs<ExtArgs> = {}>(args?: Subset<T, profile$player_tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$player_tagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    featured_assignments<T extends profile$featured_assignmentsArgs<ExtArgs> = {}>(args?: Subset<T, profile$featured_assignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$featured_assignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the profile model
   */
  interface profileFieldRefs {
    readonly id: FieldRef<"profile", 'String'>
    readonly user_id: FieldRef<"profile", 'String'>
    readonly username: FieldRef<"profile", 'String'>
    readonly display_name: FieldRef<"profile", 'String'>
    readonly bio: FieldRef<"profile", 'String'>
    readonly avatar_url: FieldRef<"profile", 'String'>
    readonly state: FieldRef<"profile", 'String'>
    readonly city: FieldRef<"profile", 'String'>
    readonly city_slug: FieldRef<"profile", 'String'>
    readonly contact_email: FieldRef<"profile", 'String'>
    readonly whatsapp: FieldRef<"profile", 'String'>
    readonly twitch: FieldRef<"profile", 'String'>
    readonly youtube: FieldRef<"profile", 'String'>
    readonly instagram: FieldRef<"profile", 'String'>
    readonly featured_media_id: FieldRef<"profile", 'String'>
    readonly tags_count: FieldRef<"profile", 'Int'>
    readonly status: FieldRef<"profile", 'profile_status'>
    readonly created_at: FieldRef<"profile", 'DateTime'>
    readonly updated_at: FieldRef<"profile", 'DateTime'>
    readonly deleted_at: FieldRef<"profile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * profile findUnique
   */
  export type profileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the profile
     */
    omit?: profileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: profileInclude<ExtArgs> | null
    /**
     * Filter, which profile to fetch.
     */
    where: profileWhereUniqueInput
  }

  /**
   * profile findUniqueOrThrow
   */
  export type profileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the profile
     */
    omit?: profileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: profileInclude<ExtArgs> | null
    /**
     * Filter, which profile to fetch.
     */
    where: profileWhereUniqueInput
  }

  /**
   * profile findFirst
   */
  export type profileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the profile
     */
    omit?: profileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: profileInclude<ExtArgs> | null
    /**
     * Filter, which profile to fetch.
     */
    where?: profileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of profiles to fetch.
     */
    orderBy?: profileOrderByWithRelationInput | profileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for profiles.
     */
    cursor?: profileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * profile findFirstOrThrow
   */
  export type profileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the profile
     */
    omit?: profileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: profileInclude<ExtArgs> | null
    /**
     * Filter, which profile to fetch.
     */
    where?: profileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of profiles to fetch.
     */
    orderBy?: profileOrderByWithRelationInput | profileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for profiles.
     */
    cursor?: profileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * profile findMany
   */
  export type profileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the profile
     */
    omit?: profileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: profileInclude<ExtArgs> | null
    /**
     * Filter, which profiles to fetch.
     */
    where?: profileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of profiles to fetch.
     */
    orderBy?: profileOrderByWithRelationInput | profileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing profiles.
     */
    cursor?: profileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` profiles.
     */
    skip?: number
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * profile create
   */
  export type profileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the profile
     */
    omit?: profileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: profileInclude<ExtArgs> | null
    /**
     * The data needed to create a profile.
     */
    data: XOR<profileCreateInput, profileUncheckedCreateInput>
  }

  /**
   * profile createMany
   */
  export type profileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many profiles.
     */
    data: profileCreateManyInput | profileCreateManyInput[]
  }

  /**
   * profile update
   */
  export type profileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the profile
     */
    omit?: profileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: profileInclude<ExtArgs> | null
    /**
     * The data needed to update a profile.
     */
    data: XOR<profileUpdateInput, profileUncheckedUpdateInput>
    /**
     * Choose, which profile to update.
     */
    where: profileWhereUniqueInput
  }

  /**
   * profile updateMany
   */
  export type profileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update profiles.
     */
    data: XOR<profileUpdateManyMutationInput, profileUncheckedUpdateManyInput>
    /**
     * Filter which profiles to update
     */
    where?: profileWhereInput
    /**
     * Limit how many profiles to update.
     */
    limit?: number
  }

  /**
   * profile upsert
   */
  export type profileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the profile
     */
    omit?: profileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: profileInclude<ExtArgs> | null
    /**
     * The filter to search for the profile to update in case it exists.
     */
    where: profileWhereUniqueInput
    /**
     * In case the profile found by the `where` argument doesn't exist, create a new profile with this data.
     */
    create: XOR<profileCreateInput, profileUncheckedCreateInput>
    /**
     * In case the profile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<profileUpdateInput, profileUncheckedUpdateInput>
  }

  /**
   * profile delete
   */
  export type profileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the profile
     */
    omit?: profileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: profileInclude<ExtArgs> | null
    /**
     * Filter which profile to delete.
     */
    where: profileWhereUniqueInput
  }

  /**
   * profile deleteMany
   */
  export type profileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which profiles to delete
     */
    where?: profileWhereInput
    /**
     * Limit how many profiles to delete.
     */
    limit?: number
  }

  /**
   * profile findRaw
   */
  export type profileFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * profile aggregateRaw
   */
  export type profileAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * profile.media
   */
  export type profile$mediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the media
     */
    select?: mediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the media
     */
    omit?: mediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mediaInclude<ExtArgs> | null
    where?: mediaWhereInput
    orderBy?: mediaOrderByWithRelationInput | mediaOrderByWithRelationInput[]
    cursor?: mediaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * profile.boosts
   */
  export type profile$boostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the boost
     */
    select?: boostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the boost
     */
    omit?: boostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: boostInclude<ExtArgs> | null
    where?: boostWhereInput
    orderBy?: boostOrderByWithRelationInput | boostOrderByWithRelationInput[]
    cursor?: boostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BoostScalarFieldEnum | BoostScalarFieldEnum[]
  }

  /**
   * profile.strikes
   */
  export type profile$strikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the strike
     */
    select?: strikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the strike
     */
    omit?: strikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: strikeInclude<ExtArgs> | null
    where?: strikeWhereInput
    orderBy?: strikeOrderByWithRelationInput | strikeOrderByWithRelationInput[]
    cursor?: strikeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StrikeScalarFieldEnum | StrikeScalarFieldEnum[]
  }

  /**
   * profile.notes
   */
  export type profile$notesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_note
     */
    select?: user_noteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_note
     */
    omit?: user_noteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_noteInclude<ExtArgs> | null
    where?: user_noteWhereInput
    orderBy?: user_noteOrderByWithRelationInput | user_noteOrderByWithRelationInput[]
    cursor?: user_noteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: User_noteScalarFieldEnum | User_noteScalarFieldEnum[]
  }

  /**
   * profile.contact_events
   */
  export type profile$contact_eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contact_event
     */
    select?: contact_eventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contact_event
     */
    omit?: contact_eventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contact_eventInclude<ExtArgs> | null
    where?: contact_eventWhereInput
    orderBy?: contact_eventOrderByWithRelationInput | contact_eventOrderByWithRelationInput[]
    cursor?: contact_eventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Contact_eventScalarFieldEnum | Contact_eventScalarFieldEnum[]
  }

  /**
   * profile.reports_against
   */
  export type profile$reports_againstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the report
     */
    select?: reportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the report
     */
    omit?: reportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reportInclude<ExtArgs> | null
    where?: reportWhereInput
    orderBy?: reportOrderByWithRelationInput | reportOrderByWithRelationInput[]
    cursor?: reportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * profile.player_tags
   */
  export type profile$player_tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the player_tag
     */
    select?: player_tagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the player_tag
     */
    omit?: player_tagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: player_tagInclude<ExtArgs> | null
    where?: player_tagWhereInput
    orderBy?: player_tagOrderByWithRelationInput | player_tagOrderByWithRelationInput[]
    cursor?: player_tagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Player_tagScalarFieldEnum | Player_tagScalarFieldEnum[]
  }

  /**
   * profile.featured_assignments
   */
  export type profile$featured_assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the featured_assignment
     */
    select?: featured_assignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the featured_assignment
     */
    omit?: featured_assignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: featured_assignmentInclude<ExtArgs> | null
    where?: featured_assignmentWhereInput
    orderBy?: featured_assignmentOrderByWithRelationInput | featured_assignmentOrderByWithRelationInput[]
    cursor?: featured_assignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Featured_assignmentScalarFieldEnum | Featured_assignmentScalarFieldEnum[]
  }

  /**
   * profile without action
   */
  export type profileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the profile
     */
    omit?: profileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: profileInclude<ExtArgs> | null
  }


  /**
   * Model media
   */

  export type AggregateMedia = {
    _count: MediaCountAggregateOutputType | null
    _avg: MediaAvgAggregateOutputType | null
    _sum: MediaSumAggregateOutputType | null
    _min: MediaMinAggregateOutputType | null
    _max: MediaMaxAggregateOutputType | null
  }

  export type MediaAvgAggregateOutputType = {
    width: number | null
    height: number | null
    duration_sec: number | null
    focal_point_x: number | null
    focal_point_y: number | null
    nsfw_score: number | null
  }

  export type MediaSumAggregateOutputType = {
    width: number | null
    height: number | null
    duration_sec: number | null
    focal_point_x: number | null
    focal_point_y: number | null
    nsfw_score: number | null
  }

  export type MediaMinAggregateOutputType = {
    id: string | null
    player_id: string | null
    type: $Enums.media_type | null
    source: $Enums.media_source | null
    url: string | null
    poster_url: string | null
    blur_data_url: string | null
    width: number | null
    height: number | null
    duration_sec: number | null
    focal_point_x: number | null
    focal_point_y: number | null
    hls_url: string | null
    nsfw_score: number | null
    title: string | null
    status: $Enums.media_status | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type MediaMaxAggregateOutputType = {
    id: string | null
    player_id: string | null
    type: $Enums.media_type | null
    source: $Enums.media_source | null
    url: string | null
    poster_url: string | null
    blur_data_url: string | null
    width: number | null
    height: number | null
    duration_sec: number | null
    focal_point_x: number | null
    focal_point_y: number | null
    hls_url: string | null
    nsfw_score: number | null
    title: string | null
    status: $Enums.media_status | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type MediaCountAggregateOutputType = {
    id: number
    player_id: number
    type: number
    source: number
    url: number
    poster_url: number
    blur_data_url: number
    width: number
    height: number
    duration_sec: number
    focal_point_x: number
    focal_point_y: number
    variants: number
    hls_url: number
    nsfw_score: number
    nsfw_labels: number
    title: number
    tags_cache: number
    status: number
    moderation_history: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type MediaAvgAggregateInputType = {
    width?: true
    height?: true
    duration_sec?: true
    focal_point_x?: true
    focal_point_y?: true
    nsfw_score?: true
  }

  export type MediaSumAggregateInputType = {
    width?: true
    height?: true
    duration_sec?: true
    focal_point_x?: true
    focal_point_y?: true
    nsfw_score?: true
  }

  export type MediaMinAggregateInputType = {
    id?: true
    player_id?: true
    type?: true
    source?: true
    url?: true
    poster_url?: true
    blur_data_url?: true
    width?: true
    height?: true
    duration_sec?: true
    focal_point_x?: true
    focal_point_y?: true
    hls_url?: true
    nsfw_score?: true
    title?: true
    status?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type MediaMaxAggregateInputType = {
    id?: true
    player_id?: true
    type?: true
    source?: true
    url?: true
    poster_url?: true
    blur_data_url?: true
    width?: true
    height?: true
    duration_sec?: true
    focal_point_x?: true
    focal_point_y?: true
    hls_url?: true
    nsfw_score?: true
    title?: true
    status?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type MediaCountAggregateInputType = {
    id?: true
    player_id?: true
    type?: true
    source?: true
    url?: true
    poster_url?: true
    blur_data_url?: true
    width?: true
    height?: true
    duration_sec?: true
    focal_point_x?: true
    focal_point_y?: true
    variants?: true
    hls_url?: true
    nsfw_score?: true
    nsfw_labels?: true
    title?: true
    tags_cache?: true
    status?: true
    moderation_history?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type MediaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which media to aggregate.
     */
    where?: mediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of media to fetch.
     */
    orderBy?: mediaOrderByWithRelationInput | mediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: mediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` media.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned media
    **/
    _count?: true | MediaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MediaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MediaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MediaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MediaMaxAggregateInputType
  }

  export type GetMediaAggregateType<T extends MediaAggregateArgs> = {
        [P in keyof T & keyof AggregateMedia]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedia[P]>
      : GetScalarType<T[P], AggregateMedia[P]>
  }




  export type mediaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: mediaWhereInput
    orderBy?: mediaOrderByWithAggregationInput | mediaOrderByWithAggregationInput[]
    by: MediaScalarFieldEnum[] | MediaScalarFieldEnum
    having?: mediaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MediaCountAggregateInputType | true
    _avg?: MediaAvgAggregateInputType
    _sum?: MediaSumAggregateInputType
    _min?: MediaMinAggregateInputType
    _max?: MediaMaxAggregateInputType
  }

  export type MediaGroupByOutputType = {
    id: string
    player_id: string
    type: $Enums.media_type
    source: $Enums.media_source
    url: string
    poster_url: string | null
    blur_data_url: string | null
    width: number | null
    height: number | null
    duration_sec: number | null
    focal_point_x: number | null
    focal_point_y: number | null
    variants: JsonValue | null
    hls_url: string | null
    nsfw_score: number | null
    nsfw_labels: JsonValue | null
    title: string | null
    tags_cache: string[]
    status: $Enums.media_status
    moderation_history: JsonValue | null
    created_at: Date
    updated_at: Date
    deleted_at: Date | null
    _count: MediaCountAggregateOutputType | null
    _avg: MediaAvgAggregateOutputType | null
    _sum: MediaSumAggregateOutputType | null
    _min: MediaMinAggregateOutputType | null
    _max: MediaMaxAggregateOutputType | null
  }

  type GetMediaGroupByPayload<T extends mediaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MediaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MediaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MediaGroupByOutputType[P]>
            : GetScalarType<T[P], MediaGroupByOutputType[P]>
        }
      >
    >


  export type mediaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    player_id?: boolean
    type?: boolean
    source?: boolean
    url?: boolean
    poster_url?: boolean
    blur_data_url?: boolean
    width?: boolean
    height?: boolean
    duration_sec?: boolean
    focal_point_x?: boolean
    focal_point_y?: boolean
    variants?: boolean
    hls_url?: boolean
    nsfw_score?: boolean
    nsfw_labels?: boolean
    title?: boolean
    tags_cache?: boolean
    status?: boolean
    moderation_history?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    player?: boolean | profileDefaultArgs<ExtArgs>
    reports_against?: boolean | media$reports_againstArgs<ExtArgs>
    featured_assignments?: boolean | media$featured_assignmentsArgs<ExtArgs>
    _count?: boolean | MediaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["media"]>



  export type mediaSelectScalar = {
    id?: boolean
    player_id?: boolean
    type?: boolean
    source?: boolean
    url?: boolean
    poster_url?: boolean
    blur_data_url?: boolean
    width?: boolean
    height?: boolean
    duration_sec?: boolean
    focal_point_x?: boolean
    focal_point_y?: boolean
    variants?: boolean
    hls_url?: boolean
    nsfw_score?: boolean
    nsfw_labels?: boolean
    title?: boolean
    tags_cache?: boolean
    status?: boolean
    moderation_history?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }

  export type mediaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "player_id" | "type" | "source" | "url" | "poster_url" | "blur_data_url" | "width" | "height" | "duration_sec" | "focal_point_x" | "focal_point_y" | "variants" | "hls_url" | "nsfw_score" | "nsfw_labels" | "title" | "tags_cache" | "status" | "moderation_history" | "created_at" | "updated_at" | "deleted_at", ExtArgs["result"]["media"]>
  export type mediaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | profileDefaultArgs<ExtArgs>
    reports_against?: boolean | media$reports_againstArgs<ExtArgs>
    featured_assignments?: boolean | media$featured_assignmentsArgs<ExtArgs>
    _count?: boolean | MediaCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $mediaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "media"
    objects: {
      player: Prisma.$profilePayload<ExtArgs>
      reports_against: Prisma.$reportPayload<ExtArgs>[]
      featured_assignments: Prisma.$featured_assignmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      player_id: string
      type: $Enums.media_type
      source: $Enums.media_source
      url: string
      poster_url: string | null
      blur_data_url: string | null
      width: number | null
      height: number | null
      duration_sec: number | null
      focal_point_x: number | null
      focal_point_y: number | null
      variants: Prisma.JsonValue | null
      hls_url: string | null
      nsfw_score: number | null
      nsfw_labels: Prisma.JsonValue | null
      title: string | null
      tags_cache: string[]
      status: $Enums.media_status
      moderation_history: Prisma.JsonValue | null
      created_at: Date
      updated_at: Date
      deleted_at: Date | null
    }, ExtArgs["result"]["media"]>
    composites: {}
  }

  type mediaGetPayload<S extends boolean | null | undefined | mediaDefaultArgs> = $Result.GetResult<Prisma.$mediaPayload, S>

  type mediaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<mediaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MediaCountAggregateInputType | true
    }

  export interface mediaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['media'], meta: { name: 'media' } }
    /**
     * Find zero or one Media that matches the filter.
     * @param {mediaFindUniqueArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends mediaFindUniqueArgs>(args: SelectSubset<T, mediaFindUniqueArgs<ExtArgs>>): Prisma__mediaClient<$Result.GetResult<Prisma.$mediaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Media that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {mediaFindUniqueOrThrowArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends mediaFindUniqueOrThrowArgs>(args: SelectSubset<T, mediaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__mediaClient<$Result.GetResult<Prisma.$mediaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Media that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mediaFindFirstArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends mediaFindFirstArgs>(args?: SelectSubset<T, mediaFindFirstArgs<ExtArgs>>): Prisma__mediaClient<$Result.GetResult<Prisma.$mediaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Media that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mediaFindFirstOrThrowArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends mediaFindFirstOrThrowArgs>(args?: SelectSubset<T, mediaFindFirstOrThrowArgs<ExtArgs>>): Prisma__mediaClient<$Result.GetResult<Prisma.$mediaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Media that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mediaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Media
     * const media = await prisma.media.findMany()
     * 
     * // Get first 10 Media
     * const media = await prisma.media.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mediaWithIdOnly = await prisma.media.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends mediaFindManyArgs>(args?: SelectSubset<T, mediaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mediaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Media.
     * @param {mediaCreateArgs} args - Arguments to create a Media.
     * @example
     * // Create one Media
     * const Media = await prisma.media.create({
     *   data: {
     *     // ... data to create a Media
     *   }
     * })
     * 
     */
    create<T extends mediaCreateArgs>(args: SelectSubset<T, mediaCreateArgs<ExtArgs>>): Prisma__mediaClient<$Result.GetResult<Prisma.$mediaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Media.
     * @param {mediaCreateManyArgs} args - Arguments to create many Media.
     * @example
     * // Create many Media
     * const media = await prisma.media.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends mediaCreateManyArgs>(args?: SelectSubset<T, mediaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Media.
     * @param {mediaDeleteArgs} args - Arguments to delete one Media.
     * @example
     * // Delete one Media
     * const Media = await prisma.media.delete({
     *   where: {
     *     // ... filter to delete one Media
     *   }
     * })
     * 
     */
    delete<T extends mediaDeleteArgs>(args: SelectSubset<T, mediaDeleteArgs<ExtArgs>>): Prisma__mediaClient<$Result.GetResult<Prisma.$mediaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Media.
     * @param {mediaUpdateArgs} args - Arguments to update one Media.
     * @example
     * // Update one Media
     * const media = await prisma.media.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends mediaUpdateArgs>(args: SelectSubset<T, mediaUpdateArgs<ExtArgs>>): Prisma__mediaClient<$Result.GetResult<Prisma.$mediaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Media.
     * @param {mediaDeleteManyArgs} args - Arguments to filter Media to delete.
     * @example
     * // Delete a few Media
     * const { count } = await prisma.media.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends mediaDeleteManyArgs>(args?: SelectSubset<T, mediaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mediaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Media
     * const media = await prisma.media.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends mediaUpdateManyArgs>(args: SelectSubset<T, mediaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Media.
     * @param {mediaUpsertArgs} args - Arguments to update or create a Media.
     * @example
     * // Update or create a Media
     * const media = await prisma.media.upsert({
     *   create: {
     *     // ... data to create a Media
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Media we want to update
     *   }
     * })
     */
    upsert<T extends mediaUpsertArgs>(args: SelectSubset<T, mediaUpsertArgs<ExtArgs>>): Prisma__mediaClient<$Result.GetResult<Prisma.$mediaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Media that matches the filter.
     * @param {mediaFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const media = await prisma.media.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: mediaFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Media.
     * @param {mediaAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const media = await prisma.media.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: mediaAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mediaCountArgs} args - Arguments to filter Media to count.
     * @example
     * // Count the number of Media
     * const count = await prisma.media.count({
     *   where: {
     *     // ... the filter for the Media we want to count
     *   }
     * })
    **/
    count<T extends mediaCountArgs>(
      args?: Subset<T, mediaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MediaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MediaAggregateArgs>(args: Subset<T, MediaAggregateArgs>): Prisma.PrismaPromise<GetMediaAggregateType<T>>

    /**
     * Group by Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mediaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends mediaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: mediaGroupByArgs['orderBy'] }
        : { orderBy?: mediaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, mediaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMediaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the media model
   */
  readonly fields: mediaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for media.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__mediaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    player<T extends profileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, profileDefaultArgs<ExtArgs>>): Prisma__profileClient<$Result.GetResult<Prisma.$profilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    reports_against<T extends media$reports_againstArgs<ExtArgs> = {}>(args?: Subset<T, media$reports_againstArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    featured_assignments<T extends media$featured_assignmentsArgs<ExtArgs> = {}>(args?: Subset<T, media$featured_assignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$featured_assignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the media model
   */
  interface mediaFieldRefs {
    readonly id: FieldRef<"media", 'String'>
    readonly player_id: FieldRef<"media", 'String'>
    readonly type: FieldRef<"media", 'media_type'>
    readonly source: FieldRef<"media", 'media_source'>
    readonly url: FieldRef<"media", 'String'>
    readonly poster_url: FieldRef<"media", 'String'>
    readonly blur_data_url: FieldRef<"media", 'String'>
    readonly width: FieldRef<"media", 'Int'>
    readonly height: FieldRef<"media", 'Int'>
    readonly duration_sec: FieldRef<"media", 'Int'>
    readonly focal_point_x: FieldRef<"media", 'Int'>
    readonly focal_point_y: FieldRef<"media", 'Int'>
    readonly variants: FieldRef<"media", 'Json'>
    readonly hls_url: FieldRef<"media", 'String'>
    readonly nsfw_score: FieldRef<"media", 'Float'>
    readonly nsfw_labels: FieldRef<"media", 'Json'>
    readonly title: FieldRef<"media", 'String'>
    readonly tags_cache: FieldRef<"media", 'String[]'>
    readonly status: FieldRef<"media", 'media_status'>
    readonly moderation_history: FieldRef<"media", 'Json'>
    readonly created_at: FieldRef<"media", 'DateTime'>
    readonly updated_at: FieldRef<"media", 'DateTime'>
    readonly deleted_at: FieldRef<"media", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * media findUnique
   */
  export type mediaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the media
     */
    select?: mediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the media
     */
    omit?: mediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mediaInclude<ExtArgs> | null
    /**
     * Filter, which media to fetch.
     */
    where: mediaWhereUniqueInput
  }

  /**
   * media findUniqueOrThrow
   */
  export type mediaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the media
     */
    select?: mediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the media
     */
    omit?: mediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mediaInclude<ExtArgs> | null
    /**
     * Filter, which media to fetch.
     */
    where: mediaWhereUniqueInput
  }

  /**
   * media findFirst
   */
  export type mediaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the media
     */
    select?: mediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the media
     */
    omit?: mediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mediaInclude<ExtArgs> | null
    /**
     * Filter, which media to fetch.
     */
    where?: mediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of media to fetch.
     */
    orderBy?: mediaOrderByWithRelationInput | mediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for media.
     */
    cursor?: mediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` media.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of media.
     */
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * media findFirstOrThrow
   */
  export type mediaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the media
     */
    select?: mediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the media
     */
    omit?: mediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mediaInclude<ExtArgs> | null
    /**
     * Filter, which media to fetch.
     */
    where?: mediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of media to fetch.
     */
    orderBy?: mediaOrderByWithRelationInput | mediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for media.
     */
    cursor?: mediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` media.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of media.
     */
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * media findMany
   */
  export type mediaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the media
     */
    select?: mediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the media
     */
    omit?: mediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mediaInclude<ExtArgs> | null
    /**
     * Filter, which media to fetch.
     */
    where?: mediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of media to fetch.
     */
    orderBy?: mediaOrderByWithRelationInput | mediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing media.
     */
    cursor?: mediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` media.
     */
    skip?: number
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * media create
   */
  export type mediaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the media
     */
    select?: mediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the media
     */
    omit?: mediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mediaInclude<ExtArgs> | null
    /**
     * The data needed to create a media.
     */
    data: XOR<mediaCreateInput, mediaUncheckedCreateInput>
  }

  /**
   * media createMany
   */
  export type mediaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many media.
     */
    data: mediaCreateManyInput | mediaCreateManyInput[]
  }

  /**
   * media update
   */
  export type mediaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the media
     */
    select?: mediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the media
     */
    omit?: mediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mediaInclude<ExtArgs> | null
    /**
     * The data needed to update a media.
     */
    data: XOR<mediaUpdateInput, mediaUncheckedUpdateInput>
    /**
     * Choose, which media to update.
     */
    where: mediaWhereUniqueInput
  }

  /**
   * media updateMany
   */
  export type mediaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update media.
     */
    data: XOR<mediaUpdateManyMutationInput, mediaUncheckedUpdateManyInput>
    /**
     * Filter which media to update
     */
    where?: mediaWhereInput
    /**
     * Limit how many media to update.
     */
    limit?: number
  }

  /**
   * media upsert
   */
  export type mediaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the media
     */
    select?: mediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the media
     */
    omit?: mediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mediaInclude<ExtArgs> | null
    /**
     * The filter to search for the media to update in case it exists.
     */
    where: mediaWhereUniqueInput
    /**
     * In case the media found by the `where` argument doesn't exist, create a new media with this data.
     */
    create: XOR<mediaCreateInput, mediaUncheckedCreateInput>
    /**
     * In case the media was found with the provided `where` argument, update it with this data.
     */
    update: XOR<mediaUpdateInput, mediaUncheckedUpdateInput>
  }

  /**
   * media delete
   */
  export type mediaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the media
     */
    select?: mediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the media
     */
    omit?: mediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mediaInclude<ExtArgs> | null
    /**
     * Filter which media to delete.
     */
    where: mediaWhereUniqueInput
  }

  /**
   * media deleteMany
   */
  export type mediaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which media to delete
     */
    where?: mediaWhereInput
    /**
     * Limit how many media to delete.
     */
    limit?: number
  }

  /**
   * media findRaw
   */
  export type mediaFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * media aggregateRaw
   */
  export type mediaAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * media.reports_against
   */
  export type media$reports_againstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the report
     */
    select?: reportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the report
     */
    omit?: reportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reportInclude<ExtArgs> | null
    where?: reportWhereInput
    orderBy?: reportOrderByWithRelationInput | reportOrderByWithRelationInput[]
    cursor?: reportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * media.featured_assignments
   */
  export type media$featured_assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the featured_assignment
     */
    select?: featured_assignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the featured_assignment
     */
    omit?: featured_assignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: featured_assignmentInclude<ExtArgs> | null
    where?: featured_assignmentWhereInput
    orderBy?: featured_assignmentOrderByWithRelationInput | featured_assignmentOrderByWithRelationInput[]
    cursor?: featured_assignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Featured_assignmentScalarFieldEnum | Featured_assignmentScalarFieldEnum[]
  }

  /**
   * media without action
   */
  export type mediaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the media
     */
    select?: mediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the media
     */
    omit?: mediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mediaInclude<ExtArgs> | null
  }


  /**
   * Model tag
   */

  export type AggregateTag = {
    _count: TagCountAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  export type TagMinAggregateOutputType = {
    id: string | null
    slug: string | null
    label: string | null
    status: $Enums.setting_status | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type TagMaxAggregateOutputType = {
    id: string | null
    slug: string | null
    label: string | null
    status: $Enums.setting_status | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type TagCountAggregateOutputType = {
    id: number
    slug: number
    label: number
    aliases: number
    status: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type TagMinAggregateInputType = {
    id?: true
    slug?: true
    label?: true
    status?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type TagMaxAggregateInputType = {
    id?: true
    slug?: true
    label?: true
    status?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type TagCountAggregateInputType = {
    id?: true
    slug?: true
    label?: true
    aliases?: true
    status?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type TagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tag to aggregate.
     */
    where?: tagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tags to fetch.
     */
    orderBy?: tagOrderByWithRelationInput | tagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tags
    **/
    _count?: true | TagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagMaxAggregateInputType
  }

  export type GetTagAggregateType<T extends TagAggregateArgs> = {
        [P in keyof T & keyof AggregateTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTag[P]>
      : GetScalarType<T[P], AggregateTag[P]>
  }




  export type tagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tagWhereInput
    orderBy?: tagOrderByWithAggregationInput | tagOrderByWithAggregationInput[]
    by: TagScalarFieldEnum[] | TagScalarFieldEnum
    having?: tagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagCountAggregateInputType | true
    _min?: TagMinAggregateInputType
    _max?: TagMaxAggregateInputType
  }

  export type TagGroupByOutputType = {
    id: string
    slug: string
    label: string
    aliases: string[]
    status: $Enums.setting_status
    created_at: Date
    updated_at: Date
    deleted_at: Date | null
    _count: TagCountAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  type GetTagGroupByPayload<T extends tagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagGroupByOutputType[P]>
            : GetScalarType<T[P], TagGroupByOutputType[P]>
        }
      >
    >


  export type tagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    label?: boolean
    aliases?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    player_tags?: boolean | tag$player_tagsArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tag"]>



  export type tagSelectScalar = {
    id?: boolean
    slug?: boolean
    label?: boolean
    aliases?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }

  export type tagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "slug" | "label" | "aliases" | "status" | "created_at" | "updated_at" | "deleted_at", ExtArgs["result"]["tag"]>
  export type tagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player_tags?: boolean | tag$player_tagsArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $tagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tag"
    objects: {
      player_tags: Prisma.$player_tagPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      slug: string
      label: string
      aliases: string[]
      status: $Enums.setting_status
      created_at: Date
      updated_at: Date
      deleted_at: Date | null
    }, ExtArgs["result"]["tag"]>
    composites: {}
  }

  type tagGetPayload<S extends boolean | null | undefined | tagDefaultArgs> = $Result.GetResult<Prisma.$tagPayload, S>

  type tagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TagCountAggregateInputType | true
    }

  export interface tagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tag'], meta: { name: 'tag' } }
    /**
     * Find zero or one Tag that matches the filter.
     * @param {tagFindUniqueArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tagFindUniqueArgs>(args: SelectSubset<T, tagFindUniqueArgs<ExtArgs>>): Prisma__tagClient<$Result.GetResult<Prisma.$tagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tagFindUniqueOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tagFindUniqueOrThrowArgs>(args: SelectSubset<T, tagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tagClient<$Result.GetResult<Prisma.$tagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tagFindFirstArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tagFindFirstArgs>(args?: SelectSubset<T, tagFindFirstArgs<ExtArgs>>): Prisma__tagClient<$Result.GetResult<Prisma.$tagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tagFindFirstOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tagFindFirstOrThrowArgs>(args?: SelectSubset<T, tagFindFirstOrThrowArgs<ExtArgs>>): Prisma__tagClient<$Result.GetResult<Prisma.$tagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tags
     * const tags = await prisma.tag.findMany()
     * 
     * // Get first 10 Tags
     * const tags = await prisma.tag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tagWithIdOnly = await prisma.tag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends tagFindManyArgs>(args?: SelectSubset<T, tagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tag.
     * @param {tagCreateArgs} args - Arguments to create a Tag.
     * @example
     * // Create one Tag
     * const Tag = await prisma.tag.create({
     *   data: {
     *     // ... data to create a Tag
     *   }
     * })
     * 
     */
    create<T extends tagCreateArgs>(args: SelectSubset<T, tagCreateArgs<ExtArgs>>): Prisma__tagClient<$Result.GetResult<Prisma.$tagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tags.
     * @param {tagCreateManyArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tagCreateManyArgs>(args?: SelectSubset<T, tagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tag.
     * @param {tagDeleteArgs} args - Arguments to delete one Tag.
     * @example
     * // Delete one Tag
     * const Tag = await prisma.tag.delete({
     *   where: {
     *     // ... filter to delete one Tag
     *   }
     * })
     * 
     */
    delete<T extends tagDeleteArgs>(args: SelectSubset<T, tagDeleteArgs<ExtArgs>>): Prisma__tagClient<$Result.GetResult<Prisma.$tagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tag.
     * @param {tagUpdateArgs} args - Arguments to update one Tag.
     * @example
     * // Update one Tag
     * const tag = await prisma.tag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tagUpdateArgs>(args: SelectSubset<T, tagUpdateArgs<ExtArgs>>): Prisma__tagClient<$Result.GetResult<Prisma.$tagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tags.
     * @param {tagDeleteManyArgs} args - Arguments to filter Tags to delete.
     * @example
     * // Delete a few Tags
     * const { count } = await prisma.tag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tagDeleteManyArgs>(args?: SelectSubset<T, tagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tagUpdateManyArgs>(args: SelectSubset<T, tagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tag.
     * @param {tagUpsertArgs} args - Arguments to update or create a Tag.
     * @example
     * // Update or create a Tag
     * const tag = await prisma.tag.upsert({
     *   create: {
     *     // ... data to create a Tag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tag we want to update
     *   }
     * })
     */
    upsert<T extends tagUpsertArgs>(args: SelectSubset<T, tagUpsertArgs<ExtArgs>>): Prisma__tagClient<$Result.GetResult<Prisma.$tagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tags that matches the filter.
     * @param {tagFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const tag = await prisma.tag.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: tagFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Tag.
     * @param {tagAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const tag = await prisma.tag.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: tagAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tagCountArgs} args - Arguments to filter Tags to count.
     * @example
     * // Count the number of Tags
     * const count = await prisma.tag.count({
     *   where: {
     *     // ... the filter for the Tags we want to count
     *   }
     * })
    **/
    count<T extends tagCountArgs>(
      args?: Subset<T, tagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagAggregateArgs>(args: Subset<T, TagAggregateArgs>): Prisma.PrismaPromise<GetTagAggregateType<T>>

    /**
     * Group by Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tagGroupByArgs['orderBy'] }
        : { orderBy?: tagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tag model
   */
  readonly fields: tagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    player_tags<T extends tag$player_tagsArgs<ExtArgs> = {}>(args?: Subset<T, tag$player_tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$player_tagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tag model
   */
  interface tagFieldRefs {
    readonly id: FieldRef<"tag", 'String'>
    readonly slug: FieldRef<"tag", 'String'>
    readonly label: FieldRef<"tag", 'String'>
    readonly aliases: FieldRef<"tag", 'String[]'>
    readonly status: FieldRef<"tag", 'setting_status'>
    readonly created_at: FieldRef<"tag", 'DateTime'>
    readonly updated_at: FieldRef<"tag", 'DateTime'>
    readonly deleted_at: FieldRef<"tag", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * tag findUnique
   */
  export type tagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tag
     */
    select?: tagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tag
     */
    omit?: tagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagInclude<ExtArgs> | null
    /**
     * Filter, which tag to fetch.
     */
    where: tagWhereUniqueInput
  }

  /**
   * tag findUniqueOrThrow
   */
  export type tagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tag
     */
    select?: tagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tag
     */
    omit?: tagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagInclude<ExtArgs> | null
    /**
     * Filter, which tag to fetch.
     */
    where: tagWhereUniqueInput
  }

  /**
   * tag findFirst
   */
  export type tagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tag
     */
    select?: tagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tag
     */
    omit?: tagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagInclude<ExtArgs> | null
    /**
     * Filter, which tag to fetch.
     */
    where?: tagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tags to fetch.
     */
    orderBy?: tagOrderByWithRelationInput | tagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tags.
     */
    cursor?: tagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * tag findFirstOrThrow
   */
  export type tagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tag
     */
    select?: tagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tag
     */
    omit?: tagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagInclude<ExtArgs> | null
    /**
     * Filter, which tag to fetch.
     */
    where?: tagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tags to fetch.
     */
    orderBy?: tagOrderByWithRelationInput | tagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tags.
     */
    cursor?: tagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * tag findMany
   */
  export type tagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tag
     */
    select?: tagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tag
     */
    omit?: tagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagInclude<ExtArgs> | null
    /**
     * Filter, which tags to fetch.
     */
    where?: tagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tags to fetch.
     */
    orderBy?: tagOrderByWithRelationInput | tagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tags.
     */
    cursor?: tagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tags.
     */
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * tag create
   */
  export type tagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tag
     */
    select?: tagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tag
     */
    omit?: tagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagInclude<ExtArgs> | null
    /**
     * The data needed to create a tag.
     */
    data: XOR<tagCreateInput, tagUncheckedCreateInput>
  }

  /**
   * tag createMany
   */
  export type tagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tags.
     */
    data: tagCreateManyInput | tagCreateManyInput[]
  }

  /**
   * tag update
   */
  export type tagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tag
     */
    select?: tagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tag
     */
    omit?: tagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagInclude<ExtArgs> | null
    /**
     * The data needed to update a tag.
     */
    data: XOR<tagUpdateInput, tagUncheckedUpdateInput>
    /**
     * Choose, which tag to update.
     */
    where: tagWhereUniqueInput
  }

  /**
   * tag updateMany
   */
  export type tagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tags.
     */
    data: XOR<tagUpdateManyMutationInput, tagUncheckedUpdateManyInput>
    /**
     * Filter which tags to update
     */
    where?: tagWhereInput
    /**
     * Limit how many tags to update.
     */
    limit?: number
  }

  /**
   * tag upsert
   */
  export type tagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tag
     */
    select?: tagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tag
     */
    omit?: tagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagInclude<ExtArgs> | null
    /**
     * The filter to search for the tag to update in case it exists.
     */
    where: tagWhereUniqueInput
    /**
     * In case the tag found by the `where` argument doesn't exist, create a new tag with this data.
     */
    create: XOR<tagCreateInput, tagUncheckedCreateInput>
    /**
     * In case the tag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tagUpdateInput, tagUncheckedUpdateInput>
  }

  /**
   * tag delete
   */
  export type tagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tag
     */
    select?: tagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tag
     */
    omit?: tagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagInclude<ExtArgs> | null
    /**
     * Filter which tag to delete.
     */
    where: tagWhereUniqueInput
  }

  /**
   * tag deleteMany
   */
  export type tagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tags to delete
     */
    where?: tagWhereInput
    /**
     * Limit how many tags to delete.
     */
    limit?: number
  }

  /**
   * tag findRaw
   */
  export type tagFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * tag aggregateRaw
   */
  export type tagAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * tag.player_tags
   */
  export type tag$player_tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the player_tag
     */
    select?: player_tagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the player_tag
     */
    omit?: player_tagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: player_tagInclude<ExtArgs> | null
    where?: player_tagWhereInput
    orderBy?: player_tagOrderByWithRelationInput | player_tagOrderByWithRelationInput[]
    cursor?: player_tagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Player_tagScalarFieldEnum | Player_tagScalarFieldEnum[]
  }

  /**
   * tag without action
   */
  export type tagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tag
     */
    select?: tagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tag
     */
    omit?: tagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagInclude<ExtArgs> | null
  }


  /**
   * Model player_tag
   */

  export type AggregatePlayer_tag = {
    _count: Player_tagCountAggregateOutputType | null
    _min: Player_tagMinAggregateOutputType | null
    _max: Player_tagMaxAggregateOutputType | null
  }

  export type Player_tagMinAggregateOutputType = {
    id: string | null
    player_id: string | null
    tag_id: string | null
    status: $Enums.setting_status | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type Player_tagMaxAggregateOutputType = {
    id: string | null
    player_id: string | null
    tag_id: string | null
    status: $Enums.setting_status | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type Player_tagCountAggregateOutputType = {
    id: number
    player_id: number
    tag_id: number
    status: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type Player_tagMinAggregateInputType = {
    id?: true
    player_id?: true
    tag_id?: true
    status?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type Player_tagMaxAggregateInputType = {
    id?: true
    player_id?: true
    tag_id?: true
    status?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type Player_tagCountAggregateInputType = {
    id?: true
    player_id?: true
    tag_id?: true
    status?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type Player_tagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which player_tag to aggregate.
     */
    where?: player_tagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of player_tags to fetch.
     */
    orderBy?: player_tagOrderByWithRelationInput | player_tagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: player_tagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` player_tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` player_tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned player_tags
    **/
    _count?: true | Player_tagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Player_tagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Player_tagMaxAggregateInputType
  }

  export type GetPlayer_tagAggregateType<T extends Player_tagAggregateArgs> = {
        [P in keyof T & keyof AggregatePlayer_tag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlayer_tag[P]>
      : GetScalarType<T[P], AggregatePlayer_tag[P]>
  }




  export type player_tagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: player_tagWhereInput
    orderBy?: player_tagOrderByWithAggregationInput | player_tagOrderByWithAggregationInput[]
    by: Player_tagScalarFieldEnum[] | Player_tagScalarFieldEnum
    having?: player_tagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Player_tagCountAggregateInputType | true
    _min?: Player_tagMinAggregateInputType
    _max?: Player_tagMaxAggregateInputType
  }

  export type Player_tagGroupByOutputType = {
    id: string
    player_id: string
    tag_id: string
    status: $Enums.setting_status
    created_at: Date
    updated_at: Date
    deleted_at: Date | null
    _count: Player_tagCountAggregateOutputType | null
    _min: Player_tagMinAggregateOutputType | null
    _max: Player_tagMaxAggregateOutputType | null
  }

  type GetPlayer_tagGroupByPayload<T extends player_tagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Player_tagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Player_tagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Player_tagGroupByOutputType[P]>
            : GetScalarType<T[P], Player_tagGroupByOutputType[P]>
        }
      >
    >


  export type player_tagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    player_id?: boolean
    tag_id?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    player?: boolean | profileDefaultArgs<ExtArgs>
    tag_ref?: boolean | tagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["player_tag"]>



  export type player_tagSelectScalar = {
    id?: boolean
    player_id?: boolean
    tag_id?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }

  export type player_tagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "player_id" | "tag_id" | "status" | "created_at" | "updated_at" | "deleted_at", ExtArgs["result"]["player_tag"]>
  export type player_tagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | profileDefaultArgs<ExtArgs>
    tag_ref?: boolean | tagDefaultArgs<ExtArgs>
  }

  export type $player_tagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "player_tag"
    objects: {
      player: Prisma.$profilePayload<ExtArgs>
      tag_ref: Prisma.$tagPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      player_id: string
      tag_id: string
      status: $Enums.setting_status
      created_at: Date
      updated_at: Date
      deleted_at: Date | null
    }, ExtArgs["result"]["player_tag"]>
    composites: {}
  }

  type player_tagGetPayload<S extends boolean | null | undefined | player_tagDefaultArgs> = $Result.GetResult<Prisma.$player_tagPayload, S>

  type player_tagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<player_tagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Player_tagCountAggregateInputType | true
    }

  export interface player_tagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['player_tag'], meta: { name: 'player_tag' } }
    /**
     * Find zero or one Player_tag that matches the filter.
     * @param {player_tagFindUniqueArgs} args - Arguments to find a Player_tag
     * @example
     * // Get one Player_tag
     * const player_tag = await prisma.player_tag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends player_tagFindUniqueArgs>(args: SelectSubset<T, player_tagFindUniqueArgs<ExtArgs>>): Prisma__player_tagClient<$Result.GetResult<Prisma.$player_tagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Player_tag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {player_tagFindUniqueOrThrowArgs} args - Arguments to find a Player_tag
     * @example
     * // Get one Player_tag
     * const player_tag = await prisma.player_tag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends player_tagFindUniqueOrThrowArgs>(args: SelectSubset<T, player_tagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__player_tagClient<$Result.GetResult<Prisma.$player_tagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Player_tag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {player_tagFindFirstArgs} args - Arguments to find a Player_tag
     * @example
     * // Get one Player_tag
     * const player_tag = await prisma.player_tag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends player_tagFindFirstArgs>(args?: SelectSubset<T, player_tagFindFirstArgs<ExtArgs>>): Prisma__player_tagClient<$Result.GetResult<Prisma.$player_tagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Player_tag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {player_tagFindFirstOrThrowArgs} args - Arguments to find a Player_tag
     * @example
     * // Get one Player_tag
     * const player_tag = await prisma.player_tag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends player_tagFindFirstOrThrowArgs>(args?: SelectSubset<T, player_tagFindFirstOrThrowArgs<ExtArgs>>): Prisma__player_tagClient<$Result.GetResult<Prisma.$player_tagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Player_tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {player_tagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Player_tags
     * const player_tags = await prisma.player_tag.findMany()
     * 
     * // Get first 10 Player_tags
     * const player_tags = await prisma.player_tag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const player_tagWithIdOnly = await prisma.player_tag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends player_tagFindManyArgs>(args?: SelectSubset<T, player_tagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$player_tagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Player_tag.
     * @param {player_tagCreateArgs} args - Arguments to create a Player_tag.
     * @example
     * // Create one Player_tag
     * const Player_tag = await prisma.player_tag.create({
     *   data: {
     *     // ... data to create a Player_tag
     *   }
     * })
     * 
     */
    create<T extends player_tagCreateArgs>(args: SelectSubset<T, player_tagCreateArgs<ExtArgs>>): Prisma__player_tagClient<$Result.GetResult<Prisma.$player_tagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Player_tags.
     * @param {player_tagCreateManyArgs} args - Arguments to create many Player_tags.
     * @example
     * // Create many Player_tags
     * const player_tag = await prisma.player_tag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends player_tagCreateManyArgs>(args?: SelectSubset<T, player_tagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Player_tag.
     * @param {player_tagDeleteArgs} args - Arguments to delete one Player_tag.
     * @example
     * // Delete one Player_tag
     * const Player_tag = await prisma.player_tag.delete({
     *   where: {
     *     // ... filter to delete one Player_tag
     *   }
     * })
     * 
     */
    delete<T extends player_tagDeleteArgs>(args: SelectSubset<T, player_tagDeleteArgs<ExtArgs>>): Prisma__player_tagClient<$Result.GetResult<Prisma.$player_tagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Player_tag.
     * @param {player_tagUpdateArgs} args - Arguments to update one Player_tag.
     * @example
     * // Update one Player_tag
     * const player_tag = await prisma.player_tag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends player_tagUpdateArgs>(args: SelectSubset<T, player_tagUpdateArgs<ExtArgs>>): Prisma__player_tagClient<$Result.GetResult<Prisma.$player_tagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Player_tags.
     * @param {player_tagDeleteManyArgs} args - Arguments to filter Player_tags to delete.
     * @example
     * // Delete a few Player_tags
     * const { count } = await prisma.player_tag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends player_tagDeleteManyArgs>(args?: SelectSubset<T, player_tagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Player_tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {player_tagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Player_tags
     * const player_tag = await prisma.player_tag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends player_tagUpdateManyArgs>(args: SelectSubset<T, player_tagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Player_tag.
     * @param {player_tagUpsertArgs} args - Arguments to update or create a Player_tag.
     * @example
     * // Update or create a Player_tag
     * const player_tag = await prisma.player_tag.upsert({
     *   create: {
     *     // ... data to create a Player_tag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Player_tag we want to update
     *   }
     * })
     */
    upsert<T extends player_tagUpsertArgs>(args: SelectSubset<T, player_tagUpsertArgs<ExtArgs>>): Prisma__player_tagClient<$Result.GetResult<Prisma.$player_tagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Player_tags that matches the filter.
     * @param {player_tagFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const player_tag = await prisma.player_tag.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: player_tagFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Player_tag.
     * @param {player_tagAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const player_tag = await prisma.player_tag.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: player_tagAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Player_tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {player_tagCountArgs} args - Arguments to filter Player_tags to count.
     * @example
     * // Count the number of Player_tags
     * const count = await prisma.player_tag.count({
     *   where: {
     *     // ... the filter for the Player_tags we want to count
     *   }
     * })
    **/
    count<T extends player_tagCountArgs>(
      args?: Subset<T, player_tagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Player_tagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Player_tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Player_tagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Player_tagAggregateArgs>(args: Subset<T, Player_tagAggregateArgs>): Prisma.PrismaPromise<GetPlayer_tagAggregateType<T>>

    /**
     * Group by Player_tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {player_tagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends player_tagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: player_tagGroupByArgs['orderBy'] }
        : { orderBy?: player_tagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, player_tagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlayer_tagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the player_tag model
   */
  readonly fields: player_tagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for player_tag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__player_tagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    player<T extends profileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, profileDefaultArgs<ExtArgs>>): Prisma__profileClient<$Result.GetResult<Prisma.$profilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tag_ref<T extends tagDefaultArgs<ExtArgs> = {}>(args?: Subset<T, tagDefaultArgs<ExtArgs>>): Prisma__tagClient<$Result.GetResult<Prisma.$tagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the player_tag model
   */
  interface player_tagFieldRefs {
    readonly id: FieldRef<"player_tag", 'String'>
    readonly player_id: FieldRef<"player_tag", 'String'>
    readonly tag_id: FieldRef<"player_tag", 'String'>
    readonly status: FieldRef<"player_tag", 'setting_status'>
    readonly created_at: FieldRef<"player_tag", 'DateTime'>
    readonly updated_at: FieldRef<"player_tag", 'DateTime'>
    readonly deleted_at: FieldRef<"player_tag", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * player_tag findUnique
   */
  export type player_tagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the player_tag
     */
    select?: player_tagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the player_tag
     */
    omit?: player_tagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: player_tagInclude<ExtArgs> | null
    /**
     * Filter, which player_tag to fetch.
     */
    where: player_tagWhereUniqueInput
  }

  /**
   * player_tag findUniqueOrThrow
   */
  export type player_tagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the player_tag
     */
    select?: player_tagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the player_tag
     */
    omit?: player_tagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: player_tagInclude<ExtArgs> | null
    /**
     * Filter, which player_tag to fetch.
     */
    where: player_tagWhereUniqueInput
  }

  /**
   * player_tag findFirst
   */
  export type player_tagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the player_tag
     */
    select?: player_tagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the player_tag
     */
    omit?: player_tagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: player_tagInclude<ExtArgs> | null
    /**
     * Filter, which player_tag to fetch.
     */
    where?: player_tagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of player_tags to fetch.
     */
    orderBy?: player_tagOrderByWithRelationInput | player_tagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for player_tags.
     */
    cursor?: player_tagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` player_tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` player_tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of player_tags.
     */
    distinct?: Player_tagScalarFieldEnum | Player_tagScalarFieldEnum[]
  }

  /**
   * player_tag findFirstOrThrow
   */
  export type player_tagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the player_tag
     */
    select?: player_tagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the player_tag
     */
    omit?: player_tagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: player_tagInclude<ExtArgs> | null
    /**
     * Filter, which player_tag to fetch.
     */
    where?: player_tagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of player_tags to fetch.
     */
    orderBy?: player_tagOrderByWithRelationInput | player_tagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for player_tags.
     */
    cursor?: player_tagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` player_tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` player_tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of player_tags.
     */
    distinct?: Player_tagScalarFieldEnum | Player_tagScalarFieldEnum[]
  }

  /**
   * player_tag findMany
   */
  export type player_tagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the player_tag
     */
    select?: player_tagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the player_tag
     */
    omit?: player_tagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: player_tagInclude<ExtArgs> | null
    /**
     * Filter, which player_tags to fetch.
     */
    where?: player_tagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of player_tags to fetch.
     */
    orderBy?: player_tagOrderByWithRelationInput | player_tagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing player_tags.
     */
    cursor?: player_tagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` player_tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` player_tags.
     */
    skip?: number
    distinct?: Player_tagScalarFieldEnum | Player_tagScalarFieldEnum[]
  }

  /**
   * player_tag create
   */
  export type player_tagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the player_tag
     */
    select?: player_tagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the player_tag
     */
    omit?: player_tagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: player_tagInclude<ExtArgs> | null
    /**
     * The data needed to create a player_tag.
     */
    data: XOR<player_tagCreateInput, player_tagUncheckedCreateInput>
  }

  /**
   * player_tag createMany
   */
  export type player_tagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many player_tags.
     */
    data: player_tagCreateManyInput | player_tagCreateManyInput[]
  }

  /**
   * player_tag update
   */
  export type player_tagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the player_tag
     */
    select?: player_tagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the player_tag
     */
    omit?: player_tagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: player_tagInclude<ExtArgs> | null
    /**
     * The data needed to update a player_tag.
     */
    data: XOR<player_tagUpdateInput, player_tagUncheckedUpdateInput>
    /**
     * Choose, which player_tag to update.
     */
    where: player_tagWhereUniqueInput
  }

  /**
   * player_tag updateMany
   */
  export type player_tagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update player_tags.
     */
    data: XOR<player_tagUpdateManyMutationInput, player_tagUncheckedUpdateManyInput>
    /**
     * Filter which player_tags to update
     */
    where?: player_tagWhereInput
    /**
     * Limit how many player_tags to update.
     */
    limit?: number
  }

  /**
   * player_tag upsert
   */
  export type player_tagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the player_tag
     */
    select?: player_tagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the player_tag
     */
    omit?: player_tagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: player_tagInclude<ExtArgs> | null
    /**
     * The filter to search for the player_tag to update in case it exists.
     */
    where: player_tagWhereUniqueInput
    /**
     * In case the player_tag found by the `where` argument doesn't exist, create a new player_tag with this data.
     */
    create: XOR<player_tagCreateInput, player_tagUncheckedCreateInput>
    /**
     * In case the player_tag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<player_tagUpdateInput, player_tagUncheckedUpdateInput>
  }

  /**
   * player_tag delete
   */
  export type player_tagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the player_tag
     */
    select?: player_tagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the player_tag
     */
    omit?: player_tagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: player_tagInclude<ExtArgs> | null
    /**
     * Filter which player_tag to delete.
     */
    where: player_tagWhereUniqueInput
  }

  /**
   * player_tag deleteMany
   */
  export type player_tagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which player_tags to delete
     */
    where?: player_tagWhereInput
    /**
     * Limit how many player_tags to delete.
     */
    limit?: number
  }

  /**
   * player_tag findRaw
   */
  export type player_tagFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * player_tag aggregateRaw
   */
  export type player_tagAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * player_tag without action
   */
  export type player_tagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the player_tag
     */
    select?: player_tagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the player_tag
     */
    omit?: player_tagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: player_tagInclude<ExtArgs> | null
  }


  /**
   * Model boost
   */

  export type AggregateBoost = {
    _count: BoostCountAggregateOutputType | null
    _avg: BoostAvgAggregateOutputType | null
    _sum: BoostSumAggregateOutputType | null
    _min: BoostMinAggregateOutputType | null
    _max: BoostMaxAggregateOutputType | null
  }

  export type BoostAvgAggregateOutputType = {
    amount_cents: number | null
  }

  export type BoostSumAggregateOutputType = {
    amount_cents: number | null
  }

  export type BoostMinAggregateOutputType = {
    id: string | null
    player_id: string | null
    status: $Enums.boost_status | null
    starts_at: Date | null
    ends_at: Date | null
    provider: $Enums.provider_kind | null
    external_id: string | null
    amount_cents: number | null
    currency: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type BoostMaxAggregateOutputType = {
    id: string | null
    player_id: string | null
    status: $Enums.boost_status | null
    starts_at: Date | null
    ends_at: Date | null
    provider: $Enums.provider_kind | null
    external_id: string | null
    amount_cents: number | null
    currency: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type BoostCountAggregateOutputType = {
    id: number
    player_id: number
    status: number
    starts_at: number
    ends_at: number
    provider: number
    external_id: number
    amount_cents: number
    currency: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type BoostAvgAggregateInputType = {
    amount_cents?: true
  }

  export type BoostSumAggregateInputType = {
    amount_cents?: true
  }

  export type BoostMinAggregateInputType = {
    id?: true
    player_id?: true
    status?: true
    starts_at?: true
    ends_at?: true
    provider?: true
    external_id?: true
    amount_cents?: true
    currency?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type BoostMaxAggregateInputType = {
    id?: true
    player_id?: true
    status?: true
    starts_at?: true
    ends_at?: true
    provider?: true
    external_id?: true
    amount_cents?: true
    currency?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type BoostCountAggregateInputType = {
    id?: true
    player_id?: true
    status?: true
    starts_at?: true
    ends_at?: true
    provider?: true
    external_id?: true
    amount_cents?: true
    currency?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type BoostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which boost to aggregate.
     */
    where?: boostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of boosts to fetch.
     */
    orderBy?: boostOrderByWithRelationInput | boostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: boostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` boosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` boosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned boosts
    **/
    _count?: true | BoostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BoostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BoostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BoostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BoostMaxAggregateInputType
  }

  export type GetBoostAggregateType<T extends BoostAggregateArgs> = {
        [P in keyof T & keyof AggregateBoost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBoost[P]>
      : GetScalarType<T[P], AggregateBoost[P]>
  }




  export type boostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: boostWhereInput
    orderBy?: boostOrderByWithAggregationInput | boostOrderByWithAggregationInput[]
    by: BoostScalarFieldEnum[] | BoostScalarFieldEnum
    having?: boostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BoostCountAggregateInputType | true
    _avg?: BoostAvgAggregateInputType
    _sum?: BoostSumAggregateInputType
    _min?: BoostMinAggregateInputType
    _max?: BoostMaxAggregateInputType
  }

  export type BoostGroupByOutputType = {
    id: string
    player_id: string
    status: $Enums.boost_status
    starts_at: Date
    ends_at: Date
    provider: $Enums.provider_kind
    external_id: string | null
    amount_cents: number
    currency: string
    created_at: Date
    updated_at: Date
    deleted_at: Date | null
    _count: BoostCountAggregateOutputType | null
    _avg: BoostAvgAggregateOutputType | null
    _sum: BoostSumAggregateOutputType | null
    _min: BoostMinAggregateOutputType | null
    _max: BoostMaxAggregateOutputType | null
  }

  type GetBoostGroupByPayload<T extends boostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BoostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BoostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BoostGroupByOutputType[P]>
            : GetScalarType<T[P], BoostGroupByOutputType[P]>
        }
      >
    >


  export type boostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    player_id?: boolean
    status?: boolean
    starts_at?: boolean
    ends_at?: boolean
    provider?: boolean
    external_id?: boolean
    amount_cents?: boolean
    currency?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    player?: boolean | profileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["boost"]>



  export type boostSelectScalar = {
    id?: boolean
    player_id?: boolean
    status?: boolean
    starts_at?: boolean
    ends_at?: boolean
    provider?: boolean
    external_id?: boolean
    amount_cents?: boolean
    currency?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }

  export type boostOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "player_id" | "status" | "starts_at" | "ends_at" | "provider" | "external_id" | "amount_cents" | "currency" | "created_at" | "updated_at" | "deleted_at", ExtArgs["result"]["boost"]>
  export type boostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | profileDefaultArgs<ExtArgs>
  }

  export type $boostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "boost"
    objects: {
      player: Prisma.$profilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      player_id: string
      status: $Enums.boost_status
      starts_at: Date
      ends_at: Date
      provider: $Enums.provider_kind
      external_id: string | null
      amount_cents: number
      currency: string
      created_at: Date
      updated_at: Date
      deleted_at: Date | null
    }, ExtArgs["result"]["boost"]>
    composites: {}
  }

  type boostGetPayload<S extends boolean | null | undefined | boostDefaultArgs> = $Result.GetResult<Prisma.$boostPayload, S>

  type boostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<boostFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BoostCountAggregateInputType | true
    }

  export interface boostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['boost'], meta: { name: 'boost' } }
    /**
     * Find zero or one Boost that matches the filter.
     * @param {boostFindUniqueArgs} args - Arguments to find a Boost
     * @example
     * // Get one Boost
     * const boost = await prisma.boost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends boostFindUniqueArgs>(args: SelectSubset<T, boostFindUniqueArgs<ExtArgs>>): Prisma__boostClient<$Result.GetResult<Prisma.$boostPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Boost that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {boostFindUniqueOrThrowArgs} args - Arguments to find a Boost
     * @example
     * // Get one Boost
     * const boost = await prisma.boost.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends boostFindUniqueOrThrowArgs>(args: SelectSubset<T, boostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__boostClient<$Result.GetResult<Prisma.$boostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Boost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {boostFindFirstArgs} args - Arguments to find a Boost
     * @example
     * // Get one Boost
     * const boost = await prisma.boost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends boostFindFirstArgs>(args?: SelectSubset<T, boostFindFirstArgs<ExtArgs>>): Prisma__boostClient<$Result.GetResult<Prisma.$boostPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Boost that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {boostFindFirstOrThrowArgs} args - Arguments to find a Boost
     * @example
     * // Get one Boost
     * const boost = await prisma.boost.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends boostFindFirstOrThrowArgs>(args?: SelectSubset<T, boostFindFirstOrThrowArgs<ExtArgs>>): Prisma__boostClient<$Result.GetResult<Prisma.$boostPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Boosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {boostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Boosts
     * const boosts = await prisma.boost.findMany()
     * 
     * // Get first 10 Boosts
     * const boosts = await prisma.boost.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const boostWithIdOnly = await prisma.boost.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends boostFindManyArgs>(args?: SelectSubset<T, boostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$boostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Boost.
     * @param {boostCreateArgs} args - Arguments to create a Boost.
     * @example
     * // Create one Boost
     * const Boost = await prisma.boost.create({
     *   data: {
     *     // ... data to create a Boost
     *   }
     * })
     * 
     */
    create<T extends boostCreateArgs>(args: SelectSubset<T, boostCreateArgs<ExtArgs>>): Prisma__boostClient<$Result.GetResult<Prisma.$boostPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Boosts.
     * @param {boostCreateManyArgs} args - Arguments to create many Boosts.
     * @example
     * // Create many Boosts
     * const boost = await prisma.boost.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends boostCreateManyArgs>(args?: SelectSubset<T, boostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Boost.
     * @param {boostDeleteArgs} args - Arguments to delete one Boost.
     * @example
     * // Delete one Boost
     * const Boost = await prisma.boost.delete({
     *   where: {
     *     // ... filter to delete one Boost
     *   }
     * })
     * 
     */
    delete<T extends boostDeleteArgs>(args: SelectSubset<T, boostDeleteArgs<ExtArgs>>): Prisma__boostClient<$Result.GetResult<Prisma.$boostPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Boost.
     * @param {boostUpdateArgs} args - Arguments to update one Boost.
     * @example
     * // Update one Boost
     * const boost = await prisma.boost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends boostUpdateArgs>(args: SelectSubset<T, boostUpdateArgs<ExtArgs>>): Prisma__boostClient<$Result.GetResult<Prisma.$boostPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Boosts.
     * @param {boostDeleteManyArgs} args - Arguments to filter Boosts to delete.
     * @example
     * // Delete a few Boosts
     * const { count } = await prisma.boost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends boostDeleteManyArgs>(args?: SelectSubset<T, boostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Boosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {boostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Boosts
     * const boost = await prisma.boost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends boostUpdateManyArgs>(args: SelectSubset<T, boostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Boost.
     * @param {boostUpsertArgs} args - Arguments to update or create a Boost.
     * @example
     * // Update or create a Boost
     * const boost = await prisma.boost.upsert({
     *   create: {
     *     // ... data to create a Boost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Boost we want to update
     *   }
     * })
     */
    upsert<T extends boostUpsertArgs>(args: SelectSubset<T, boostUpsertArgs<ExtArgs>>): Prisma__boostClient<$Result.GetResult<Prisma.$boostPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Boosts that matches the filter.
     * @param {boostFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const boost = await prisma.boost.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: boostFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Boost.
     * @param {boostAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const boost = await prisma.boost.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: boostAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Boosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {boostCountArgs} args - Arguments to filter Boosts to count.
     * @example
     * // Count the number of Boosts
     * const count = await prisma.boost.count({
     *   where: {
     *     // ... the filter for the Boosts we want to count
     *   }
     * })
    **/
    count<T extends boostCountArgs>(
      args?: Subset<T, boostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BoostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Boost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BoostAggregateArgs>(args: Subset<T, BoostAggregateArgs>): Prisma.PrismaPromise<GetBoostAggregateType<T>>

    /**
     * Group by Boost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {boostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends boostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: boostGroupByArgs['orderBy'] }
        : { orderBy?: boostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, boostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBoostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the boost model
   */
  readonly fields: boostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for boost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__boostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    player<T extends profileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, profileDefaultArgs<ExtArgs>>): Prisma__profileClient<$Result.GetResult<Prisma.$profilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the boost model
   */
  interface boostFieldRefs {
    readonly id: FieldRef<"boost", 'String'>
    readonly player_id: FieldRef<"boost", 'String'>
    readonly status: FieldRef<"boost", 'boost_status'>
    readonly starts_at: FieldRef<"boost", 'DateTime'>
    readonly ends_at: FieldRef<"boost", 'DateTime'>
    readonly provider: FieldRef<"boost", 'provider_kind'>
    readonly external_id: FieldRef<"boost", 'String'>
    readonly amount_cents: FieldRef<"boost", 'Int'>
    readonly currency: FieldRef<"boost", 'String'>
    readonly created_at: FieldRef<"boost", 'DateTime'>
    readonly updated_at: FieldRef<"boost", 'DateTime'>
    readonly deleted_at: FieldRef<"boost", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * boost findUnique
   */
  export type boostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the boost
     */
    select?: boostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the boost
     */
    omit?: boostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: boostInclude<ExtArgs> | null
    /**
     * Filter, which boost to fetch.
     */
    where: boostWhereUniqueInput
  }

  /**
   * boost findUniqueOrThrow
   */
  export type boostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the boost
     */
    select?: boostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the boost
     */
    omit?: boostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: boostInclude<ExtArgs> | null
    /**
     * Filter, which boost to fetch.
     */
    where: boostWhereUniqueInput
  }

  /**
   * boost findFirst
   */
  export type boostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the boost
     */
    select?: boostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the boost
     */
    omit?: boostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: boostInclude<ExtArgs> | null
    /**
     * Filter, which boost to fetch.
     */
    where?: boostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of boosts to fetch.
     */
    orderBy?: boostOrderByWithRelationInput | boostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for boosts.
     */
    cursor?: boostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` boosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` boosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of boosts.
     */
    distinct?: BoostScalarFieldEnum | BoostScalarFieldEnum[]
  }

  /**
   * boost findFirstOrThrow
   */
  export type boostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the boost
     */
    select?: boostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the boost
     */
    omit?: boostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: boostInclude<ExtArgs> | null
    /**
     * Filter, which boost to fetch.
     */
    where?: boostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of boosts to fetch.
     */
    orderBy?: boostOrderByWithRelationInput | boostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for boosts.
     */
    cursor?: boostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` boosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` boosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of boosts.
     */
    distinct?: BoostScalarFieldEnum | BoostScalarFieldEnum[]
  }

  /**
   * boost findMany
   */
  export type boostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the boost
     */
    select?: boostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the boost
     */
    omit?: boostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: boostInclude<ExtArgs> | null
    /**
     * Filter, which boosts to fetch.
     */
    where?: boostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of boosts to fetch.
     */
    orderBy?: boostOrderByWithRelationInput | boostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing boosts.
     */
    cursor?: boostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` boosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` boosts.
     */
    skip?: number
    distinct?: BoostScalarFieldEnum | BoostScalarFieldEnum[]
  }

  /**
   * boost create
   */
  export type boostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the boost
     */
    select?: boostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the boost
     */
    omit?: boostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: boostInclude<ExtArgs> | null
    /**
     * The data needed to create a boost.
     */
    data: XOR<boostCreateInput, boostUncheckedCreateInput>
  }

  /**
   * boost createMany
   */
  export type boostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many boosts.
     */
    data: boostCreateManyInput | boostCreateManyInput[]
  }

  /**
   * boost update
   */
  export type boostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the boost
     */
    select?: boostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the boost
     */
    omit?: boostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: boostInclude<ExtArgs> | null
    /**
     * The data needed to update a boost.
     */
    data: XOR<boostUpdateInput, boostUncheckedUpdateInput>
    /**
     * Choose, which boost to update.
     */
    where: boostWhereUniqueInput
  }

  /**
   * boost updateMany
   */
  export type boostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update boosts.
     */
    data: XOR<boostUpdateManyMutationInput, boostUncheckedUpdateManyInput>
    /**
     * Filter which boosts to update
     */
    where?: boostWhereInput
    /**
     * Limit how many boosts to update.
     */
    limit?: number
  }

  /**
   * boost upsert
   */
  export type boostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the boost
     */
    select?: boostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the boost
     */
    omit?: boostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: boostInclude<ExtArgs> | null
    /**
     * The filter to search for the boost to update in case it exists.
     */
    where: boostWhereUniqueInput
    /**
     * In case the boost found by the `where` argument doesn't exist, create a new boost with this data.
     */
    create: XOR<boostCreateInput, boostUncheckedCreateInput>
    /**
     * In case the boost was found with the provided `where` argument, update it with this data.
     */
    update: XOR<boostUpdateInput, boostUncheckedUpdateInput>
  }

  /**
   * boost delete
   */
  export type boostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the boost
     */
    select?: boostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the boost
     */
    omit?: boostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: boostInclude<ExtArgs> | null
    /**
     * Filter which boost to delete.
     */
    where: boostWhereUniqueInput
  }

  /**
   * boost deleteMany
   */
  export type boostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which boosts to delete
     */
    where?: boostWhereInput
    /**
     * Limit how many boosts to delete.
     */
    limit?: number
  }

  /**
   * boost findRaw
   */
  export type boostFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * boost aggregateRaw
   */
  export type boostAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * boost without action
   */
  export type boostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the boost
     */
    select?: boostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the boost
     */
    omit?: boostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: boostInclude<ExtArgs> | null
  }


  /**
   * Model report
   */

  export type AggregateReport = {
    _count: ReportCountAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  export type ReportMinAggregateOutputType = {
    id: string | null
    reporter_user_id: string | null
    target_type: string | null
    target_id: string | null
    reason: $Enums.report_reason | null
    details: string | null
    severity: $Enums.severity_level | null
    status: $Enums.report_status | null
    resolution_note: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type ReportMaxAggregateOutputType = {
    id: string | null
    reporter_user_id: string | null
    target_type: string | null
    target_id: string | null
    reason: $Enums.report_reason | null
    details: string | null
    severity: $Enums.severity_level | null
    status: $Enums.report_status | null
    resolution_note: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type ReportCountAggregateOutputType = {
    id: number
    reporter_user_id: number
    target_type: number
    target_id: number
    reason: number
    details: number
    severity: number
    status: number
    resolution_note: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type ReportMinAggregateInputType = {
    id?: true
    reporter_user_id?: true
    target_type?: true
    target_id?: true
    reason?: true
    details?: true
    severity?: true
    status?: true
    resolution_note?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type ReportMaxAggregateInputType = {
    id?: true
    reporter_user_id?: true
    target_type?: true
    target_id?: true
    reason?: true
    details?: true
    severity?: true
    status?: true
    resolution_note?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type ReportCountAggregateInputType = {
    id?: true
    reporter_user_id?: true
    target_type?: true
    target_id?: true
    reason?: true
    details?: true
    severity?: true
    status?: true
    resolution_note?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type ReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which report to aggregate.
     */
    where?: reportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reports to fetch.
     */
    orderBy?: reportOrderByWithRelationInput | reportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: reportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned reports
    **/
    _count?: true | ReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReportMaxAggregateInputType
  }

  export type GetReportAggregateType<T extends ReportAggregateArgs> = {
        [P in keyof T & keyof AggregateReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReport[P]>
      : GetScalarType<T[P], AggregateReport[P]>
  }




  export type reportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: reportWhereInput
    orderBy?: reportOrderByWithAggregationInput | reportOrderByWithAggregationInput[]
    by: ReportScalarFieldEnum[] | ReportScalarFieldEnum
    having?: reportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReportCountAggregateInputType | true
    _min?: ReportMinAggregateInputType
    _max?: ReportMaxAggregateInputType
  }

  export type ReportGroupByOutputType = {
    id: string
    reporter_user_id: string | null
    target_type: string
    target_id: string
    reason: $Enums.report_reason
    details: string | null
    severity: $Enums.severity_level
    status: $Enums.report_status
    resolution_note: string | null
    created_at: Date
    updated_at: Date
    deleted_at: Date | null
    _count: ReportCountAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  type GetReportGroupByPayload<T extends reportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportGroupByOutputType[P]>
            : GetScalarType<T[P], ReportGroupByOutputType[P]>
        }
      >
    >


  export type reportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reporter_user_id?: boolean
    target_type?: boolean
    target_id?: boolean
    reason?: boolean
    details?: boolean
    severity?: boolean
    status?: boolean
    resolution_note?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    media_target?: boolean | report$media_targetArgs<ExtArgs>
    profile_target?: boolean | report$profile_targetArgs<ExtArgs>
    reporter_user?: boolean | report$reporter_userArgs<ExtArgs>
  }, ExtArgs["result"]["report"]>



  export type reportSelectScalar = {
    id?: boolean
    reporter_user_id?: boolean
    target_type?: boolean
    target_id?: boolean
    reason?: boolean
    details?: boolean
    severity?: boolean
    status?: boolean
    resolution_note?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }

  export type reportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "reporter_user_id" | "target_type" | "target_id" | "reason" | "details" | "severity" | "status" | "resolution_note" | "created_at" | "updated_at" | "deleted_at", ExtArgs["result"]["report"]>
  export type reportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    media_target?: boolean | report$media_targetArgs<ExtArgs>
    profile_target?: boolean | report$profile_targetArgs<ExtArgs>
    reporter_user?: boolean | report$reporter_userArgs<ExtArgs>
  }

  export type $reportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "report"
    objects: {
      media_target: Prisma.$mediaPayload<ExtArgs> | null
      profile_target: Prisma.$profilePayload<ExtArgs> | null
      reporter_user: Prisma.$userPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      reporter_user_id: string | null
      target_type: string
      target_id: string
      reason: $Enums.report_reason
      details: string | null
      severity: $Enums.severity_level
      status: $Enums.report_status
      resolution_note: string | null
      created_at: Date
      updated_at: Date
      deleted_at: Date | null
    }, ExtArgs["result"]["report"]>
    composites: {}
  }

  type reportGetPayload<S extends boolean | null | undefined | reportDefaultArgs> = $Result.GetResult<Prisma.$reportPayload, S>

  type reportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<reportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReportCountAggregateInputType | true
    }

  export interface reportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['report'], meta: { name: 'report' } }
    /**
     * Find zero or one Report that matches the filter.
     * @param {reportFindUniqueArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends reportFindUniqueArgs>(args: SelectSubset<T, reportFindUniqueArgs<ExtArgs>>): Prisma__reportClient<$Result.GetResult<Prisma.$reportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Report that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {reportFindUniqueOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends reportFindUniqueOrThrowArgs>(args: SelectSubset<T, reportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__reportClient<$Result.GetResult<Prisma.$reportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Report that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reportFindFirstArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends reportFindFirstArgs>(args?: SelectSubset<T, reportFindFirstArgs<ExtArgs>>): Prisma__reportClient<$Result.GetResult<Prisma.$reportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Report that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reportFindFirstOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends reportFindFirstOrThrowArgs>(args?: SelectSubset<T, reportFindFirstOrThrowArgs<ExtArgs>>): Prisma__reportClient<$Result.GetResult<Prisma.$reportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reports
     * const reports = await prisma.report.findMany()
     * 
     * // Get first 10 Reports
     * const reports = await prisma.report.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reportWithIdOnly = await prisma.report.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends reportFindManyArgs>(args?: SelectSubset<T, reportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Report.
     * @param {reportCreateArgs} args - Arguments to create a Report.
     * @example
     * // Create one Report
     * const Report = await prisma.report.create({
     *   data: {
     *     // ... data to create a Report
     *   }
     * })
     * 
     */
    create<T extends reportCreateArgs>(args: SelectSubset<T, reportCreateArgs<ExtArgs>>): Prisma__reportClient<$Result.GetResult<Prisma.$reportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Reports.
     * @param {reportCreateManyArgs} args - Arguments to create many Reports.
     * @example
     * // Create many Reports
     * const report = await prisma.report.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends reportCreateManyArgs>(args?: SelectSubset<T, reportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Report.
     * @param {reportDeleteArgs} args - Arguments to delete one Report.
     * @example
     * // Delete one Report
     * const Report = await prisma.report.delete({
     *   where: {
     *     // ... filter to delete one Report
     *   }
     * })
     * 
     */
    delete<T extends reportDeleteArgs>(args: SelectSubset<T, reportDeleteArgs<ExtArgs>>): Prisma__reportClient<$Result.GetResult<Prisma.$reportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Report.
     * @param {reportUpdateArgs} args - Arguments to update one Report.
     * @example
     * // Update one Report
     * const report = await prisma.report.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends reportUpdateArgs>(args: SelectSubset<T, reportUpdateArgs<ExtArgs>>): Prisma__reportClient<$Result.GetResult<Prisma.$reportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Reports.
     * @param {reportDeleteManyArgs} args - Arguments to filter Reports to delete.
     * @example
     * // Delete a few Reports
     * const { count } = await prisma.report.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends reportDeleteManyArgs>(args?: SelectSubset<T, reportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reports
     * const report = await prisma.report.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends reportUpdateManyArgs>(args: SelectSubset<T, reportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Report.
     * @param {reportUpsertArgs} args - Arguments to update or create a Report.
     * @example
     * // Update or create a Report
     * const report = await prisma.report.upsert({
     *   create: {
     *     // ... data to create a Report
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Report we want to update
     *   }
     * })
     */
    upsert<T extends reportUpsertArgs>(args: SelectSubset<T, reportUpsertArgs<ExtArgs>>): Prisma__reportClient<$Result.GetResult<Prisma.$reportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reports that matches the filter.
     * @param {reportFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const report = await prisma.report.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: reportFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Report.
     * @param {reportAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const report = await prisma.report.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: reportAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reportCountArgs} args - Arguments to filter Reports to count.
     * @example
     * // Count the number of Reports
     * const count = await prisma.report.count({
     *   where: {
     *     // ... the filter for the Reports we want to count
     *   }
     * })
    **/
    count<T extends reportCountArgs>(
      args?: Subset<T, reportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportAggregateArgs>(args: Subset<T, ReportAggregateArgs>): Prisma.PrismaPromise<GetReportAggregateType<T>>

    /**
     * Group by Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends reportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: reportGroupByArgs['orderBy'] }
        : { orderBy?: reportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, reportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the report model
   */
  readonly fields: reportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for report.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__reportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    media_target<T extends report$media_targetArgs<ExtArgs> = {}>(args?: Subset<T, report$media_targetArgs<ExtArgs>>): Prisma__mediaClient<$Result.GetResult<Prisma.$mediaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    profile_target<T extends report$profile_targetArgs<ExtArgs> = {}>(args?: Subset<T, report$profile_targetArgs<ExtArgs>>): Prisma__profileClient<$Result.GetResult<Prisma.$profilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    reporter_user<T extends report$reporter_userArgs<ExtArgs> = {}>(args?: Subset<T, report$reporter_userArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the report model
   */
  interface reportFieldRefs {
    readonly id: FieldRef<"report", 'String'>
    readonly reporter_user_id: FieldRef<"report", 'String'>
    readonly target_type: FieldRef<"report", 'String'>
    readonly target_id: FieldRef<"report", 'String'>
    readonly reason: FieldRef<"report", 'report_reason'>
    readonly details: FieldRef<"report", 'String'>
    readonly severity: FieldRef<"report", 'severity_level'>
    readonly status: FieldRef<"report", 'report_status'>
    readonly resolution_note: FieldRef<"report", 'String'>
    readonly created_at: FieldRef<"report", 'DateTime'>
    readonly updated_at: FieldRef<"report", 'DateTime'>
    readonly deleted_at: FieldRef<"report", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * report findUnique
   */
  export type reportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the report
     */
    select?: reportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the report
     */
    omit?: reportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reportInclude<ExtArgs> | null
    /**
     * Filter, which report to fetch.
     */
    where: reportWhereUniqueInput
  }

  /**
   * report findUniqueOrThrow
   */
  export type reportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the report
     */
    select?: reportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the report
     */
    omit?: reportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reportInclude<ExtArgs> | null
    /**
     * Filter, which report to fetch.
     */
    where: reportWhereUniqueInput
  }

  /**
   * report findFirst
   */
  export type reportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the report
     */
    select?: reportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the report
     */
    omit?: reportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reportInclude<ExtArgs> | null
    /**
     * Filter, which report to fetch.
     */
    where?: reportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reports to fetch.
     */
    orderBy?: reportOrderByWithRelationInput | reportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reports.
     */
    cursor?: reportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reports.
     */
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * report findFirstOrThrow
   */
  export type reportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the report
     */
    select?: reportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the report
     */
    omit?: reportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reportInclude<ExtArgs> | null
    /**
     * Filter, which report to fetch.
     */
    where?: reportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reports to fetch.
     */
    orderBy?: reportOrderByWithRelationInput | reportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reports.
     */
    cursor?: reportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reports.
     */
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * report findMany
   */
  export type reportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the report
     */
    select?: reportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the report
     */
    omit?: reportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reportInclude<ExtArgs> | null
    /**
     * Filter, which reports to fetch.
     */
    where?: reportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reports to fetch.
     */
    orderBy?: reportOrderByWithRelationInput | reportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing reports.
     */
    cursor?: reportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reports.
     */
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * report create
   */
  export type reportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the report
     */
    select?: reportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the report
     */
    omit?: reportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reportInclude<ExtArgs> | null
    /**
     * The data needed to create a report.
     */
    data: XOR<reportCreateInput, reportUncheckedCreateInput>
  }

  /**
   * report createMany
   */
  export type reportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many reports.
     */
    data: reportCreateManyInput | reportCreateManyInput[]
  }

  /**
   * report update
   */
  export type reportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the report
     */
    select?: reportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the report
     */
    omit?: reportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reportInclude<ExtArgs> | null
    /**
     * The data needed to update a report.
     */
    data: XOR<reportUpdateInput, reportUncheckedUpdateInput>
    /**
     * Choose, which report to update.
     */
    where: reportWhereUniqueInput
  }

  /**
   * report updateMany
   */
  export type reportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update reports.
     */
    data: XOR<reportUpdateManyMutationInput, reportUncheckedUpdateManyInput>
    /**
     * Filter which reports to update
     */
    where?: reportWhereInput
    /**
     * Limit how many reports to update.
     */
    limit?: number
  }

  /**
   * report upsert
   */
  export type reportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the report
     */
    select?: reportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the report
     */
    omit?: reportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reportInclude<ExtArgs> | null
    /**
     * The filter to search for the report to update in case it exists.
     */
    where: reportWhereUniqueInput
    /**
     * In case the report found by the `where` argument doesn't exist, create a new report with this data.
     */
    create: XOR<reportCreateInput, reportUncheckedCreateInput>
    /**
     * In case the report was found with the provided `where` argument, update it with this data.
     */
    update: XOR<reportUpdateInput, reportUncheckedUpdateInput>
  }

  /**
   * report delete
   */
  export type reportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the report
     */
    select?: reportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the report
     */
    omit?: reportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reportInclude<ExtArgs> | null
    /**
     * Filter which report to delete.
     */
    where: reportWhereUniqueInput
  }

  /**
   * report deleteMany
   */
  export type reportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which reports to delete
     */
    where?: reportWhereInput
    /**
     * Limit how many reports to delete.
     */
    limit?: number
  }

  /**
   * report findRaw
   */
  export type reportFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * report aggregateRaw
   */
  export type reportAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * report.media_target
   */
  export type report$media_targetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the media
     */
    select?: mediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the media
     */
    omit?: mediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mediaInclude<ExtArgs> | null
    where?: mediaWhereInput
  }

  /**
   * report.profile_target
   */
  export type report$profile_targetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the profile
     */
    omit?: profileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: profileInclude<ExtArgs> | null
    where?: profileWhereInput
  }

  /**
   * report.reporter_user
   */
  export type report$reporter_userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
  }

  /**
   * report without action
   */
  export type reportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the report
     */
    select?: reportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the report
     */
    omit?: reportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reportInclude<ExtArgs> | null
  }


  /**
   * Model strike
   */

  export type AggregateStrike = {
    _count: StrikeCountAggregateOutputType | null
    _min: StrikeMinAggregateOutputType | null
    _max: StrikeMaxAggregateOutputType | null
  }

  export type StrikeMinAggregateOutputType = {
    id: string | null
    player_id: string | null
    reason: string | null
    severity: $Enums.severity_level | null
    expires_at: Date | null
    status: $Enums.setting_status | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type StrikeMaxAggregateOutputType = {
    id: string | null
    player_id: string | null
    reason: string | null
    severity: $Enums.severity_level | null
    expires_at: Date | null
    status: $Enums.setting_status | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type StrikeCountAggregateOutputType = {
    id: number
    player_id: number
    reason: number
    severity: number
    expires_at: number
    status: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type StrikeMinAggregateInputType = {
    id?: true
    player_id?: true
    reason?: true
    severity?: true
    expires_at?: true
    status?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type StrikeMaxAggregateInputType = {
    id?: true
    player_id?: true
    reason?: true
    severity?: true
    expires_at?: true
    status?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type StrikeCountAggregateInputType = {
    id?: true
    player_id?: true
    reason?: true
    severity?: true
    expires_at?: true
    status?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type StrikeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which strike to aggregate.
     */
    where?: strikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of strikes to fetch.
     */
    orderBy?: strikeOrderByWithRelationInput | strikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: strikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` strikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` strikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned strikes
    **/
    _count?: true | StrikeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StrikeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StrikeMaxAggregateInputType
  }

  export type GetStrikeAggregateType<T extends StrikeAggregateArgs> = {
        [P in keyof T & keyof AggregateStrike]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStrike[P]>
      : GetScalarType<T[P], AggregateStrike[P]>
  }




  export type strikeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: strikeWhereInput
    orderBy?: strikeOrderByWithAggregationInput | strikeOrderByWithAggregationInput[]
    by: StrikeScalarFieldEnum[] | StrikeScalarFieldEnum
    having?: strikeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StrikeCountAggregateInputType | true
    _min?: StrikeMinAggregateInputType
    _max?: StrikeMaxAggregateInputType
  }

  export type StrikeGroupByOutputType = {
    id: string
    player_id: string
    reason: string
    severity: $Enums.severity_level
    expires_at: Date | null
    status: $Enums.setting_status
    created_at: Date
    updated_at: Date
    deleted_at: Date | null
    _count: StrikeCountAggregateOutputType | null
    _min: StrikeMinAggregateOutputType | null
    _max: StrikeMaxAggregateOutputType | null
  }

  type GetStrikeGroupByPayload<T extends strikeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StrikeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StrikeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StrikeGroupByOutputType[P]>
            : GetScalarType<T[P], StrikeGroupByOutputType[P]>
        }
      >
    >


  export type strikeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    player_id?: boolean
    reason?: boolean
    severity?: boolean
    expires_at?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    player?: boolean | profileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["strike"]>



  export type strikeSelectScalar = {
    id?: boolean
    player_id?: boolean
    reason?: boolean
    severity?: boolean
    expires_at?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }

  export type strikeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "player_id" | "reason" | "severity" | "expires_at" | "status" | "created_at" | "updated_at" | "deleted_at", ExtArgs["result"]["strike"]>
  export type strikeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | profileDefaultArgs<ExtArgs>
  }

  export type $strikePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "strike"
    objects: {
      player: Prisma.$profilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      player_id: string
      reason: string
      severity: $Enums.severity_level
      expires_at: Date | null
      status: $Enums.setting_status
      created_at: Date
      updated_at: Date
      deleted_at: Date | null
    }, ExtArgs["result"]["strike"]>
    composites: {}
  }

  type strikeGetPayload<S extends boolean | null | undefined | strikeDefaultArgs> = $Result.GetResult<Prisma.$strikePayload, S>

  type strikeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<strikeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StrikeCountAggregateInputType | true
    }

  export interface strikeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['strike'], meta: { name: 'strike' } }
    /**
     * Find zero or one Strike that matches the filter.
     * @param {strikeFindUniqueArgs} args - Arguments to find a Strike
     * @example
     * // Get one Strike
     * const strike = await prisma.strike.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends strikeFindUniqueArgs>(args: SelectSubset<T, strikeFindUniqueArgs<ExtArgs>>): Prisma__strikeClient<$Result.GetResult<Prisma.$strikePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Strike that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {strikeFindUniqueOrThrowArgs} args - Arguments to find a Strike
     * @example
     * // Get one Strike
     * const strike = await prisma.strike.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends strikeFindUniqueOrThrowArgs>(args: SelectSubset<T, strikeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__strikeClient<$Result.GetResult<Prisma.$strikePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Strike that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {strikeFindFirstArgs} args - Arguments to find a Strike
     * @example
     * // Get one Strike
     * const strike = await prisma.strike.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends strikeFindFirstArgs>(args?: SelectSubset<T, strikeFindFirstArgs<ExtArgs>>): Prisma__strikeClient<$Result.GetResult<Prisma.$strikePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Strike that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {strikeFindFirstOrThrowArgs} args - Arguments to find a Strike
     * @example
     * // Get one Strike
     * const strike = await prisma.strike.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends strikeFindFirstOrThrowArgs>(args?: SelectSubset<T, strikeFindFirstOrThrowArgs<ExtArgs>>): Prisma__strikeClient<$Result.GetResult<Prisma.$strikePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Strikes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {strikeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Strikes
     * const strikes = await prisma.strike.findMany()
     * 
     * // Get first 10 Strikes
     * const strikes = await prisma.strike.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const strikeWithIdOnly = await prisma.strike.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends strikeFindManyArgs>(args?: SelectSubset<T, strikeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$strikePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Strike.
     * @param {strikeCreateArgs} args - Arguments to create a Strike.
     * @example
     * // Create one Strike
     * const Strike = await prisma.strike.create({
     *   data: {
     *     // ... data to create a Strike
     *   }
     * })
     * 
     */
    create<T extends strikeCreateArgs>(args: SelectSubset<T, strikeCreateArgs<ExtArgs>>): Prisma__strikeClient<$Result.GetResult<Prisma.$strikePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Strikes.
     * @param {strikeCreateManyArgs} args - Arguments to create many Strikes.
     * @example
     * // Create many Strikes
     * const strike = await prisma.strike.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends strikeCreateManyArgs>(args?: SelectSubset<T, strikeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Strike.
     * @param {strikeDeleteArgs} args - Arguments to delete one Strike.
     * @example
     * // Delete one Strike
     * const Strike = await prisma.strike.delete({
     *   where: {
     *     // ... filter to delete one Strike
     *   }
     * })
     * 
     */
    delete<T extends strikeDeleteArgs>(args: SelectSubset<T, strikeDeleteArgs<ExtArgs>>): Prisma__strikeClient<$Result.GetResult<Prisma.$strikePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Strike.
     * @param {strikeUpdateArgs} args - Arguments to update one Strike.
     * @example
     * // Update one Strike
     * const strike = await prisma.strike.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends strikeUpdateArgs>(args: SelectSubset<T, strikeUpdateArgs<ExtArgs>>): Prisma__strikeClient<$Result.GetResult<Prisma.$strikePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Strikes.
     * @param {strikeDeleteManyArgs} args - Arguments to filter Strikes to delete.
     * @example
     * // Delete a few Strikes
     * const { count } = await prisma.strike.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends strikeDeleteManyArgs>(args?: SelectSubset<T, strikeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Strikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {strikeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Strikes
     * const strike = await prisma.strike.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends strikeUpdateManyArgs>(args: SelectSubset<T, strikeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Strike.
     * @param {strikeUpsertArgs} args - Arguments to update or create a Strike.
     * @example
     * // Update or create a Strike
     * const strike = await prisma.strike.upsert({
     *   create: {
     *     // ... data to create a Strike
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Strike we want to update
     *   }
     * })
     */
    upsert<T extends strikeUpsertArgs>(args: SelectSubset<T, strikeUpsertArgs<ExtArgs>>): Prisma__strikeClient<$Result.GetResult<Prisma.$strikePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Strikes that matches the filter.
     * @param {strikeFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const strike = await prisma.strike.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: strikeFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Strike.
     * @param {strikeAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const strike = await prisma.strike.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: strikeAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Strikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {strikeCountArgs} args - Arguments to filter Strikes to count.
     * @example
     * // Count the number of Strikes
     * const count = await prisma.strike.count({
     *   where: {
     *     // ... the filter for the Strikes we want to count
     *   }
     * })
    **/
    count<T extends strikeCountArgs>(
      args?: Subset<T, strikeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StrikeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Strike.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StrikeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StrikeAggregateArgs>(args: Subset<T, StrikeAggregateArgs>): Prisma.PrismaPromise<GetStrikeAggregateType<T>>

    /**
     * Group by Strike.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {strikeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends strikeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: strikeGroupByArgs['orderBy'] }
        : { orderBy?: strikeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, strikeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStrikeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the strike model
   */
  readonly fields: strikeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for strike.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__strikeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    player<T extends profileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, profileDefaultArgs<ExtArgs>>): Prisma__profileClient<$Result.GetResult<Prisma.$profilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the strike model
   */
  interface strikeFieldRefs {
    readonly id: FieldRef<"strike", 'String'>
    readonly player_id: FieldRef<"strike", 'String'>
    readonly reason: FieldRef<"strike", 'String'>
    readonly severity: FieldRef<"strike", 'severity_level'>
    readonly expires_at: FieldRef<"strike", 'DateTime'>
    readonly status: FieldRef<"strike", 'setting_status'>
    readonly created_at: FieldRef<"strike", 'DateTime'>
    readonly updated_at: FieldRef<"strike", 'DateTime'>
    readonly deleted_at: FieldRef<"strike", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * strike findUnique
   */
  export type strikeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the strike
     */
    select?: strikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the strike
     */
    omit?: strikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: strikeInclude<ExtArgs> | null
    /**
     * Filter, which strike to fetch.
     */
    where: strikeWhereUniqueInput
  }

  /**
   * strike findUniqueOrThrow
   */
  export type strikeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the strike
     */
    select?: strikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the strike
     */
    omit?: strikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: strikeInclude<ExtArgs> | null
    /**
     * Filter, which strike to fetch.
     */
    where: strikeWhereUniqueInput
  }

  /**
   * strike findFirst
   */
  export type strikeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the strike
     */
    select?: strikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the strike
     */
    omit?: strikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: strikeInclude<ExtArgs> | null
    /**
     * Filter, which strike to fetch.
     */
    where?: strikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of strikes to fetch.
     */
    orderBy?: strikeOrderByWithRelationInput | strikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for strikes.
     */
    cursor?: strikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` strikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` strikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of strikes.
     */
    distinct?: StrikeScalarFieldEnum | StrikeScalarFieldEnum[]
  }

  /**
   * strike findFirstOrThrow
   */
  export type strikeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the strike
     */
    select?: strikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the strike
     */
    omit?: strikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: strikeInclude<ExtArgs> | null
    /**
     * Filter, which strike to fetch.
     */
    where?: strikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of strikes to fetch.
     */
    orderBy?: strikeOrderByWithRelationInput | strikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for strikes.
     */
    cursor?: strikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` strikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` strikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of strikes.
     */
    distinct?: StrikeScalarFieldEnum | StrikeScalarFieldEnum[]
  }

  /**
   * strike findMany
   */
  export type strikeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the strike
     */
    select?: strikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the strike
     */
    omit?: strikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: strikeInclude<ExtArgs> | null
    /**
     * Filter, which strikes to fetch.
     */
    where?: strikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of strikes to fetch.
     */
    orderBy?: strikeOrderByWithRelationInput | strikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing strikes.
     */
    cursor?: strikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` strikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` strikes.
     */
    skip?: number
    distinct?: StrikeScalarFieldEnum | StrikeScalarFieldEnum[]
  }

  /**
   * strike create
   */
  export type strikeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the strike
     */
    select?: strikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the strike
     */
    omit?: strikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: strikeInclude<ExtArgs> | null
    /**
     * The data needed to create a strike.
     */
    data: XOR<strikeCreateInput, strikeUncheckedCreateInput>
  }

  /**
   * strike createMany
   */
  export type strikeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many strikes.
     */
    data: strikeCreateManyInput | strikeCreateManyInput[]
  }

  /**
   * strike update
   */
  export type strikeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the strike
     */
    select?: strikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the strike
     */
    omit?: strikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: strikeInclude<ExtArgs> | null
    /**
     * The data needed to update a strike.
     */
    data: XOR<strikeUpdateInput, strikeUncheckedUpdateInput>
    /**
     * Choose, which strike to update.
     */
    where: strikeWhereUniqueInput
  }

  /**
   * strike updateMany
   */
  export type strikeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update strikes.
     */
    data: XOR<strikeUpdateManyMutationInput, strikeUncheckedUpdateManyInput>
    /**
     * Filter which strikes to update
     */
    where?: strikeWhereInput
    /**
     * Limit how many strikes to update.
     */
    limit?: number
  }

  /**
   * strike upsert
   */
  export type strikeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the strike
     */
    select?: strikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the strike
     */
    omit?: strikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: strikeInclude<ExtArgs> | null
    /**
     * The filter to search for the strike to update in case it exists.
     */
    where: strikeWhereUniqueInput
    /**
     * In case the strike found by the `where` argument doesn't exist, create a new strike with this data.
     */
    create: XOR<strikeCreateInput, strikeUncheckedCreateInput>
    /**
     * In case the strike was found with the provided `where` argument, update it with this data.
     */
    update: XOR<strikeUpdateInput, strikeUncheckedUpdateInput>
  }

  /**
   * strike delete
   */
  export type strikeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the strike
     */
    select?: strikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the strike
     */
    omit?: strikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: strikeInclude<ExtArgs> | null
    /**
     * Filter which strike to delete.
     */
    where: strikeWhereUniqueInput
  }

  /**
   * strike deleteMany
   */
  export type strikeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which strikes to delete
     */
    where?: strikeWhereInput
    /**
     * Limit how many strikes to delete.
     */
    limit?: number
  }

  /**
   * strike findRaw
   */
  export type strikeFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * strike aggregateRaw
   */
  export type strikeAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * strike without action
   */
  export type strikeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the strike
     */
    select?: strikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the strike
     */
    omit?: strikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: strikeInclude<ExtArgs> | null
  }


  /**
   * Model user_note
   */

  export type AggregateUser_note = {
    _count: User_noteCountAggregateOutputType | null
    _min: User_noteMinAggregateOutputType | null
    _max: User_noteMaxAggregateOutputType | null
  }

  export type User_noteMinAggregateOutputType = {
    id: string | null
    player_id: string | null
    author_id: string | null
    note: string | null
    status: $Enums.setting_status | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type User_noteMaxAggregateOutputType = {
    id: string | null
    player_id: string | null
    author_id: string | null
    note: string | null
    status: $Enums.setting_status | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type User_noteCountAggregateOutputType = {
    id: number
    player_id: number
    author_id: number
    note: number
    status: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type User_noteMinAggregateInputType = {
    id?: true
    player_id?: true
    author_id?: true
    note?: true
    status?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type User_noteMaxAggregateInputType = {
    id?: true
    player_id?: true
    author_id?: true
    note?: true
    status?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type User_noteCountAggregateInputType = {
    id?: true
    player_id?: true
    author_id?: true
    note?: true
    status?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type User_noteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_note to aggregate.
     */
    where?: user_noteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_notes to fetch.
     */
    orderBy?: user_noteOrderByWithRelationInput | user_noteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: user_noteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned user_notes
    **/
    _count?: true | User_noteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_noteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_noteMaxAggregateInputType
  }

  export type GetUser_noteAggregateType<T extends User_noteAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_note]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_note[P]>
      : GetScalarType<T[P], AggregateUser_note[P]>
  }




  export type user_noteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_noteWhereInput
    orderBy?: user_noteOrderByWithAggregationInput | user_noteOrderByWithAggregationInput[]
    by: User_noteScalarFieldEnum[] | User_noteScalarFieldEnum
    having?: user_noteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_noteCountAggregateInputType | true
    _min?: User_noteMinAggregateInputType
    _max?: User_noteMaxAggregateInputType
  }

  export type User_noteGroupByOutputType = {
    id: string
    player_id: string
    author_id: string
    note: string
    status: $Enums.setting_status
    created_at: Date
    updated_at: Date
    deleted_at: Date | null
    _count: User_noteCountAggregateOutputType | null
    _min: User_noteMinAggregateOutputType | null
    _max: User_noteMaxAggregateOutputType | null
  }

  type GetUser_noteGroupByPayload<T extends user_noteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<User_noteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User_noteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_noteGroupByOutputType[P]>
            : GetScalarType<T[P], User_noteGroupByOutputType[P]>
        }
      >
    >


  export type user_noteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    player_id?: boolean
    author_id?: boolean
    note?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    player?: boolean | profileDefaultArgs<ExtArgs>
    author?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_note"]>



  export type user_noteSelectScalar = {
    id?: boolean
    player_id?: boolean
    author_id?: boolean
    note?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }

  export type user_noteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "player_id" | "author_id" | "note" | "status" | "created_at" | "updated_at" | "deleted_at", ExtArgs["result"]["user_note"]>
  export type user_noteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | profileDefaultArgs<ExtArgs>
    author?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $user_notePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user_note"
    objects: {
      player: Prisma.$profilePayload<ExtArgs>
      author: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      player_id: string
      author_id: string
      note: string
      status: $Enums.setting_status
      created_at: Date
      updated_at: Date
      deleted_at: Date | null
    }, ExtArgs["result"]["user_note"]>
    composites: {}
  }

  type user_noteGetPayload<S extends boolean | null | undefined | user_noteDefaultArgs> = $Result.GetResult<Prisma.$user_notePayload, S>

  type user_noteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<user_noteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: User_noteCountAggregateInputType | true
    }

  export interface user_noteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user_note'], meta: { name: 'user_note' } }
    /**
     * Find zero or one User_note that matches the filter.
     * @param {user_noteFindUniqueArgs} args - Arguments to find a User_note
     * @example
     * // Get one User_note
     * const user_note = await prisma.user_note.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends user_noteFindUniqueArgs>(args: SelectSubset<T, user_noteFindUniqueArgs<ExtArgs>>): Prisma__user_noteClient<$Result.GetResult<Prisma.$user_notePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User_note that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {user_noteFindUniqueOrThrowArgs} args - Arguments to find a User_note
     * @example
     * // Get one User_note
     * const user_note = await prisma.user_note.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends user_noteFindUniqueOrThrowArgs>(args: SelectSubset<T, user_noteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__user_noteClient<$Result.GetResult<Prisma.$user_notePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User_note that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_noteFindFirstArgs} args - Arguments to find a User_note
     * @example
     * // Get one User_note
     * const user_note = await prisma.user_note.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends user_noteFindFirstArgs>(args?: SelectSubset<T, user_noteFindFirstArgs<ExtArgs>>): Prisma__user_noteClient<$Result.GetResult<Prisma.$user_notePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User_note that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_noteFindFirstOrThrowArgs} args - Arguments to find a User_note
     * @example
     * // Get one User_note
     * const user_note = await prisma.user_note.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends user_noteFindFirstOrThrowArgs>(args?: SelectSubset<T, user_noteFindFirstOrThrowArgs<ExtArgs>>): Prisma__user_noteClient<$Result.GetResult<Prisma.$user_notePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more User_notes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_noteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_notes
     * const user_notes = await prisma.user_note.findMany()
     * 
     * // Get first 10 User_notes
     * const user_notes = await prisma.user_note.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const user_noteWithIdOnly = await prisma.user_note.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends user_noteFindManyArgs>(args?: SelectSubset<T, user_noteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_notePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User_note.
     * @param {user_noteCreateArgs} args - Arguments to create a User_note.
     * @example
     * // Create one User_note
     * const User_note = await prisma.user_note.create({
     *   data: {
     *     // ... data to create a User_note
     *   }
     * })
     * 
     */
    create<T extends user_noteCreateArgs>(args: SelectSubset<T, user_noteCreateArgs<ExtArgs>>): Prisma__user_noteClient<$Result.GetResult<Prisma.$user_notePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many User_notes.
     * @param {user_noteCreateManyArgs} args - Arguments to create many User_notes.
     * @example
     * // Create many User_notes
     * const user_note = await prisma.user_note.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends user_noteCreateManyArgs>(args?: SelectSubset<T, user_noteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User_note.
     * @param {user_noteDeleteArgs} args - Arguments to delete one User_note.
     * @example
     * // Delete one User_note
     * const User_note = await prisma.user_note.delete({
     *   where: {
     *     // ... filter to delete one User_note
     *   }
     * })
     * 
     */
    delete<T extends user_noteDeleteArgs>(args: SelectSubset<T, user_noteDeleteArgs<ExtArgs>>): Prisma__user_noteClient<$Result.GetResult<Prisma.$user_notePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User_note.
     * @param {user_noteUpdateArgs} args - Arguments to update one User_note.
     * @example
     * // Update one User_note
     * const user_note = await prisma.user_note.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends user_noteUpdateArgs>(args: SelectSubset<T, user_noteUpdateArgs<ExtArgs>>): Prisma__user_noteClient<$Result.GetResult<Prisma.$user_notePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more User_notes.
     * @param {user_noteDeleteManyArgs} args - Arguments to filter User_notes to delete.
     * @example
     * // Delete a few User_notes
     * const { count } = await prisma.user_note.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends user_noteDeleteManyArgs>(args?: SelectSubset<T, user_noteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_noteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_notes
     * const user_note = await prisma.user_note.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends user_noteUpdateManyArgs>(args: SelectSubset<T, user_noteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User_note.
     * @param {user_noteUpsertArgs} args - Arguments to update or create a User_note.
     * @example
     * // Update or create a User_note
     * const user_note = await prisma.user_note.upsert({
     *   create: {
     *     // ... data to create a User_note
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_note we want to update
     *   }
     * })
     */
    upsert<T extends user_noteUpsertArgs>(args: SelectSubset<T, user_noteUpsertArgs<ExtArgs>>): Prisma__user_noteClient<$Result.GetResult<Prisma.$user_notePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more User_notes that matches the filter.
     * @param {user_noteFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const user_note = await prisma.user_note.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: user_noteFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a User_note.
     * @param {user_noteAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const user_note = await prisma.user_note.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: user_noteAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of User_notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_noteCountArgs} args - Arguments to filter User_notes to count.
     * @example
     * // Count the number of User_notes
     * const count = await prisma.user_note.count({
     *   where: {
     *     // ... the filter for the User_notes we want to count
     *   }
     * })
    **/
    count<T extends user_noteCountArgs>(
      args?: Subset<T, user_noteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_noteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_note.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_noteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_noteAggregateArgs>(args: Subset<T, User_noteAggregateArgs>): Prisma.PrismaPromise<GetUser_noteAggregateType<T>>

    /**
     * Group by User_note.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_noteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends user_noteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: user_noteGroupByArgs['orderBy'] }
        : { orderBy?: user_noteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, user_noteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_noteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user_note model
   */
  readonly fields: user_noteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user_note.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__user_noteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    player<T extends profileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, profileDefaultArgs<ExtArgs>>): Prisma__profileClient<$Result.GetResult<Prisma.$profilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    author<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the user_note model
   */
  interface user_noteFieldRefs {
    readonly id: FieldRef<"user_note", 'String'>
    readonly player_id: FieldRef<"user_note", 'String'>
    readonly author_id: FieldRef<"user_note", 'String'>
    readonly note: FieldRef<"user_note", 'String'>
    readonly status: FieldRef<"user_note", 'setting_status'>
    readonly created_at: FieldRef<"user_note", 'DateTime'>
    readonly updated_at: FieldRef<"user_note", 'DateTime'>
    readonly deleted_at: FieldRef<"user_note", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * user_note findUnique
   */
  export type user_noteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_note
     */
    select?: user_noteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_note
     */
    omit?: user_noteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_noteInclude<ExtArgs> | null
    /**
     * Filter, which user_note to fetch.
     */
    where: user_noteWhereUniqueInput
  }

  /**
   * user_note findUniqueOrThrow
   */
  export type user_noteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_note
     */
    select?: user_noteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_note
     */
    omit?: user_noteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_noteInclude<ExtArgs> | null
    /**
     * Filter, which user_note to fetch.
     */
    where: user_noteWhereUniqueInput
  }

  /**
   * user_note findFirst
   */
  export type user_noteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_note
     */
    select?: user_noteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_note
     */
    omit?: user_noteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_noteInclude<ExtArgs> | null
    /**
     * Filter, which user_note to fetch.
     */
    where?: user_noteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_notes to fetch.
     */
    orderBy?: user_noteOrderByWithRelationInput | user_noteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_notes.
     */
    cursor?: user_noteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_notes.
     */
    distinct?: User_noteScalarFieldEnum | User_noteScalarFieldEnum[]
  }

  /**
   * user_note findFirstOrThrow
   */
  export type user_noteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_note
     */
    select?: user_noteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_note
     */
    omit?: user_noteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_noteInclude<ExtArgs> | null
    /**
     * Filter, which user_note to fetch.
     */
    where?: user_noteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_notes to fetch.
     */
    orderBy?: user_noteOrderByWithRelationInput | user_noteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_notes.
     */
    cursor?: user_noteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_notes.
     */
    distinct?: User_noteScalarFieldEnum | User_noteScalarFieldEnum[]
  }

  /**
   * user_note findMany
   */
  export type user_noteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_note
     */
    select?: user_noteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_note
     */
    omit?: user_noteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_noteInclude<ExtArgs> | null
    /**
     * Filter, which user_notes to fetch.
     */
    where?: user_noteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_notes to fetch.
     */
    orderBy?: user_noteOrderByWithRelationInput | user_noteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing user_notes.
     */
    cursor?: user_noteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_notes.
     */
    skip?: number
    distinct?: User_noteScalarFieldEnum | User_noteScalarFieldEnum[]
  }

  /**
   * user_note create
   */
  export type user_noteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_note
     */
    select?: user_noteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_note
     */
    omit?: user_noteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_noteInclude<ExtArgs> | null
    /**
     * The data needed to create a user_note.
     */
    data: XOR<user_noteCreateInput, user_noteUncheckedCreateInput>
  }

  /**
   * user_note createMany
   */
  export type user_noteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many user_notes.
     */
    data: user_noteCreateManyInput | user_noteCreateManyInput[]
  }

  /**
   * user_note update
   */
  export type user_noteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_note
     */
    select?: user_noteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_note
     */
    omit?: user_noteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_noteInclude<ExtArgs> | null
    /**
     * The data needed to update a user_note.
     */
    data: XOR<user_noteUpdateInput, user_noteUncheckedUpdateInput>
    /**
     * Choose, which user_note to update.
     */
    where: user_noteWhereUniqueInput
  }

  /**
   * user_note updateMany
   */
  export type user_noteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update user_notes.
     */
    data: XOR<user_noteUpdateManyMutationInput, user_noteUncheckedUpdateManyInput>
    /**
     * Filter which user_notes to update
     */
    where?: user_noteWhereInput
    /**
     * Limit how many user_notes to update.
     */
    limit?: number
  }

  /**
   * user_note upsert
   */
  export type user_noteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_note
     */
    select?: user_noteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_note
     */
    omit?: user_noteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_noteInclude<ExtArgs> | null
    /**
     * The filter to search for the user_note to update in case it exists.
     */
    where: user_noteWhereUniqueInput
    /**
     * In case the user_note found by the `where` argument doesn't exist, create a new user_note with this data.
     */
    create: XOR<user_noteCreateInput, user_noteUncheckedCreateInput>
    /**
     * In case the user_note was found with the provided `where` argument, update it with this data.
     */
    update: XOR<user_noteUpdateInput, user_noteUncheckedUpdateInput>
  }

  /**
   * user_note delete
   */
  export type user_noteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_note
     */
    select?: user_noteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_note
     */
    omit?: user_noteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_noteInclude<ExtArgs> | null
    /**
     * Filter which user_note to delete.
     */
    where: user_noteWhereUniqueInput
  }

  /**
   * user_note deleteMany
   */
  export type user_noteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_notes to delete
     */
    where?: user_noteWhereInput
    /**
     * Limit how many user_notes to delete.
     */
    limit?: number
  }

  /**
   * user_note findRaw
   */
  export type user_noteFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * user_note aggregateRaw
   */
  export type user_noteAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * user_note without action
   */
  export type user_noteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_note
     */
    select?: user_noteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_note
     */
    omit?: user_noteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_noteInclude<ExtArgs> | null
  }


  /**
   * Model announcement
   */

  export type AggregateAnnouncement = {
    _count: AnnouncementCountAggregateOutputType | null
    _min: AnnouncementMinAggregateOutputType | null
    _max: AnnouncementMaxAggregateOutputType | null
  }

  export type AnnouncementMinAggregateOutputType = {
    id: string | null
    title: string | null
    body_md: string | null
    status: $Enums.announcement_status | null
    starts_at: Date | null
    ends_at: Date | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type AnnouncementMaxAggregateOutputType = {
    id: string | null
    title: string | null
    body_md: string | null
    status: $Enums.announcement_status | null
    starts_at: Date | null
    ends_at: Date | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type AnnouncementCountAggregateOutputType = {
    id: number
    title: number
    body_md: number
    status: number
    starts_at: number
    ends_at: number
    segment_tags: number
    segment_states: number
    segment_devices: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type AnnouncementMinAggregateInputType = {
    id?: true
    title?: true
    body_md?: true
    status?: true
    starts_at?: true
    ends_at?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type AnnouncementMaxAggregateInputType = {
    id?: true
    title?: true
    body_md?: true
    status?: true
    starts_at?: true
    ends_at?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type AnnouncementCountAggregateInputType = {
    id?: true
    title?: true
    body_md?: true
    status?: true
    starts_at?: true
    ends_at?: true
    segment_tags?: true
    segment_states?: true
    segment_devices?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type AnnouncementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which announcement to aggregate.
     */
    where?: announcementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of announcements to fetch.
     */
    orderBy?: announcementOrderByWithRelationInput | announcementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: announcementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` announcements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` announcements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned announcements
    **/
    _count?: true | AnnouncementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnnouncementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnnouncementMaxAggregateInputType
  }

  export type GetAnnouncementAggregateType<T extends AnnouncementAggregateArgs> = {
        [P in keyof T & keyof AggregateAnnouncement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnnouncement[P]>
      : GetScalarType<T[P], AggregateAnnouncement[P]>
  }




  export type announcementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: announcementWhereInput
    orderBy?: announcementOrderByWithAggregationInput | announcementOrderByWithAggregationInput[]
    by: AnnouncementScalarFieldEnum[] | AnnouncementScalarFieldEnum
    having?: announcementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnnouncementCountAggregateInputType | true
    _min?: AnnouncementMinAggregateInputType
    _max?: AnnouncementMaxAggregateInputType
  }

  export type AnnouncementGroupByOutputType = {
    id: string
    title: string
    body_md: string
    status: $Enums.announcement_status
    starts_at: Date | null
    ends_at: Date | null
    segment_tags: string[]
    segment_states: string[]
    segment_devices: string[]
    created_at: Date
    updated_at: Date
    deleted_at: Date | null
    _count: AnnouncementCountAggregateOutputType | null
    _min: AnnouncementMinAggregateOutputType | null
    _max: AnnouncementMaxAggregateOutputType | null
  }

  type GetAnnouncementGroupByPayload<T extends announcementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnnouncementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnnouncementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnnouncementGroupByOutputType[P]>
            : GetScalarType<T[P], AnnouncementGroupByOutputType[P]>
        }
      >
    >


  export type announcementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    body_md?: boolean
    status?: boolean
    starts_at?: boolean
    ends_at?: boolean
    segment_tags?: boolean
    segment_states?: boolean
    segment_devices?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }, ExtArgs["result"]["announcement"]>



  export type announcementSelectScalar = {
    id?: boolean
    title?: boolean
    body_md?: boolean
    status?: boolean
    starts_at?: boolean
    ends_at?: boolean
    segment_tags?: boolean
    segment_states?: boolean
    segment_devices?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }

  export type announcementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "body_md" | "status" | "starts_at" | "ends_at" | "segment_tags" | "segment_states" | "segment_devices" | "created_at" | "updated_at" | "deleted_at", ExtArgs["result"]["announcement"]>

  export type $announcementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "announcement"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      body_md: string
      status: $Enums.announcement_status
      starts_at: Date | null
      ends_at: Date | null
      segment_tags: string[]
      segment_states: string[]
      segment_devices: string[]
      created_at: Date
      updated_at: Date
      deleted_at: Date | null
    }, ExtArgs["result"]["announcement"]>
    composites: {}
  }

  type announcementGetPayload<S extends boolean | null | undefined | announcementDefaultArgs> = $Result.GetResult<Prisma.$announcementPayload, S>

  type announcementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<announcementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AnnouncementCountAggregateInputType | true
    }

  export interface announcementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['announcement'], meta: { name: 'announcement' } }
    /**
     * Find zero or one Announcement that matches the filter.
     * @param {announcementFindUniqueArgs} args - Arguments to find a Announcement
     * @example
     * // Get one Announcement
     * const announcement = await prisma.announcement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends announcementFindUniqueArgs>(args: SelectSubset<T, announcementFindUniqueArgs<ExtArgs>>): Prisma__announcementClient<$Result.GetResult<Prisma.$announcementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Announcement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {announcementFindUniqueOrThrowArgs} args - Arguments to find a Announcement
     * @example
     * // Get one Announcement
     * const announcement = await prisma.announcement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends announcementFindUniqueOrThrowArgs>(args: SelectSubset<T, announcementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__announcementClient<$Result.GetResult<Prisma.$announcementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Announcement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {announcementFindFirstArgs} args - Arguments to find a Announcement
     * @example
     * // Get one Announcement
     * const announcement = await prisma.announcement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends announcementFindFirstArgs>(args?: SelectSubset<T, announcementFindFirstArgs<ExtArgs>>): Prisma__announcementClient<$Result.GetResult<Prisma.$announcementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Announcement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {announcementFindFirstOrThrowArgs} args - Arguments to find a Announcement
     * @example
     * // Get one Announcement
     * const announcement = await prisma.announcement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends announcementFindFirstOrThrowArgs>(args?: SelectSubset<T, announcementFindFirstOrThrowArgs<ExtArgs>>): Prisma__announcementClient<$Result.GetResult<Prisma.$announcementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Announcements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {announcementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Announcements
     * const announcements = await prisma.announcement.findMany()
     * 
     * // Get first 10 Announcements
     * const announcements = await prisma.announcement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const announcementWithIdOnly = await prisma.announcement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends announcementFindManyArgs>(args?: SelectSubset<T, announcementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$announcementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Announcement.
     * @param {announcementCreateArgs} args - Arguments to create a Announcement.
     * @example
     * // Create one Announcement
     * const Announcement = await prisma.announcement.create({
     *   data: {
     *     // ... data to create a Announcement
     *   }
     * })
     * 
     */
    create<T extends announcementCreateArgs>(args: SelectSubset<T, announcementCreateArgs<ExtArgs>>): Prisma__announcementClient<$Result.GetResult<Prisma.$announcementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Announcements.
     * @param {announcementCreateManyArgs} args - Arguments to create many Announcements.
     * @example
     * // Create many Announcements
     * const announcement = await prisma.announcement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends announcementCreateManyArgs>(args?: SelectSubset<T, announcementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Announcement.
     * @param {announcementDeleteArgs} args - Arguments to delete one Announcement.
     * @example
     * // Delete one Announcement
     * const Announcement = await prisma.announcement.delete({
     *   where: {
     *     // ... filter to delete one Announcement
     *   }
     * })
     * 
     */
    delete<T extends announcementDeleteArgs>(args: SelectSubset<T, announcementDeleteArgs<ExtArgs>>): Prisma__announcementClient<$Result.GetResult<Prisma.$announcementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Announcement.
     * @param {announcementUpdateArgs} args - Arguments to update one Announcement.
     * @example
     * // Update one Announcement
     * const announcement = await prisma.announcement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends announcementUpdateArgs>(args: SelectSubset<T, announcementUpdateArgs<ExtArgs>>): Prisma__announcementClient<$Result.GetResult<Prisma.$announcementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Announcements.
     * @param {announcementDeleteManyArgs} args - Arguments to filter Announcements to delete.
     * @example
     * // Delete a few Announcements
     * const { count } = await prisma.announcement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends announcementDeleteManyArgs>(args?: SelectSubset<T, announcementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Announcements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {announcementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Announcements
     * const announcement = await prisma.announcement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends announcementUpdateManyArgs>(args: SelectSubset<T, announcementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Announcement.
     * @param {announcementUpsertArgs} args - Arguments to update or create a Announcement.
     * @example
     * // Update or create a Announcement
     * const announcement = await prisma.announcement.upsert({
     *   create: {
     *     // ... data to create a Announcement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Announcement we want to update
     *   }
     * })
     */
    upsert<T extends announcementUpsertArgs>(args: SelectSubset<T, announcementUpsertArgs<ExtArgs>>): Prisma__announcementClient<$Result.GetResult<Prisma.$announcementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Announcements that matches the filter.
     * @param {announcementFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const announcement = await prisma.announcement.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: announcementFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Announcement.
     * @param {announcementAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const announcement = await prisma.announcement.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: announcementAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Announcements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {announcementCountArgs} args - Arguments to filter Announcements to count.
     * @example
     * // Count the number of Announcements
     * const count = await prisma.announcement.count({
     *   where: {
     *     // ... the filter for the Announcements we want to count
     *   }
     * })
    **/
    count<T extends announcementCountArgs>(
      args?: Subset<T, announcementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnnouncementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Announcement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnnouncementAggregateArgs>(args: Subset<T, AnnouncementAggregateArgs>): Prisma.PrismaPromise<GetAnnouncementAggregateType<T>>

    /**
     * Group by Announcement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {announcementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends announcementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: announcementGroupByArgs['orderBy'] }
        : { orderBy?: announcementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, announcementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnnouncementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the announcement model
   */
  readonly fields: announcementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for announcement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__announcementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the announcement model
   */
  interface announcementFieldRefs {
    readonly id: FieldRef<"announcement", 'String'>
    readonly title: FieldRef<"announcement", 'String'>
    readonly body_md: FieldRef<"announcement", 'String'>
    readonly status: FieldRef<"announcement", 'announcement_status'>
    readonly starts_at: FieldRef<"announcement", 'DateTime'>
    readonly ends_at: FieldRef<"announcement", 'DateTime'>
    readonly segment_tags: FieldRef<"announcement", 'String[]'>
    readonly segment_states: FieldRef<"announcement", 'String[]'>
    readonly segment_devices: FieldRef<"announcement", 'String[]'>
    readonly created_at: FieldRef<"announcement", 'DateTime'>
    readonly updated_at: FieldRef<"announcement", 'DateTime'>
    readonly deleted_at: FieldRef<"announcement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * announcement findUnique
   */
  export type announcementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the announcement
     */
    select?: announcementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the announcement
     */
    omit?: announcementOmit<ExtArgs> | null
    /**
     * Filter, which announcement to fetch.
     */
    where: announcementWhereUniqueInput
  }

  /**
   * announcement findUniqueOrThrow
   */
  export type announcementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the announcement
     */
    select?: announcementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the announcement
     */
    omit?: announcementOmit<ExtArgs> | null
    /**
     * Filter, which announcement to fetch.
     */
    where: announcementWhereUniqueInput
  }

  /**
   * announcement findFirst
   */
  export type announcementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the announcement
     */
    select?: announcementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the announcement
     */
    omit?: announcementOmit<ExtArgs> | null
    /**
     * Filter, which announcement to fetch.
     */
    where?: announcementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of announcements to fetch.
     */
    orderBy?: announcementOrderByWithRelationInput | announcementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for announcements.
     */
    cursor?: announcementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` announcements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` announcements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of announcements.
     */
    distinct?: AnnouncementScalarFieldEnum | AnnouncementScalarFieldEnum[]
  }

  /**
   * announcement findFirstOrThrow
   */
  export type announcementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the announcement
     */
    select?: announcementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the announcement
     */
    omit?: announcementOmit<ExtArgs> | null
    /**
     * Filter, which announcement to fetch.
     */
    where?: announcementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of announcements to fetch.
     */
    orderBy?: announcementOrderByWithRelationInput | announcementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for announcements.
     */
    cursor?: announcementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` announcements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` announcements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of announcements.
     */
    distinct?: AnnouncementScalarFieldEnum | AnnouncementScalarFieldEnum[]
  }

  /**
   * announcement findMany
   */
  export type announcementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the announcement
     */
    select?: announcementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the announcement
     */
    omit?: announcementOmit<ExtArgs> | null
    /**
     * Filter, which announcements to fetch.
     */
    where?: announcementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of announcements to fetch.
     */
    orderBy?: announcementOrderByWithRelationInput | announcementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing announcements.
     */
    cursor?: announcementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` announcements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` announcements.
     */
    skip?: number
    distinct?: AnnouncementScalarFieldEnum | AnnouncementScalarFieldEnum[]
  }

  /**
   * announcement create
   */
  export type announcementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the announcement
     */
    select?: announcementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the announcement
     */
    omit?: announcementOmit<ExtArgs> | null
    /**
     * The data needed to create a announcement.
     */
    data: XOR<announcementCreateInput, announcementUncheckedCreateInput>
  }

  /**
   * announcement createMany
   */
  export type announcementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many announcements.
     */
    data: announcementCreateManyInput | announcementCreateManyInput[]
  }

  /**
   * announcement update
   */
  export type announcementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the announcement
     */
    select?: announcementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the announcement
     */
    omit?: announcementOmit<ExtArgs> | null
    /**
     * The data needed to update a announcement.
     */
    data: XOR<announcementUpdateInput, announcementUncheckedUpdateInput>
    /**
     * Choose, which announcement to update.
     */
    where: announcementWhereUniqueInput
  }

  /**
   * announcement updateMany
   */
  export type announcementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update announcements.
     */
    data: XOR<announcementUpdateManyMutationInput, announcementUncheckedUpdateManyInput>
    /**
     * Filter which announcements to update
     */
    where?: announcementWhereInput
    /**
     * Limit how many announcements to update.
     */
    limit?: number
  }

  /**
   * announcement upsert
   */
  export type announcementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the announcement
     */
    select?: announcementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the announcement
     */
    omit?: announcementOmit<ExtArgs> | null
    /**
     * The filter to search for the announcement to update in case it exists.
     */
    where: announcementWhereUniqueInput
    /**
     * In case the announcement found by the `where` argument doesn't exist, create a new announcement with this data.
     */
    create: XOR<announcementCreateInput, announcementUncheckedCreateInput>
    /**
     * In case the announcement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<announcementUpdateInput, announcementUncheckedUpdateInput>
  }

  /**
   * announcement delete
   */
  export type announcementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the announcement
     */
    select?: announcementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the announcement
     */
    omit?: announcementOmit<ExtArgs> | null
    /**
     * Filter which announcement to delete.
     */
    where: announcementWhereUniqueInput
  }

  /**
   * announcement deleteMany
   */
  export type announcementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which announcements to delete
     */
    where?: announcementWhereInput
    /**
     * Limit how many announcements to delete.
     */
    limit?: number
  }

  /**
   * announcement findRaw
   */
  export type announcementFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * announcement aggregateRaw
   */
  export type announcementAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * announcement without action
   */
  export type announcementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the announcement
     */
    select?: announcementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the announcement
     */
    omit?: announcementOmit<ExtArgs> | null
  }


  /**
   * Model feature_slot
   */

  export type AggregateFeature_slot = {
    _count: Feature_slotCountAggregateOutputType | null
    _min: Feature_slotMinAggregateOutputType | null
    _max: Feature_slotMaxAggregateOutputType | null
  }

  export type Feature_slotMinAggregateOutputType = {
    id: string | null
    slot_key: $Enums.feature_slot_key | null
    description: string | null
    status: $Enums.setting_status | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type Feature_slotMaxAggregateOutputType = {
    id: string | null
    slot_key: $Enums.feature_slot_key | null
    description: string | null
    status: $Enums.setting_status | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type Feature_slotCountAggregateOutputType = {
    id: number
    slot_key: number
    description: number
    status: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type Feature_slotMinAggregateInputType = {
    id?: true
    slot_key?: true
    description?: true
    status?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type Feature_slotMaxAggregateInputType = {
    id?: true
    slot_key?: true
    description?: true
    status?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type Feature_slotCountAggregateInputType = {
    id?: true
    slot_key?: true
    description?: true
    status?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type Feature_slotAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which feature_slot to aggregate.
     */
    where?: feature_slotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of feature_slots to fetch.
     */
    orderBy?: feature_slotOrderByWithRelationInput | feature_slotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: feature_slotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` feature_slots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` feature_slots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned feature_slots
    **/
    _count?: true | Feature_slotCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Feature_slotMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Feature_slotMaxAggregateInputType
  }

  export type GetFeature_slotAggregateType<T extends Feature_slotAggregateArgs> = {
        [P in keyof T & keyof AggregateFeature_slot]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeature_slot[P]>
      : GetScalarType<T[P], AggregateFeature_slot[P]>
  }




  export type feature_slotGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: feature_slotWhereInput
    orderBy?: feature_slotOrderByWithAggregationInput | feature_slotOrderByWithAggregationInput[]
    by: Feature_slotScalarFieldEnum[] | Feature_slotScalarFieldEnum
    having?: feature_slotScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Feature_slotCountAggregateInputType | true
    _min?: Feature_slotMinAggregateInputType
    _max?: Feature_slotMaxAggregateInputType
  }

  export type Feature_slotGroupByOutputType = {
    id: string
    slot_key: $Enums.feature_slot_key
    description: string | null
    status: $Enums.setting_status
    created_at: Date
    updated_at: Date
    deleted_at: Date | null
    _count: Feature_slotCountAggregateOutputType | null
    _min: Feature_slotMinAggregateOutputType | null
    _max: Feature_slotMaxAggregateOutputType | null
  }

  type GetFeature_slotGroupByPayload<T extends feature_slotGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Feature_slotGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Feature_slotGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Feature_slotGroupByOutputType[P]>
            : GetScalarType<T[P], Feature_slotGroupByOutputType[P]>
        }
      >
    >


  export type feature_slotSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slot_key?: boolean
    description?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }, ExtArgs["result"]["feature_slot"]>



  export type feature_slotSelectScalar = {
    id?: boolean
    slot_key?: boolean
    description?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }

  export type feature_slotOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "slot_key" | "description" | "status" | "created_at" | "updated_at" | "deleted_at", ExtArgs["result"]["feature_slot"]>

  export type $feature_slotPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "feature_slot"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      slot_key: $Enums.feature_slot_key
      description: string | null
      status: $Enums.setting_status
      created_at: Date
      updated_at: Date
      deleted_at: Date | null
    }, ExtArgs["result"]["feature_slot"]>
    composites: {}
  }

  type feature_slotGetPayload<S extends boolean | null | undefined | feature_slotDefaultArgs> = $Result.GetResult<Prisma.$feature_slotPayload, S>

  type feature_slotCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<feature_slotFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Feature_slotCountAggregateInputType | true
    }

  export interface feature_slotDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['feature_slot'], meta: { name: 'feature_slot' } }
    /**
     * Find zero or one Feature_slot that matches the filter.
     * @param {feature_slotFindUniqueArgs} args - Arguments to find a Feature_slot
     * @example
     * // Get one Feature_slot
     * const feature_slot = await prisma.feature_slot.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends feature_slotFindUniqueArgs>(args: SelectSubset<T, feature_slotFindUniqueArgs<ExtArgs>>): Prisma__feature_slotClient<$Result.GetResult<Prisma.$feature_slotPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Feature_slot that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {feature_slotFindUniqueOrThrowArgs} args - Arguments to find a Feature_slot
     * @example
     * // Get one Feature_slot
     * const feature_slot = await prisma.feature_slot.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends feature_slotFindUniqueOrThrowArgs>(args: SelectSubset<T, feature_slotFindUniqueOrThrowArgs<ExtArgs>>): Prisma__feature_slotClient<$Result.GetResult<Prisma.$feature_slotPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Feature_slot that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {feature_slotFindFirstArgs} args - Arguments to find a Feature_slot
     * @example
     * // Get one Feature_slot
     * const feature_slot = await prisma.feature_slot.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends feature_slotFindFirstArgs>(args?: SelectSubset<T, feature_slotFindFirstArgs<ExtArgs>>): Prisma__feature_slotClient<$Result.GetResult<Prisma.$feature_slotPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Feature_slot that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {feature_slotFindFirstOrThrowArgs} args - Arguments to find a Feature_slot
     * @example
     * // Get one Feature_slot
     * const feature_slot = await prisma.feature_slot.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends feature_slotFindFirstOrThrowArgs>(args?: SelectSubset<T, feature_slotFindFirstOrThrowArgs<ExtArgs>>): Prisma__feature_slotClient<$Result.GetResult<Prisma.$feature_slotPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Feature_slots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {feature_slotFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Feature_slots
     * const feature_slots = await prisma.feature_slot.findMany()
     * 
     * // Get first 10 Feature_slots
     * const feature_slots = await prisma.feature_slot.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const feature_slotWithIdOnly = await prisma.feature_slot.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends feature_slotFindManyArgs>(args?: SelectSubset<T, feature_slotFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$feature_slotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Feature_slot.
     * @param {feature_slotCreateArgs} args - Arguments to create a Feature_slot.
     * @example
     * // Create one Feature_slot
     * const Feature_slot = await prisma.feature_slot.create({
     *   data: {
     *     // ... data to create a Feature_slot
     *   }
     * })
     * 
     */
    create<T extends feature_slotCreateArgs>(args: SelectSubset<T, feature_slotCreateArgs<ExtArgs>>): Prisma__feature_slotClient<$Result.GetResult<Prisma.$feature_slotPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Feature_slots.
     * @param {feature_slotCreateManyArgs} args - Arguments to create many Feature_slots.
     * @example
     * // Create many Feature_slots
     * const feature_slot = await prisma.feature_slot.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends feature_slotCreateManyArgs>(args?: SelectSubset<T, feature_slotCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Feature_slot.
     * @param {feature_slotDeleteArgs} args - Arguments to delete one Feature_slot.
     * @example
     * // Delete one Feature_slot
     * const Feature_slot = await prisma.feature_slot.delete({
     *   where: {
     *     // ... filter to delete one Feature_slot
     *   }
     * })
     * 
     */
    delete<T extends feature_slotDeleteArgs>(args: SelectSubset<T, feature_slotDeleteArgs<ExtArgs>>): Prisma__feature_slotClient<$Result.GetResult<Prisma.$feature_slotPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Feature_slot.
     * @param {feature_slotUpdateArgs} args - Arguments to update one Feature_slot.
     * @example
     * // Update one Feature_slot
     * const feature_slot = await prisma.feature_slot.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends feature_slotUpdateArgs>(args: SelectSubset<T, feature_slotUpdateArgs<ExtArgs>>): Prisma__feature_slotClient<$Result.GetResult<Prisma.$feature_slotPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Feature_slots.
     * @param {feature_slotDeleteManyArgs} args - Arguments to filter Feature_slots to delete.
     * @example
     * // Delete a few Feature_slots
     * const { count } = await prisma.feature_slot.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends feature_slotDeleteManyArgs>(args?: SelectSubset<T, feature_slotDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Feature_slots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {feature_slotUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Feature_slots
     * const feature_slot = await prisma.feature_slot.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends feature_slotUpdateManyArgs>(args: SelectSubset<T, feature_slotUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Feature_slot.
     * @param {feature_slotUpsertArgs} args - Arguments to update or create a Feature_slot.
     * @example
     * // Update or create a Feature_slot
     * const feature_slot = await prisma.feature_slot.upsert({
     *   create: {
     *     // ... data to create a Feature_slot
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Feature_slot we want to update
     *   }
     * })
     */
    upsert<T extends feature_slotUpsertArgs>(args: SelectSubset<T, feature_slotUpsertArgs<ExtArgs>>): Prisma__feature_slotClient<$Result.GetResult<Prisma.$feature_slotPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Feature_slots that matches the filter.
     * @param {feature_slotFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const feature_slot = await prisma.feature_slot.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: feature_slotFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Feature_slot.
     * @param {feature_slotAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const feature_slot = await prisma.feature_slot.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: feature_slotAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Feature_slots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {feature_slotCountArgs} args - Arguments to filter Feature_slots to count.
     * @example
     * // Count the number of Feature_slots
     * const count = await prisma.feature_slot.count({
     *   where: {
     *     // ... the filter for the Feature_slots we want to count
     *   }
     * })
    **/
    count<T extends feature_slotCountArgs>(
      args?: Subset<T, feature_slotCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Feature_slotCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Feature_slot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Feature_slotAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Feature_slotAggregateArgs>(args: Subset<T, Feature_slotAggregateArgs>): Prisma.PrismaPromise<GetFeature_slotAggregateType<T>>

    /**
     * Group by Feature_slot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {feature_slotGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends feature_slotGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: feature_slotGroupByArgs['orderBy'] }
        : { orderBy?: feature_slotGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, feature_slotGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeature_slotGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the feature_slot model
   */
  readonly fields: feature_slotFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for feature_slot.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__feature_slotClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the feature_slot model
   */
  interface feature_slotFieldRefs {
    readonly id: FieldRef<"feature_slot", 'String'>
    readonly slot_key: FieldRef<"feature_slot", 'feature_slot_key'>
    readonly description: FieldRef<"feature_slot", 'String'>
    readonly status: FieldRef<"feature_slot", 'setting_status'>
    readonly created_at: FieldRef<"feature_slot", 'DateTime'>
    readonly updated_at: FieldRef<"feature_slot", 'DateTime'>
    readonly deleted_at: FieldRef<"feature_slot", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * feature_slot findUnique
   */
  export type feature_slotFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feature_slot
     */
    select?: feature_slotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the feature_slot
     */
    omit?: feature_slotOmit<ExtArgs> | null
    /**
     * Filter, which feature_slot to fetch.
     */
    where: feature_slotWhereUniqueInput
  }

  /**
   * feature_slot findUniqueOrThrow
   */
  export type feature_slotFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feature_slot
     */
    select?: feature_slotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the feature_slot
     */
    omit?: feature_slotOmit<ExtArgs> | null
    /**
     * Filter, which feature_slot to fetch.
     */
    where: feature_slotWhereUniqueInput
  }

  /**
   * feature_slot findFirst
   */
  export type feature_slotFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feature_slot
     */
    select?: feature_slotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the feature_slot
     */
    omit?: feature_slotOmit<ExtArgs> | null
    /**
     * Filter, which feature_slot to fetch.
     */
    where?: feature_slotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of feature_slots to fetch.
     */
    orderBy?: feature_slotOrderByWithRelationInput | feature_slotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for feature_slots.
     */
    cursor?: feature_slotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` feature_slots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` feature_slots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of feature_slots.
     */
    distinct?: Feature_slotScalarFieldEnum | Feature_slotScalarFieldEnum[]
  }

  /**
   * feature_slot findFirstOrThrow
   */
  export type feature_slotFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feature_slot
     */
    select?: feature_slotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the feature_slot
     */
    omit?: feature_slotOmit<ExtArgs> | null
    /**
     * Filter, which feature_slot to fetch.
     */
    where?: feature_slotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of feature_slots to fetch.
     */
    orderBy?: feature_slotOrderByWithRelationInput | feature_slotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for feature_slots.
     */
    cursor?: feature_slotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` feature_slots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` feature_slots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of feature_slots.
     */
    distinct?: Feature_slotScalarFieldEnum | Feature_slotScalarFieldEnum[]
  }

  /**
   * feature_slot findMany
   */
  export type feature_slotFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feature_slot
     */
    select?: feature_slotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the feature_slot
     */
    omit?: feature_slotOmit<ExtArgs> | null
    /**
     * Filter, which feature_slots to fetch.
     */
    where?: feature_slotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of feature_slots to fetch.
     */
    orderBy?: feature_slotOrderByWithRelationInput | feature_slotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing feature_slots.
     */
    cursor?: feature_slotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` feature_slots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` feature_slots.
     */
    skip?: number
    distinct?: Feature_slotScalarFieldEnum | Feature_slotScalarFieldEnum[]
  }

  /**
   * feature_slot create
   */
  export type feature_slotCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feature_slot
     */
    select?: feature_slotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the feature_slot
     */
    omit?: feature_slotOmit<ExtArgs> | null
    /**
     * The data needed to create a feature_slot.
     */
    data: XOR<feature_slotCreateInput, feature_slotUncheckedCreateInput>
  }

  /**
   * feature_slot createMany
   */
  export type feature_slotCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many feature_slots.
     */
    data: feature_slotCreateManyInput | feature_slotCreateManyInput[]
  }

  /**
   * feature_slot update
   */
  export type feature_slotUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feature_slot
     */
    select?: feature_slotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the feature_slot
     */
    omit?: feature_slotOmit<ExtArgs> | null
    /**
     * The data needed to update a feature_slot.
     */
    data: XOR<feature_slotUpdateInput, feature_slotUncheckedUpdateInput>
    /**
     * Choose, which feature_slot to update.
     */
    where: feature_slotWhereUniqueInput
  }

  /**
   * feature_slot updateMany
   */
  export type feature_slotUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update feature_slots.
     */
    data: XOR<feature_slotUpdateManyMutationInput, feature_slotUncheckedUpdateManyInput>
    /**
     * Filter which feature_slots to update
     */
    where?: feature_slotWhereInput
    /**
     * Limit how many feature_slots to update.
     */
    limit?: number
  }

  /**
   * feature_slot upsert
   */
  export type feature_slotUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feature_slot
     */
    select?: feature_slotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the feature_slot
     */
    omit?: feature_slotOmit<ExtArgs> | null
    /**
     * The filter to search for the feature_slot to update in case it exists.
     */
    where: feature_slotWhereUniqueInput
    /**
     * In case the feature_slot found by the `where` argument doesn't exist, create a new feature_slot with this data.
     */
    create: XOR<feature_slotCreateInput, feature_slotUncheckedCreateInput>
    /**
     * In case the feature_slot was found with the provided `where` argument, update it with this data.
     */
    update: XOR<feature_slotUpdateInput, feature_slotUncheckedUpdateInput>
  }

  /**
   * feature_slot delete
   */
  export type feature_slotDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feature_slot
     */
    select?: feature_slotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the feature_slot
     */
    omit?: feature_slotOmit<ExtArgs> | null
    /**
     * Filter which feature_slot to delete.
     */
    where: feature_slotWhereUniqueInput
  }

  /**
   * feature_slot deleteMany
   */
  export type feature_slotDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which feature_slots to delete
     */
    where?: feature_slotWhereInput
    /**
     * Limit how many feature_slots to delete.
     */
    limit?: number
  }

  /**
   * feature_slot findRaw
   */
  export type feature_slotFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * feature_slot aggregateRaw
   */
  export type feature_slotAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * feature_slot without action
   */
  export type feature_slotDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feature_slot
     */
    select?: feature_slotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the feature_slot
     */
    omit?: feature_slotOmit<ExtArgs> | null
  }


  /**
   * Model featured_assignment
   */

  export type AggregateFeatured_assignment = {
    _count: Featured_assignmentCountAggregateOutputType | null
    _avg: Featured_assignmentAvgAggregateOutputType | null
    _sum: Featured_assignmentSumAggregateOutputType | null
    _min: Featured_assignmentMinAggregateOutputType | null
    _max: Featured_assignmentMaxAggregateOutputType | null
  }

  export type Featured_assignmentAvgAggregateOutputType = {
    priority: number | null
  }

  export type Featured_assignmentSumAggregateOutputType = {
    priority: number | null
  }

  export type Featured_assignmentMinAggregateOutputType = {
    id: string | null
    slot_key: $Enums.feature_slot_key | null
    player_id: string | null
    media_id: string | null
    starts_at: Date | null
    ends_at: Date | null
    priority: number | null
    status: $Enums.setting_status | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type Featured_assignmentMaxAggregateOutputType = {
    id: string | null
    slot_key: $Enums.feature_slot_key | null
    player_id: string | null
    media_id: string | null
    starts_at: Date | null
    ends_at: Date | null
    priority: number | null
    status: $Enums.setting_status | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type Featured_assignmentCountAggregateOutputType = {
    id: number
    slot_key: number
    player_id: number
    media_id: number
    starts_at: number
    ends_at: number
    priority: number
    status: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type Featured_assignmentAvgAggregateInputType = {
    priority?: true
  }

  export type Featured_assignmentSumAggregateInputType = {
    priority?: true
  }

  export type Featured_assignmentMinAggregateInputType = {
    id?: true
    slot_key?: true
    player_id?: true
    media_id?: true
    starts_at?: true
    ends_at?: true
    priority?: true
    status?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type Featured_assignmentMaxAggregateInputType = {
    id?: true
    slot_key?: true
    player_id?: true
    media_id?: true
    starts_at?: true
    ends_at?: true
    priority?: true
    status?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type Featured_assignmentCountAggregateInputType = {
    id?: true
    slot_key?: true
    player_id?: true
    media_id?: true
    starts_at?: true
    ends_at?: true
    priority?: true
    status?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type Featured_assignmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which featured_assignment to aggregate.
     */
    where?: featured_assignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of featured_assignments to fetch.
     */
    orderBy?: featured_assignmentOrderByWithRelationInput | featured_assignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: featured_assignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` featured_assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` featured_assignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned featured_assignments
    **/
    _count?: true | Featured_assignmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Featured_assignmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Featured_assignmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Featured_assignmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Featured_assignmentMaxAggregateInputType
  }

  export type GetFeatured_assignmentAggregateType<T extends Featured_assignmentAggregateArgs> = {
        [P in keyof T & keyof AggregateFeatured_assignment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeatured_assignment[P]>
      : GetScalarType<T[P], AggregateFeatured_assignment[P]>
  }




  export type featured_assignmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: featured_assignmentWhereInput
    orderBy?: featured_assignmentOrderByWithAggregationInput | featured_assignmentOrderByWithAggregationInput[]
    by: Featured_assignmentScalarFieldEnum[] | Featured_assignmentScalarFieldEnum
    having?: featured_assignmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Featured_assignmentCountAggregateInputType | true
    _avg?: Featured_assignmentAvgAggregateInputType
    _sum?: Featured_assignmentSumAggregateInputType
    _min?: Featured_assignmentMinAggregateInputType
    _max?: Featured_assignmentMaxAggregateInputType
  }

  export type Featured_assignmentGroupByOutputType = {
    id: string
    slot_key: $Enums.feature_slot_key
    player_id: string
    media_id: string | null
    starts_at: Date
    ends_at: Date
    priority: number
    status: $Enums.setting_status
    created_at: Date
    updated_at: Date
    deleted_at: Date | null
    _count: Featured_assignmentCountAggregateOutputType | null
    _avg: Featured_assignmentAvgAggregateOutputType | null
    _sum: Featured_assignmentSumAggregateOutputType | null
    _min: Featured_assignmentMinAggregateOutputType | null
    _max: Featured_assignmentMaxAggregateOutputType | null
  }

  type GetFeatured_assignmentGroupByPayload<T extends featured_assignmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Featured_assignmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Featured_assignmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Featured_assignmentGroupByOutputType[P]>
            : GetScalarType<T[P], Featured_assignmentGroupByOutputType[P]>
        }
      >
    >


  export type featured_assignmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slot_key?: boolean
    player_id?: boolean
    media_id?: boolean
    starts_at?: boolean
    ends_at?: boolean
    priority?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    player?: boolean | profileDefaultArgs<ExtArgs>
    media_ref?: boolean | featured_assignment$media_refArgs<ExtArgs>
  }, ExtArgs["result"]["featured_assignment"]>



  export type featured_assignmentSelectScalar = {
    id?: boolean
    slot_key?: boolean
    player_id?: boolean
    media_id?: boolean
    starts_at?: boolean
    ends_at?: boolean
    priority?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }

  export type featured_assignmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "slot_key" | "player_id" | "media_id" | "starts_at" | "ends_at" | "priority" | "status" | "created_at" | "updated_at" | "deleted_at", ExtArgs["result"]["featured_assignment"]>
  export type featured_assignmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | profileDefaultArgs<ExtArgs>
    media_ref?: boolean | featured_assignment$media_refArgs<ExtArgs>
  }

  export type $featured_assignmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "featured_assignment"
    objects: {
      player: Prisma.$profilePayload<ExtArgs>
      media_ref: Prisma.$mediaPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      slot_key: $Enums.feature_slot_key
      player_id: string
      media_id: string | null
      starts_at: Date
      ends_at: Date
      priority: number
      status: $Enums.setting_status
      created_at: Date
      updated_at: Date
      deleted_at: Date | null
    }, ExtArgs["result"]["featured_assignment"]>
    composites: {}
  }

  type featured_assignmentGetPayload<S extends boolean | null | undefined | featured_assignmentDefaultArgs> = $Result.GetResult<Prisma.$featured_assignmentPayload, S>

  type featured_assignmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<featured_assignmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Featured_assignmentCountAggregateInputType | true
    }

  export interface featured_assignmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['featured_assignment'], meta: { name: 'featured_assignment' } }
    /**
     * Find zero or one Featured_assignment that matches the filter.
     * @param {featured_assignmentFindUniqueArgs} args - Arguments to find a Featured_assignment
     * @example
     * // Get one Featured_assignment
     * const featured_assignment = await prisma.featured_assignment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends featured_assignmentFindUniqueArgs>(args: SelectSubset<T, featured_assignmentFindUniqueArgs<ExtArgs>>): Prisma__featured_assignmentClient<$Result.GetResult<Prisma.$featured_assignmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Featured_assignment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {featured_assignmentFindUniqueOrThrowArgs} args - Arguments to find a Featured_assignment
     * @example
     * // Get one Featured_assignment
     * const featured_assignment = await prisma.featured_assignment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends featured_assignmentFindUniqueOrThrowArgs>(args: SelectSubset<T, featured_assignmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__featured_assignmentClient<$Result.GetResult<Prisma.$featured_assignmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Featured_assignment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {featured_assignmentFindFirstArgs} args - Arguments to find a Featured_assignment
     * @example
     * // Get one Featured_assignment
     * const featured_assignment = await prisma.featured_assignment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends featured_assignmentFindFirstArgs>(args?: SelectSubset<T, featured_assignmentFindFirstArgs<ExtArgs>>): Prisma__featured_assignmentClient<$Result.GetResult<Prisma.$featured_assignmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Featured_assignment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {featured_assignmentFindFirstOrThrowArgs} args - Arguments to find a Featured_assignment
     * @example
     * // Get one Featured_assignment
     * const featured_assignment = await prisma.featured_assignment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends featured_assignmentFindFirstOrThrowArgs>(args?: SelectSubset<T, featured_assignmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__featured_assignmentClient<$Result.GetResult<Prisma.$featured_assignmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Featured_assignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {featured_assignmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Featured_assignments
     * const featured_assignments = await prisma.featured_assignment.findMany()
     * 
     * // Get first 10 Featured_assignments
     * const featured_assignments = await prisma.featured_assignment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const featured_assignmentWithIdOnly = await prisma.featured_assignment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends featured_assignmentFindManyArgs>(args?: SelectSubset<T, featured_assignmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$featured_assignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Featured_assignment.
     * @param {featured_assignmentCreateArgs} args - Arguments to create a Featured_assignment.
     * @example
     * // Create one Featured_assignment
     * const Featured_assignment = await prisma.featured_assignment.create({
     *   data: {
     *     // ... data to create a Featured_assignment
     *   }
     * })
     * 
     */
    create<T extends featured_assignmentCreateArgs>(args: SelectSubset<T, featured_assignmentCreateArgs<ExtArgs>>): Prisma__featured_assignmentClient<$Result.GetResult<Prisma.$featured_assignmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Featured_assignments.
     * @param {featured_assignmentCreateManyArgs} args - Arguments to create many Featured_assignments.
     * @example
     * // Create many Featured_assignments
     * const featured_assignment = await prisma.featured_assignment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends featured_assignmentCreateManyArgs>(args?: SelectSubset<T, featured_assignmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Featured_assignment.
     * @param {featured_assignmentDeleteArgs} args - Arguments to delete one Featured_assignment.
     * @example
     * // Delete one Featured_assignment
     * const Featured_assignment = await prisma.featured_assignment.delete({
     *   where: {
     *     // ... filter to delete one Featured_assignment
     *   }
     * })
     * 
     */
    delete<T extends featured_assignmentDeleteArgs>(args: SelectSubset<T, featured_assignmentDeleteArgs<ExtArgs>>): Prisma__featured_assignmentClient<$Result.GetResult<Prisma.$featured_assignmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Featured_assignment.
     * @param {featured_assignmentUpdateArgs} args - Arguments to update one Featured_assignment.
     * @example
     * // Update one Featured_assignment
     * const featured_assignment = await prisma.featured_assignment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends featured_assignmentUpdateArgs>(args: SelectSubset<T, featured_assignmentUpdateArgs<ExtArgs>>): Prisma__featured_assignmentClient<$Result.GetResult<Prisma.$featured_assignmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Featured_assignments.
     * @param {featured_assignmentDeleteManyArgs} args - Arguments to filter Featured_assignments to delete.
     * @example
     * // Delete a few Featured_assignments
     * const { count } = await prisma.featured_assignment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends featured_assignmentDeleteManyArgs>(args?: SelectSubset<T, featured_assignmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Featured_assignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {featured_assignmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Featured_assignments
     * const featured_assignment = await prisma.featured_assignment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends featured_assignmentUpdateManyArgs>(args: SelectSubset<T, featured_assignmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Featured_assignment.
     * @param {featured_assignmentUpsertArgs} args - Arguments to update or create a Featured_assignment.
     * @example
     * // Update or create a Featured_assignment
     * const featured_assignment = await prisma.featured_assignment.upsert({
     *   create: {
     *     // ... data to create a Featured_assignment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Featured_assignment we want to update
     *   }
     * })
     */
    upsert<T extends featured_assignmentUpsertArgs>(args: SelectSubset<T, featured_assignmentUpsertArgs<ExtArgs>>): Prisma__featured_assignmentClient<$Result.GetResult<Prisma.$featured_assignmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Featured_assignments that matches the filter.
     * @param {featured_assignmentFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const featured_assignment = await prisma.featured_assignment.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: featured_assignmentFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Featured_assignment.
     * @param {featured_assignmentAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const featured_assignment = await prisma.featured_assignment.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: featured_assignmentAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Featured_assignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {featured_assignmentCountArgs} args - Arguments to filter Featured_assignments to count.
     * @example
     * // Count the number of Featured_assignments
     * const count = await prisma.featured_assignment.count({
     *   where: {
     *     // ... the filter for the Featured_assignments we want to count
     *   }
     * })
    **/
    count<T extends featured_assignmentCountArgs>(
      args?: Subset<T, featured_assignmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Featured_assignmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Featured_assignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Featured_assignmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Featured_assignmentAggregateArgs>(args: Subset<T, Featured_assignmentAggregateArgs>): Prisma.PrismaPromise<GetFeatured_assignmentAggregateType<T>>

    /**
     * Group by Featured_assignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {featured_assignmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends featured_assignmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: featured_assignmentGroupByArgs['orderBy'] }
        : { orderBy?: featured_assignmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, featured_assignmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeatured_assignmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the featured_assignment model
   */
  readonly fields: featured_assignmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for featured_assignment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__featured_assignmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    player<T extends profileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, profileDefaultArgs<ExtArgs>>): Prisma__profileClient<$Result.GetResult<Prisma.$profilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    media_ref<T extends featured_assignment$media_refArgs<ExtArgs> = {}>(args?: Subset<T, featured_assignment$media_refArgs<ExtArgs>>): Prisma__mediaClient<$Result.GetResult<Prisma.$mediaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the featured_assignment model
   */
  interface featured_assignmentFieldRefs {
    readonly id: FieldRef<"featured_assignment", 'String'>
    readonly slot_key: FieldRef<"featured_assignment", 'feature_slot_key'>
    readonly player_id: FieldRef<"featured_assignment", 'String'>
    readonly media_id: FieldRef<"featured_assignment", 'String'>
    readonly starts_at: FieldRef<"featured_assignment", 'DateTime'>
    readonly ends_at: FieldRef<"featured_assignment", 'DateTime'>
    readonly priority: FieldRef<"featured_assignment", 'Int'>
    readonly status: FieldRef<"featured_assignment", 'setting_status'>
    readonly created_at: FieldRef<"featured_assignment", 'DateTime'>
    readonly updated_at: FieldRef<"featured_assignment", 'DateTime'>
    readonly deleted_at: FieldRef<"featured_assignment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * featured_assignment findUnique
   */
  export type featured_assignmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the featured_assignment
     */
    select?: featured_assignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the featured_assignment
     */
    omit?: featured_assignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: featured_assignmentInclude<ExtArgs> | null
    /**
     * Filter, which featured_assignment to fetch.
     */
    where: featured_assignmentWhereUniqueInput
  }

  /**
   * featured_assignment findUniqueOrThrow
   */
  export type featured_assignmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the featured_assignment
     */
    select?: featured_assignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the featured_assignment
     */
    omit?: featured_assignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: featured_assignmentInclude<ExtArgs> | null
    /**
     * Filter, which featured_assignment to fetch.
     */
    where: featured_assignmentWhereUniqueInput
  }

  /**
   * featured_assignment findFirst
   */
  export type featured_assignmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the featured_assignment
     */
    select?: featured_assignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the featured_assignment
     */
    omit?: featured_assignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: featured_assignmentInclude<ExtArgs> | null
    /**
     * Filter, which featured_assignment to fetch.
     */
    where?: featured_assignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of featured_assignments to fetch.
     */
    orderBy?: featured_assignmentOrderByWithRelationInput | featured_assignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for featured_assignments.
     */
    cursor?: featured_assignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` featured_assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` featured_assignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of featured_assignments.
     */
    distinct?: Featured_assignmentScalarFieldEnum | Featured_assignmentScalarFieldEnum[]
  }

  /**
   * featured_assignment findFirstOrThrow
   */
  export type featured_assignmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the featured_assignment
     */
    select?: featured_assignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the featured_assignment
     */
    omit?: featured_assignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: featured_assignmentInclude<ExtArgs> | null
    /**
     * Filter, which featured_assignment to fetch.
     */
    where?: featured_assignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of featured_assignments to fetch.
     */
    orderBy?: featured_assignmentOrderByWithRelationInput | featured_assignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for featured_assignments.
     */
    cursor?: featured_assignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` featured_assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` featured_assignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of featured_assignments.
     */
    distinct?: Featured_assignmentScalarFieldEnum | Featured_assignmentScalarFieldEnum[]
  }

  /**
   * featured_assignment findMany
   */
  export type featured_assignmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the featured_assignment
     */
    select?: featured_assignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the featured_assignment
     */
    omit?: featured_assignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: featured_assignmentInclude<ExtArgs> | null
    /**
     * Filter, which featured_assignments to fetch.
     */
    where?: featured_assignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of featured_assignments to fetch.
     */
    orderBy?: featured_assignmentOrderByWithRelationInput | featured_assignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing featured_assignments.
     */
    cursor?: featured_assignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` featured_assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` featured_assignments.
     */
    skip?: number
    distinct?: Featured_assignmentScalarFieldEnum | Featured_assignmentScalarFieldEnum[]
  }

  /**
   * featured_assignment create
   */
  export type featured_assignmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the featured_assignment
     */
    select?: featured_assignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the featured_assignment
     */
    omit?: featured_assignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: featured_assignmentInclude<ExtArgs> | null
    /**
     * The data needed to create a featured_assignment.
     */
    data: XOR<featured_assignmentCreateInput, featured_assignmentUncheckedCreateInput>
  }

  /**
   * featured_assignment createMany
   */
  export type featured_assignmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many featured_assignments.
     */
    data: featured_assignmentCreateManyInput | featured_assignmentCreateManyInput[]
  }

  /**
   * featured_assignment update
   */
  export type featured_assignmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the featured_assignment
     */
    select?: featured_assignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the featured_assignment
     */
    omit?: featured_assignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: featured_assignmentInclude<ExtArgs> | null
    /**
     * The data needed to update a featured_assignment.
     */
    data: XOR<featured_assignmentUpdateInput, featured_assignmentUncheckedUpdateInput>
    /**
     * Choose, which featured_assignment to update.
     */
    where: featured_assignmentWhereUniqueInput
  }

  /**
   * featured_assignment updateMany
   */
  export type featured_assignmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update featured_assignments.
     */
    data: XOR<featured_assignmentUpdateManyMutationInput, featured_assignmentUncheckedUpdateManyInput>
    /**
     * Filter which featured_assignments to update
     */
    where?: featured_assignmentWhereInput
    /**
     * Limit how many featured_assignments to update.
     */
    limit?: number
  }

  /**
   * featured_assignment upsert
   */
  export type featured_assignmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the featured_assignment
     */
    select?: featured_assignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the featured_assignment
     */
    omit?: featured_assignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: featured_assignmentInclude<ExtArgs> | null
    /**
     * The filter to search for the featured_assignment to update in case it exists.
     */
    where: featured_assignmentWhereUniqueInput
    /**
     * In case the featured_assignment found by the `where` argument doesn't exist, create a new featured_assignment with this data.
     */
    create: XOR<featured_assignmentCreateInput, featured_assignmentUncheckedCreateInput>
    /**
     * In case the featured_assignment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<featured_assignmentUpdateInput, featured_assignmentUncheckedUpdateInput>
  }

  /**
   * featured_assignment delete
   */
  export type featured_assignmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the featured_assignment
     */
    select?: featured_assignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the featured_assignment
     */
    omit?: featured_assignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: featured_assignmentInclude<ExtArgs> | null
    /**
     * Filter which featured_assignment to delete.
     */
    where: featured_assignmentWhereUniqueInput
  }

  /**
   * featured_assignment deleteMany
   */
  export type featured_assignmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which featured_assignments to delete
     */
    where?: featured_assignmentWhereInput
    /**
     * Limit how many featured_assignments to delete.
     */
    limit?: number
  }

  /**
   * featured_assignment findRaw
   */
  export type featured_assignmentFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * featured_assignment aggregateRaw
   */
  export type featured_assignmentAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * featured_assignment.media_ref
   */
  export type featured_assignment$media_refArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the media
     */
    select?: mediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the media
     */
    omit?: mediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mediaInclude<ExtArgs> | null
    where?: mediaWhereInput
  }

  /**
   * featured_assignment without action
   */
  export type featured_assignmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the featured_assignment
     */
    select?: featured_assignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the featured_assignment
     */
    omit?: featured_assignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: featured_assignmentInclude<ExtArgs> | null
  }


  /**
   * Model setting
   */

  export type AggregateSetting = {
    _count: SettingCountAggregateOutputType | null
    _avg: SettingAvgAggregateOutputType | null
    _sum: SettingSumAggregateOutputType | null
    _min: SettingMinAggregateOutputType | null
    _max: SettingMaxAggregateOutputType | null
  }

  export type SettingAvgAggregateOutputType = {
    version: number | null
  }

  export type SettingSumAggregateOutputType = {
    version: number | null
  }

  export type SettingMinAggregateOutputType = {
    id: string | null
    key: string | null
    status: $Enums.setting_status | null
    version: number | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type SettingMaxAggregateOutputType = {
    id: string | null
    key: string | null
    status: $Enums.setting_status | null
    version: number | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type SettingCountAggregateOutputType = {
    id: number
    key: number
    value_json: number
    status: number
    version: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type SettingAvgAggregateInputType = {
    version?: true
  }

  export type SettingSumAggregateInputType = {
    version?: true
  }

  export type SettingMinAggregateInputType = {
    id?: true
    key?: true
    status?: true
    version?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type SettingMaxAggregateInputType = {
    id?: true
    key?: true
    status?: true
    version?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type SettingCountAggregateInputType = {
    id?: true
    key?: true
    value_json?: true
    status?: true
    version?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type SettingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which setting to aggregate.
     */
    where?: settingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of settings to fetch.
     */
    orderBy?: settingOrderByWithRelationInput | settingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: settingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned settings
    **/
    _count?: true | SettingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SettingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SettingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SettingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SettingMaxAggregateInputType
  }

  export type GetSettingAggregateType<T extends SettingAggregateArgs> = {
        [P in keyof T & keyof AggregateSetting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSetting[P]>
      : GetScalarType<T[P], AggregateSetting[P]>
  }




  export type settingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: settingWhereInput
    orderBy?: settingOrderByWithAggregationInput | settingOrderByWithAggregationInput[]
    by: SettingScalarFieldEnum[] | SettingScalarFieldEnum
    having?: settingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SettingCountAggregateInputType | true
    _avg?: SettingAvgAggregateInputType
    _sum?: SettingSumAggregateInputType
    _min?: SettingMinAggregateInputType
    _max?: SettingMaxAggregateInputType
  }

  export type SettingGroupByOutputType = {
    id: string
    key: string
    value_json: JsonValue
    status: $Enums.setting_status
    version: number
    created_at: Date
    updated_at: Date
    deleted_at: Date | null
    _count: SettingCountAggregateOutputType | null
    _avg: SettingAvgAggregateOutputType | null
    _sum: SettingSumAggregateOutputType | null
    _min: SettingMinAggregateOutputType | null
    _max: SettingMaxAggregateOutputType | null
  }

  type GetSettingGroupByPayload<T extends settingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SettingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SettingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SettingGroupByOutputType[P]>
            : GetScalarType<T[P], SettingGroupByOutputType[P]>
        }
      >
    >


  export type settingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value_json?: boolean
    status?: boolean
    version?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }, ExtArgs["result"]["setting"]>



  export type settingSelectScalar = {
    id?: boolean
    key?: boolean
    value_json?: boolean
    status?: boolean
    version?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }

  export type settingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "key" | "value_json" | "status" | "version" | "created_at" | "updated_at" | "deleted_at", ExtArgs["result"]["setting"]>

  export type $settingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "setting"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      key: string
      value_json: Prisma.JsonValue
      status: $Enums.setting_status
      version: number
      created_at: Date
      updated_at: Date
      deleted_at: Date | null
    }, ExtArgs["result"]["setting"]>
    composites: {}
  }

  type settingGetPayload<S extends boolean | null | undefined | settingDefaultArgs> = $Result.GetResult<Prisma.$settingPayload, S>

  type settingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<settingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SettingCountAggregateInputType | true
    }

  export interface settingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['setting'], meta: { name: 'setting' } }
    /**
     * Find zero or one Setting that matches the filter.
     * @param {settingFindUniqueArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends settingFindUniqueArgs>(args: SelectSubset<T, settingFindUniqueArgs<ExtArgs>>): Prisma__settingClient<$Result.GetResult<Prisma.$settingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Setting that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {settingFindUniqueOrThrowArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends settingFindUniqueOrThrowArgs>(args: SelectSubset<T, settingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__settingClient<$Result.GetResult<Prisma.$settingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Setting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {settingFindFirstArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends settingFindFirstArgs>(args?: SelectSubset<T, settingFindFirstArgs<ExtArgs>>): Prisma__settingClient<$Result.GetResult<Prisma.$settingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Setting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {settingFindFirstOrThrowArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends settingFindFirstOrThrowArgs>(args?: SelectSubset<T, settingFindFirstOrThrowArgs<ExtArgs>>): Prisma__settingClient<$Result.GetResult<Prisma.$settingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {settingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Settings
     * const settings = await prisma.setting.findMany()
     * 
     * // Get first 10 Settings
     * const settings = await prisma.setting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const settingWithIdOnly = await prisma.setting.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends settingFindManyArgs>(args?: SelectSubset<T, settingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$settingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Setting.
     * @param {settingCreateArgs} args - Arguments to create a Setting.
     * @example
     * // Create one Setting
     * const Setting = await prisma.setting.create({
     *   data: {
     *     // ... data to create a Setting
     *   }
     * })
     * 
     */
    create<T extends settingCreateArgs>(args: SelectSubset<T, settingCreateArgs<ExtArgs>>): Prisma__settingClient<$Result.GetResult<Prisma.$settingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Settings.
     * @param {settingCreateManyArgs} args - Arguments to create many Settings.
     * @example
     * // Create many Settings
     * const setting = await prisma.setting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends settingCreateManyArgs>(args?: SelectSubset<T, settingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Setting.
     * @param {settingDeleteArgs} args - Arguments to delete one Setting.
     * @example
     * // Delete one Setting
     * const Setting = await prisma.setting.delete({
     *   where: {
     *     // ... filter to delete one Setting
     *   }
     * })
     * 
     */
    delete<T extends settingDeleteArgs>(args: SelectSubset<T, settingDeleteArgs<ExtArgs>>): Prisma__settingClient<$Result.GetResult<Prisma.$settingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Setting.
     * @param {settingUpdateArgs} args - Arguments to update one Setting.
     * @example
     * // Update one Setting
     * const setting = await prisma.setting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends settingUpdateArgs>(args: SelectSubset<T, settingUpdateArgs<ExtArgs>>): Prisma__settingClient<$Result.GetResult<Prisma.$settingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Settings.
     * @param {settingDeleteManyArgs} args - Arguments to filter Settings to delete.
     * @example
     * // Delete a few Settings
     * const { count } = await prisma.setting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends settingDeleteManyArgs>(args?: SelectSubset<T, settingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {settingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Settings
     * const setting = await prisma.setting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends settingUpdateManyArgs>(args: SelectSubset<T, settingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Setting.
     * @param {settingUpsertArgs} args - Arguments to update or create a Setting.
     * @example
     * // Update or create a Setting
     * const setting = await prisma.setting.upsert({
     *   create: {
     *     // ... data to create a Setting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Setting we want to update
     *   }
     * })
     */
    upsert<T extends settingUpsertArgs>(args: SelectSubset<T, settingUpsertArgs<ExtArgs>>): Prisma__settingClient<$Result.GetResult<Prisma.$settingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Settings that matches the filter.
     * @param {settingFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const setting = await prisma.setting.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: settingFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Setting.
     * @param {settingAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const setting = await prisma.setting.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: settingAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {settingCountArgs} args - Arguments to filter Settings to count.
     * @example
     * // Count the number of Settings
     * const count = await prisma.setting.count({
     *   where: {
     *     // ... the filter for the Settings we want to count
     *   }
     * })
    **/
    count<T extends settingCountArgs>(
      args?: Subset<T, settingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SettingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Setting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SettingAggregateArgs>(args: Subset<T, SettingAggregateArgs>): Prisma.PrismaPromise<GetSettingAggregateType<T>>

    /**
     * Group by Setting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {settingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends settingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: settingGroupByArgs['orderBy'] }
        : { orderBy?: settingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, settingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSettingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the setting model
   */
  readonly fields: settingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for setting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__settingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the setting model
   */
  interface settingFieldRefs {
    readonly id: FieldRef<"setting", 'String'>
    readonly key: FieldRef<"setting", 'String'>
    readonly value_json: FieldRef<"setting", 'Json'>
    readonly status: FieldRef<"setting", 'setting_status'>
    readonly version: FieldRef<"setting", 'Int'>
    readonly created_at: FieldRef<"setting", 'DateTime'>
    readonly updated_at: FieldRef<"setting", 'DateTime'>
    readonly deleted_at: FieldRef<"setting", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * setting findUnique
   */
  export type settingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the setting
     */
    select?: settingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the setting
     */
    omit?: settingOmit<ExtArgs> | null
    /**
     * Filter, which setting to fetch.
     */
    where: settingWhereUniqueInput
  }

  /**
   * setting findUniqueOrThrow
   */
  export type settingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the setting
     */
    select?: settingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the setting
     */
    omit?: settingOmit<ExtArgs> | null
    /**
     * Filter, which setting to fetch.
     */
    where: settingWhereUniqueInput
  }

  /**
   * setting findFirst
   */
  export type settingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the setting
     */
    select?: settingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the setting
     */
    omit?: settingOmit<ExtArgs> | null
    /**
     * Filter, which setting to fetch.
     */
    where?: settingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of settings to fetch.
     */
    orderBy?: settingOrderByWithRelationInput | settingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for settings.
     */
    cursor?: settingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of settings.
     */
    distinct?: SettingScalarFieldEnum | SettingScalarFieldEnum[]
  }

  /**
   * setting findFirstOrThrow
   */
  export type settingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the setting
     */
    select?: settingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the setting
     */
    omit?: settingOmit<ExtArgs> | null
    /**
     * Filter, which setting to fetch.
     */
    where?: settingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of settings to fetch.
     */
    orderBy?: settingOrderByWithRelationInput | settingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for settings.
     */
    cursor?: settingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of settings.
     */
    distinct?: SettingScalarFieldEnum | SettingScalarFieldEnum[]
  }

  /**
   * setting findMany
   */
  export type settingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the setting
     */
    select?: settingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the setting
     */
    omit?: settingOmit<ExtArgs> | null
    /**
     * Filter, which settings to fetch.
     */
    where?: settingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of settings to fetch.
     */
    orderBy?: settingOrderByWithRelationInput | settingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing settings.
     */
    cursor?: settingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` settings.
     */
    skip?: number
    distinct?: SettingScalarFieldEnum | SettingScalarFieldEnum[]
  }

  /**
   * setting create
   */
  export type settingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the setting
     */
    select?: settingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the setting
     */
    omit?: settingOmit<ExtArgs> | null
    /**
     * The data needed to create a setting.
     */
    data: XOR<settingCreateInput, settingUncheckedCreateInput>
  }

  /**
   * setting createMany
   */
  export type settingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many settings.
     */
    data: settingCreateManyInput | settingCreateManyInput[]
  }

  /**
   * setting update
   */
  export type settingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the setting
     */
    select?: settingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the setting
     */
    omit?: settingOmit<ExtArgs> | null
    /**
     * The data needed to update a setting.
     */
    data: XOR<settingUpdateInput, settingUncheckedUpdateInput>
    /**
     * Choose, which setting to update.
     */
    where: settingWhereUniqueInput
  }

  /**
   * setting updateMany
   */
  export type settingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update settings.
     */
    data: XOR<settingUpdateManyMutationInput, settingUncheckedUpdateManyInput>
    /**
     * Filter which settings to update
     */
    where?: settingWhereInput
    /**
     * Limit how many settings to update.
     */
    limit?: number
  }

  /**
   * setting upsert
   */
  export type settingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the setting
     */
    select?: settingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the setting
     */
    omit?: settingOmit<ExtArgs> | null
    /**
     * The filter to search for the setting to update in case it exists.
     */
    where: settingWhereUniqueInput
    /**
     * In case the setting found by the `where` argument doesn't exist, create a new setting with this data.
     */
    create: XOR<settingCreateInput, settingUncheckedCreateInput>
    /**
     * In case the setting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<settingUpdateInput, settingUncheckedUpdateInput>
  }

  /**
   * setting delete
   */
  export type settingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the setting
     */
    select?: settingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the setting
     */
    omit?: settingOmit<ExtArgs> | null
    /**
     * Filter which setting to delete.
     */
    where: settingWhereUniqueInput
  }

  /**
   * setting deleteMany
   */
  export type settingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which settings to delete
     */
    where?: settingWhereInput
    /**
     * Limit how many settings to delete.
     */
    limit?: number
  }

  /**
   * setting findRaw
   */
  export type settingFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * setting aggregateRaw
   */
  export type settingAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * setting without action
   */
  export type settingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the setting
     */
    select?: settingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the setting
     */
    omit?: settingOmit<ExtArgs> | null
  }


  /**
   * Model support_ticket
   */

  export type AggregateSupport_ticket = {
    _count: Support_ticketCountAggregateOutputType | null
    _min: Support_ticketMinAggregateOutputType | null
    _max: Support_ticketMaxAggregateOutputType | null
  }

  export type Support_ticketMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    email: string | null
    subject: string | null
    message: string | null
    priority: $Enums.ticket_priority | null
    status: $Enums.ticket_status | null
    assigned_to: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type Support_ticketMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    email: string | null
    subject: string | null
    message: string | null
    priority: $Enums.ticket_priority | null
    status: $Enums.ticket_status | null
    assigned_to: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type Support_ticketCountAggregateOutputType = {
    id: number
    user_id: number
    email: number
    subject: number
    message: number
    priority: number
    status: number
    assigned_to: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type Support_ticketMinAggregateInputType = {
    id?: true
    user_id?: true
    email?: true
    subject?: true
    message?: true
    priority?: true
    status?: true
    assigned_to?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type Support_ticketMaxAggregateInputType = {
    id?: true
    user_id?: true
    email?: true
    subject?: true
    message?: true
    priority?: true
    status?: true
    assigned_to?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type Support_ticketCountAggregateInputType = {
    id?: true
    user_id?: true
    email?: true
    subject?: true
    message?: true
    priority?: true
    status?: true
    assigned_to?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type Support_ticketAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which support_ticket to aggregate.
     */
    where?: support_ticketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of support_tickets to fetch.
     */
    orderBy?: support_ticketOrderByWithRelationInput | support_ticketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: support_ticketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` support_tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` support_tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned support_tickets
    **/
    _count?: true | Support_ticketCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Support_ticketMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Support_ticketMaxAggregateInputType
  }

  export type GetSupport_ticketAggregateType<T extends Support_ticketAggregateArgs> = {
        [P in keyof T & keyof AggregateSupport_ticket]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupport_ticket[P]>
      : GetScalarType<T[P], AggregateSupport_ticket[P]>
  }




  export type support_ticketGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: support_ticketWhereInput
    orderBy?: support_ticketOrderByWithAggregationInput | support_ticketOrderByWithAggregationInput[]
    by: Support_ticketScalarFieldEnum[] | Support_ticketScalarFieldEnum
    having?: support_ticketScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Support_ticketCountAggregateInputType | true
    _min?: Support_ticketMinAggregateInputType
    _max?: Support_ticketMaxAggregateInputType
  }

  export type Support_ticketGroupByOutputType = {
    id: string
    user_id: string | null
    email: string | null
    subject: string
    message: string
    priority: $Enums.ticket_priority
    status: $Enums.ticket_status
    assigned_to: string | null
    created_at: Date
    updated_at: Date
    deleted_at: Date | null
    _count: Support_ticketCountAggregateOutputType | null
    _min: Support_ticketMinAggregateOutputType | null
    _max: Support_ticketMaxAggregateOutputType | null
  }

  type GetSupport_ticketGroupByPayload<T extends support_ticketGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Support_ticketGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Support_ticketGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Support_ticketGroupByOutputType[P]>
            : GetScalarType<T[P], Support_ticketGroupByOutputType[P]>
        }
      >
    >


  export type support_ticketSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    email?: boolean
    subject?: boolean
    message?: boolean
    priority?: boolean
    status?: boolean
    assigned_to?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    user?: boolean | support_ticket$userArgs<ExtArgs>
    assignee?: boolean | support_ticket$assigneeArgs<ExtArgs>
  }, ExtArgs["result"]["support_ticket"]>



  export type support_ticketSelectScalar = {
    id?: boolean
    user_id?: boolean
    email?: boolean
    subject?: boolean
    message?: boolean
    priority?: boolean
    status?: boolean
    assigned_to?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }

  export type support_ticketOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "email" | "subject" | "message" | "priority" | "status" | "assigned_to" | "created_at" | "updated_at" | "deleted_at", ExtArgs["result"]["support_ticket"]>
  export type support_ticketInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | support_ticket$userArgs<ExtArgs>
    assignee?: boolean | support_ticket$assigneeArgs<ExtArgs>
  }

  export type $support_ticketPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "support_ticket"
    objects: {
      user: Prisma.$userPayload<ExtArgs> | null
      assignee: Prisma.$userPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string | null
      email: string | null
      subject: string
      message: string
      priority: $Enums.ticket_priority
      status: $Enums.ticket_status
      assigned_to: string | null
      created_at: Date
      updated_at: Date
      deleted_at: Date | null
    }, ExtArgs["result"]["support_ticket"]>
    composites: {}
  }

  type support_ticketGetPayload<S extends boolean | null | undefined | support_ticketDefaultArgs> = $Result.GetResult<Prisma.$support_ticketPayload, S>

  type support_ticketCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<support_ticketFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Support_ticketCountAggregateInputType | true
    }

  export interface support_ticketDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['support_ticket'], meta: { name: 'support_ticket' } }
    /**
     * Find zero or one Support_ticket that matches the filter.
     * @param {support_ticketFindUniqueArgs} args - Arguments to find a Support_ticket
     * @example
     * // Get one Support_ticket
     * const support_ticket = await prisma.support_ticket.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends support_ticketFindUniqueArgs>(args: SelectSubset<T, support_ticketFindUniqueArgs<ExtArgs>>): Prisma__support_ticketClient<$Result.GetResult<Prisma.$support_ticketPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Support_ticket that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {support_ticketFindUniqueOrThrowArgs} args - Arguments to find a Support_ticket
     * @example
     * // Get one Support_ticket
     * const support_ticket = await prisma.support_ticket.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends support_ticketFindUniqueOrThrowArgs>(args: SelectSubset<T, support_ticketFindUniqueOrThrowArgs<ExtArgs>>): Prisma__support_ticketClient<$Result.GetResult<Prisma.$support_ticketPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Support_ticket that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {support_ticketFindFirstArgs} args - Arguments to find a Support_ticket
     * @example
     * // Get one Support_ticket
     * const support_ticket = await prisma.support_ticket.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends support_ticketFindFirstArgs>(args?: SelectSubset<T, support_ticketFindFirstArgs<ExtArgs>>): Prisma__support_ticketClient<$Result.GetResult<Prisma.$support_ticketPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Support_ticket that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {support_ticketFindFirstOrThrowArgs} args - Arguments to find a Support_ticket
     * @example
     * // Get one Support_ticket
     * const support_ticket = await prisma.support_ticket.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends support_ticketFindFirstOrThrowArgs>(args?: SelectSubset<T, support_ticketFindFirstOrThrowArgs<ExtArgs>>): Prisma__support_ticketClient<$Result.GetResult<Prisma.$support_ticketPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Support_tickets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {support_ticketFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Support_tickets
     * const support_tickets = await prisma.support_ticket.findMany()
     * 
     * // Get first 10 Support_tickets
     * const support_tickets = await prisma.support_ticket.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const support_ticketWithIdOnly = await prisma.support_ticket.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends support_ticketFindManyArgs>(args?: SelectSubset<T, support_ticketFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$support_ticketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Support_ticket.
     * @param {support_ticketCreateArgs} args - Arguments to create a Support_ticket.
     * @example
     * // Create one Support_ticket
     * const Support_ticket = await prisma.support_ticket.create({
     *   data: {
     *     // ... data to create a Support_ticket
     *   }
     * })
     * 
     */
    create<T extends support_ticketCreateArgs>(args: SelectSubset<T, support_ticketCreateArgs<ExtArgs>>): Prisma__support_ticketClient<$Result.GetResult<Prisma.$support_ticketPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Support_tickets.
     * @param {support_ticketCreateManyArgs} args - Arguments to create many Support_tickets.
     * @example
     * // Create many Support_tickets
     * const support_ticket = await prisma.support_ticket.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends support_ticketCreateManyArgs>(args?: SelectSubset<T, support_ticketCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Support_ticket.
     * @param {support_ticketDeleteArgs} args - Arguments to delete one Support_ticket.
     * @example
     * // Delete one Support_ticket
     * const Support_ticket = await prisma.support_ticket.delete({
     *   where: {
     *     // ... filter to delete one Support_ticket
     *   }
     * })
     * 
     */
    delete<T extends support_ticketDeleteArgs>(args: SelectSubset<T, support_ticketDeleteArgs<ExtArgs>>): Prisma__support_ticketClient<$Result.GetResult<Prisma.$support_ticketPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Support_ticket.
     * @param {support_ticketUpdateArgs} args - Arguments to update one Support_ticket.
     * @example
     * // Update one Support_ticket
     * const support_ticket = await prisma.support_ticket.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends support_ticketUpdateArgs>(args: SelectSubset<T, support_ticketUpdateArgs<ExtArgs>>): Prisma__support_ticketClient<$Result.GetResult<Prisma.$support_ticketPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Support_tickets.
     * @param {support_ticketDeleteManyArgs} args - Arguments to filter Support_tickets to delete.
     * @example
     * // Delete a few Support_tickets
     * const { count } = await prisma.support_ticket.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends support_ticketDeleteManyArgs>(args?: SelectSubset<T, support_ticketDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Support_tickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {support_ticketUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Support_tickets
     * const support_ticket = await prisma.support_ticket.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends support_ticketUpdateManyArgs>(args: SelectSubset<T, support_ticketUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Support_ticket.
     * @param {support_ticketUpsertArgs} args - Arguments to update or create a Support_ticket.
     * @example
     * // Update or create a Support_ticket
     * const support_ticket = await prisma.support_ticket.upsert({
     *   create: {
     *     // ... data to create a Support_ticket
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Support_ticket we want to update
     *   }
     * })
     */
    upsert<T extends support_ticketUpsertArgs>(args: SelectSubset<T, support_ticketUpsertArgs<ExtArgs>>): Prisma__support_ticketClient<$Result.GetResult<Prisma.$support_ticketPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Support_tickets that matches the filter.
     * @param {support_ticketFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const support_ticket = await prisma.support_ticket.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: support_ticketFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Support_ticket.
     * @param {support_ticketAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const support_ticket = await prisma.support_ticket.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: support_ticketAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Support_tickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {support_ticketCountArgs} args - Arguments to filter Support_tickets to count.
     * @example
     * // Count the number of Support_tickets
     * const count = await prisma.support_ticket.count({
     *   where: {
     *     // ... the filter for the Support_tickets we want to count
     *   }
     * })
    **/
    count<T extends support_ticketCountArgs>(
      args?: Subset<T, support_ticketCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Support_ticketCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Support_ticket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Support_ticketAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Support_ticketAggregateArgs>(args: Subset<T, Support_ticketAggregateArgs>): Prisma.PrismaPromise<GetSupport_ticketAggregateType<T>>

    /**
     * Group by Support_ticket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {support_ticketGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends support_ticketGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: support_ticketGroupByArgs['orderBy'] }
        : { orderBy?: support_ticketGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, support_ticketGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupport_ticketGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the support_ticket model
   */
  readonly fields: support_ticketFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for support_ticket.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__support_ticketClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends support_ticket$userArgs<ExtArgs> = {}>(args?: Subset<T, support_ticket$userArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    assignee<T extends support_ticket$assigneeArgs<ExtArgs> = {}>(args?: Subset<T, support_ticket$assigneeArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the support_ticket model
   */
  interface support_ticketFieldRefs {
    readonly id: FieldRef<"support_ticket", 'String'>
    readonly user_id: FieldRef<"support_ticket", 'String'>
    readonly email: FieldRef<"support_ticket", 'String'>
    readonly subject: FieldRef<"support_ticket", 'String'>
    readonly message: FieldRef<"support_ticket", 'String'>
    readonly priority: FieldRef<"support_ticket", 'ticket_priority'>
    readonly status: FieldRef<"support_ticket", 'ticket_status'>
    readonly assigned_to: FieldRef<"support_ticket", 'String'>
    readonly created_at: FieldRef<"support_ticket", 'DateTime'>
    readonly updated_at: FieldRef<"support_ticket", 'DateTime'>
    readonly deleted_at: FieldRef<"support_ticket", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * support_ticket findUnique
   */
  export type support_ticketFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_ticket
     */
    select?: support_ticketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_ticket
     */
    omit?: support_ticketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: support_ticketInclude<ExtArgs> | null
    /**
     * Filter, which support_ticket to fetch.
     */
    where: support_ticketWhereUniqueInput
  }

  /**
   * support_ticket findUniqueOrThrow
   */
  export type support_ticketFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_ticket
     */
    select?: support_ticketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_ticket
     */
    omit?: support_ticketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: support_ticketInclude<ExtArgs> | null
    /**
     * Filter, which support_ticket to fetch.
     */
    where: support_ticketWhereUniqueInput
  }

  /**
   * support_ticket findFirst
   */
  export type support_ticketFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_ticket
     */
    select?: support_ticketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_ticket
     */
    omit?: support_ticketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: support_ticketInclude<ExtArgs> | null
    /**
     * Filter, which support_ticket to fetch.
     */
    where?: support_ticketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of support_tickets to fetch.
     */
    orderBy?: support_ticketOrderByWithRelationInput | support_ticketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for support_tickets.
     */
    cursor?: support_ticketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` support_tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` support_tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of support_tickets.
     */
    distinct?: Support_ticketScalarFieldEnum | Support_ticketScalarFieldEnum[]
  }

  /**
   * support_ticket findFirstOrThrow
   */
  export type support_ticketFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_ticket
     */
    select?: support_ticketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_ticket
     */
    omit?: support_ticketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: support_ticketInclude<ExtArgs> | null
    /**
     * Filter, which support_ticket to fetch.
     */
    where?: support_ticketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of support_tickets to fetch.
     */
    orderBy?: support_ticketOrderByWithRelationInput | support_ticketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for support_tickets.
     */
    cursor?: support_ticketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` support_tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` support_tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of support_tickets.
     */
    distinct?: Support_ticketScalarFieldEnum | Support_ticketScalarFieldEnum[]
  }

  /**
   * support_ticket findMany
   */
  export type support_ticketFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_ticket
     */
    select?: support_ticketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_ticket
     */
    omit?: support_ticketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: support_ticketInclude<ExtArgs> | null
    /**
     * Filter, which support_tickets to fetch.
     */
    where?: support_ticketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of support_tickets to fetch.
     */
    orderBy?: support_ticketOrderByWithRelationInput | support_ticketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing support_tickets.
     */
    cursor?: support_ticketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` support_tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` support_tickets.
     */
    skip?: number
    distinct?: Support_ticketScalarFieldEnum | Support_ticketScalarFieldEnum[]
  }

  /**
   * support_ticket create
   */
  export type support_ticketCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_ticket
     */
    select?: support_ticketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_ticket
     */
    omit?: support_ticketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: support_ticketInclude<ExtArgs> | null
    /**
     * The data needed to create a support_ticket.
     */
    data: XOR<support_ticketCreateInput, support_ticketUncheckedCreateInput>
  }

  /**
   * support_ticket createMany
   */
  export type support_ticketCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many support_tickets.
     */
    data: support_ticketCreateManyInput | support_ticketCreateManyInput[]
  }

  /**
   * support_ticket update
   */
  export type support_ticketUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_ticket
     */
    select?: support_ticketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_ticket
     */
    omit?: support_ticketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: support_ticketInclude<ExtArgs> | null
    /**
     * The data needed to update a support_ticket.
     */
    data: XOR<support_ticketUpdateInput, support_ticketUncheckedUpdateInput>
    /**
     * Choose, which support_ticket to update.
     */
    where: support_ticketWhereUniqueInput
  }

  /**
   * support_ticket updateMany
   */
  export type support_ticketUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update support_tickets.
     */
    data: XOR<support_ticketUpdateManyMutationInput, support_ticketUncheckedUpdateManyInput>
    /**
     * Filter which support_tickets to update
     */
    where?: support_ticketWhereInput
    /**
     * Limit how many support_tickets to update.
     */
    limit?: number
  }

  /**
   * support_ticket upsert
   */
  export type support_ticketUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_ticket
     */
    select?: support_ticketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_ticket
     */
    omit?: support_ticketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: support_ticketInclude<ExtArgs> | null
    /**
     * The filter to search for the support_ticket to update in case it exists.
     */
    where: support_ticketWhereUniqueInput
    /**
     * In case the support_ticket found by the `where` argument doesn't exist, create a new support_ticket with this data.
     */
    create: XOR<support_ticketCreateInput, support_ticketUncheckedCreateInput>
    /**
     * In case the support_ticket was found with the provided `where` argument, update it with this data.
     */
    update: XOR<support_ticketUpdateInput, support_ticketUncheckedUpdateInput>
  }

  /**
   * support_ticket delete
   */
  export type support_ticketDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_ticket
     */
    select?: support_ticketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_ticket
     */
    omit?: support_ticketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: support_ticketInclude<ExtArgs> | null
    /**
     * Filter which support_ticket to delete.
     */
    where: support_ticketWhereUniqueInput
  }

  /**
   * support_ticket deleteMany
   */
  export type support_ticketDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which support_tickets to delete
     */
    where?: support_ticketWhereInput
    /**
     * Limit how many support_tickets to delete.
     */
    limit?: number
  }

  /**
   * support_ticket findRaw
   */
  export type support_ticketFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * support_ticket aggregateRaw
   */
  export type support_ticketAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * support_ticket.user
   */
  export type support_ticket$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
  }

  /**
   * support_ticket.assignee
   */
  export type support_ticket$assigneeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
  }

  /**
   * support_ticket without action
   */
  export type support_ticketDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_ticket
     */
    select?: support_ticketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_ticket
     */
    omit?: support_ticketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: support_ticketInclude<ExtArgs> | null
  }


  /**
   * Model contact_event
   */

  export type AggregateContact_event = {
    _count: Contact_eventCountAggregateOutputType | null
    _min: Contact_eventMinAggregateOutputType | null
    _max: Contact_eventMaxAggregateOutputType | null
  }

  export type Contact_eventMinAggregateOutputType = {
    id: string | null
    player_id: string | null
    channel: $Enums.contact_channel | null
    requester_ip: string | null
    user_agent: string | null
    referrer: string | null
    message: string | null
    status: $Enums.setting_status | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type Contact_eventMaxAggregateOutputType = {
    id: string | null
    player_id: string | null
    channel: $Enums.contact_channel | null
    requester_ip: string | null
    user_agent: string | null
    referrer: string | null
    message: string | null
    status: $Enums.setting_status | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type Contact_eventCountAggregateOutputType = {
    id: number
    player_id: number
    channel: number
    requester_ip: number
    user_agent: number
    referrer: number
    message: number
    status: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type Contact_eventMinAggregateInputType = {
    id?: true
    player_id?: true
    channel?: true
    requester_ip?: true
    user_agent?: true
    referrer?: true
    message?: true
    status?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type Contact_eventMaxAggregateInputType = {
    id?: true
    player_id?: true
    channel?: true
    requester_ip?: true
    user_agent?: true
    referrer?: true
    message?: true
    status?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type Contact_eventCountAggregateInputType = {
    id?: true
    player_id?: true
    channel?: true
    requester_ip?: true
    user_agent?: true
    referrer?: true
    message?: true
    status?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type Contact_eventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which contact_event to aggregate.
     */
    where?: contact_eventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contact_events to fetch.
     */
    orderBy?: contact_eventOrderByWithRelationInput | contact_eventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: contact_eventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contact_events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contact_events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned contact_events
    **/
    _count?: true | Contact_eventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Contact_eventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Contact_eventMaxAggregateInputType
  }

  export type GetContact_eventAggregateType<T extends Contact_eventAggregateArgs> = {
        [P in keyof T & keyof AggregateContact_event]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContact_event[P]>
      : GetScalarType<T[P], AggregateContact_event[P]>
  }




  export type contact_eventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: contact_eventWhereInput
    orderBy?: contact_eventOrderByWithAggregationInput | contact_eventOrderByWithAggregationInput[]
    by: Contact_eventScalarFieldEnum[] | Contact_eventScalarFieldEnum
    having?: contact_eventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Contact_eventCountAggregateInputType | true
    _min?: Contact_eventMinAggregateInputType
    _max?: Contact_eventMaxAggregateInputType
  }

  export type Contact_eventGroupByOutputType = {
    id: string
    player_id: string
    channel: $Enums.contact_channel
    requester_ip: string | null
    user_agent: string | null
    referrer: string | null
    message: string | null
    status: $Enums.setting_status
    created_at: Date
    updated_at: Date
    deleted_at: Date | null
    _count: Contact_eventCountAggregateOutputType | null
    _min: Contact_eventMinAggregateOutputType | null
    _max: Contact_eventMaxAggregateOutputType | null
  }

  type GetContact_eventGroupByPayload<T extends contact_eventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Contact_eventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Contact_eventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Contact_eventGroupByOutputType[P]>
            : GetScalarType<T[P], Contact_eventGroupByOutputType[P]>
        }
      >
    >


  export type contact_eventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    player_id?: boolean
    channel?: boolean
    requester_ip?: boolean
    user_agent?: boolean
    referrer?: boolean
    message?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    player?: boolean | profileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contact_event"]>



  export type contact_eventSelectScalar = {
    id?: boolean
    player_id?: boolean
    channel?: boolean
    requester_ip?: boolean
    user_agent?: boolean
    referrer?: boolean
    message?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }

  export type contact_eventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "player_id" | "channel" | "requester_ip" | "user_agent" | "referrer" | "message" | "status" | "created_at" | "updated_at" | "deleted_at", ExtArgs["result"]["contact_event"]>
  export type contact_eventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | profileDefaultArgs<ExtArgs>
  }

  export type $contact_eventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "contact_event"
    objects: {
      player: Prisma.$profilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      player_id: string
      channel: $Enums.contact_channel
      requester_ip: string | null
      user_agent: string | null
      referrer: string | null
      message: string | null
      status: $Enums.setting_status
      created_at: Date
      updated_at: Date
      deleted_at: Date | null
    }, ExtArgs["result"]["contact_event"]>
    composites: {}
  }

  type contact_eventGetPayload<S extends boolean | null | undefined | contact_eventDefaultArgs> = $Result.GetResult<Prisma.$contact_eventPayload, S>

  type contact_eventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<contact_eventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Contact_eventCountAggregateInputType | true
    }

  export interface contact_eventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['contact_event'], meta: { name: 'contact_event' } }
    /**
     * Find zero or one Contact_event that matches the filter.
     * @param {contact_eventFindUniqueArgs} args - Arguments to find a Contact_event
     * @example
     * // Get one Contact_event
     * const contact_event = await prisma.contact_event.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends contact_eventFindUniqueArgs>(args: SelectSubset<T, contact_eventFindUniqueArgs<ExtArgs>>): Prisma__contact_eventClient<$Result.GetResult<Prisma.$contact_eventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Contact_event that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {contact_eventFindUniqueOrThrowArgs} args - Arguments to find a Contact_event
     * @example
     * // Get one Contact_event
     * const contact_event = await prisma.contact_event.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends contact_eventFindUniqueOrThrowArgs>(args: SelectSubset<T, contact_eventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__contact_eventClient<$Result.GetResult<Prisma.$contact_eventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contact_event that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contact_eventFindFirstArgs} args - Arguments to find a Contact_event
     * @example
     * // Get one Contact_event
     * const contact_event = await prisma.contact_event.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends contact_eventFindFirstArgs>(args?: SelectSubset<T, contact_eventFindFirstArgs<ExtArgs>>): Prisma__contact_eventClient<$Result.GetResult<Prisma.$contact_eventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contact_event that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contact_eventFindFirstOrThrowArgs} args - Arguments to find a Contact_event
     * @example
     * // Get one Contact_event
     * const contact_event = await prisma.contact_event.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends contact_eventFindFirstOrThrowArgs>(args?: SelectSubset<T, contact_eventFindFirstOrThrowArgs<ExtArgs>>): Prisma__contact_eventClient<$Result.GetResult<Prisma.$contact_eventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Contact_events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contact_eventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contact_events
     * const contact_events = await prisma.contact_event.findMany()
     * 
     * // Get first 10 Contact_events
     * const contact_events = await prisma.contact_event.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contact_eventWithIdOnly = await prisma.contact_event.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends contact_eventFindManyArgs>(args?: SelectSubset<T, contact_eventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$contact_eventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Contact_event.
     * @param {contact_eventCreateArgs} args - Arguments to create a Contact_event.
     * @example
     * // Create one Contact_event
     * const Contact_event = await prisma.contact_event.create({
     *   data: {
     *     // ... data to create a Contact_event
     *   }
     * })
     * 
     */
    create<T extends contact_eventCreateArgs>(args: SelectSubset<T, contact_eventCreateArgs<ExtArgs>>): Prisma__contact_eventClient<$Result.GetResult<Prisma.$contact_eventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Contact_events.
     * @param {contact_eventCreateManyArgs} args - Arguments to create many Contact_events.
     * @example
     * // Create many Contact_events
     * const contact_event = await prisma.contact_event.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends contact_eventCreateManyArgs>(args?: SelectSubset<T, contact_eventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Contact_event.
     * @param {contact_eventDeleteArgs} args - Arguments to delete one Contact_event.
     * @example
     * // Delete one Contact_event
     * const Contact_event = await prisma.contact_event.delete({
     *   where: {
     *     // ... filter to delete one Contact_event
     *   }
     * })
     * 
     */
    delete<T extends contact_eventDeleteArgs>(args: SelectSubset<T, contact_eventDeleteArgs<ExtArgs>>): Prisma__contact_eventClient<$Result.GetResult<Prisma.$contact_eventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Contact_event.
     * @param {contact_eventUpdateArgs} args - Arguments to update one Contact_event.
     * @example
     * // Update one Contact_event
     * const contact_event = await prisma.contact_event.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends contact_eventUpdateArgs>(args: SelectSubset<T, contact_eventUpdateArgs<ExtArgs>>): Prisma__contact_eventClient<$Result.GetResult<Prisma.$contact_eventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Contact_events.
     * @param {contact_eventDeleteManyArgs} args - Arguments to filter Contact_events to delete.
     * @example
     * // Delete a few Contact_events
     * const { count } = await prisma.contact_event.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends contact_eventDeleteManyArgs>(args?: SelectSubset<T, contact_eventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contact_events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contact_eventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contact_events
     * const contact_event = await prisma.contact_event.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends contact_eventUpdateManyArgs>(args: SelectSubset<T, contact_eventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Contact_event.
     * @param {contact_eventUpsertArgs} args - Arguments to update or create a Contact_event.
     * @example
     * // Update or create a Contact_event
     * const contact_event = await prisma.contact_event.upsert({
     *   create: {
     *     // ... data to create a Contact_event
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contact_event we want to update
     *   }
     * })
     */
    upsert<T extends contact_eventUpsertArgs>(args: SelectSubset<T, contact_eventUpsertArgs<ExtArgs>>): Prisma__contact_eventClient<$Result.GetResult<Prisma.$contact_eventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Contact_events that matches the filter.
     * @param {contact_eventFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const contact_event = await prisma.contact_event.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: contact_eventFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Contact_event.
     * @param {contact_eventAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const contact_event = await prisma.contact_event.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: contact_eventAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Contact_events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contact_eventCountArgs} args - Arguments to filter Contact_events to count.
     * @example
     * // Count the number of Contact_events
     * const count = await prisma.contact_event.count({
     *   where: {
     *     // ... the filter for the Contact_events we want to count
     *   }
     * })
    **/
    count<T extends contact_eventCountArgs>(
      args?: Subset<T, contact_eventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Contact_eventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contact_event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Contact_eventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Contact_eventAggregateArgs>(args: Subset<T, Contact_eventAggregateArgs>): Prisma.PrismaPromise<GetContact_eventAggregateType<T>>

    /**
     * Group by Contact_event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contact_eventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends contact_eventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: contact_eventGroupByArgs['orderBy'] }
        : { orderBy?: contact_eventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, contact_eventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContact_eventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the contact_event model
   */
  readonly fields: contact_eventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for contact_event.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__contact_eventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    player<T extends profileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, profileDefaultArgs<ExtArgs>>): Prisma__profileClient<$Result.GetResult<Prisma.$profilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the contact_event model
   */
  interface contact_eventFieldRefs {
    readonly id: FieldRef<"contact_event", 'String'>
    readonly player_id: FieldRef<"contact_event", 'String'>
    readonly channel: FieldRef<"contact_event", 'contact_channel'>
    readonly requester_ip: FieldRef<"contact_event", 'String'>
    readonly user_agent: FieldRef<"contact_event", 'String'>
    readonly referrer: FieldRef<"contact_event", 'String'>
    readonly message: FieldRef<"contact_event", 'String'>
    readonly status: FieldRef<"contact_event", 'setting_status'>
    readonly created_at: FieldRef<"contact_event", 'DateTime'>
    readonly updated_at: FieldRef<"contact_event", 'DateTime'>
    readonly deleted_at: FieldRef<"contact_event", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * contact_event findUnique
   */
  export type contact_eventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contact_event
     */
    select?: contact_eventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contact_event
     */
    omit?: contact_eventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contact_eventInclude<ExtArgs> | null
    /**
     * Filter, which contact_event to fetch.
     */
    where: contact_eventWhereUniqueInput
  }

  /**
   * contact_event findUniqueOrThrow
   */
  export type contact_eventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contact_event
     */
    select?: contact_eventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contact_event
     */
    omit?: contact_eventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contact_eventInclude<ExtArgs> | null
    /**
     * Filter, which contact_event to fetch.
     */
    where: contact_eventWhereUniqueInput
  }

  /**
   * contact_event findFirst
   */
  export type contact_eventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contact_event
     */
    select?: contact_eventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contact_event
     */
    omit?: contact_eventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contact_eventInclude<ExtArgs> | null
    /**
     * Filter, which contact_event to fetch.
     */
    where?: contact_eventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contact_events to fetch.
     */
    orderBy?: contact_eventOrderByWithRelationInput | contact_eventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for contact_events.
     */
    cursor?: contact_eventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contact_events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contact_events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of contact_events.
     */
    distinct?: Contact_eventScalarFieldEnum | Contact_eventScalarFieldEnum[]
  }

  /**
   * contact_event findFirstOrThrow
   */
  export type contact_eventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contact_event
     */
    select?: contact_eventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contact_event
     */
    omit?: contact_eventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contact_eventInclude<ExtArgs> | null
    /**
     * Filter, which contact_event to fetch.
     */
    where?: contact_eventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contact_events to fetch.
     */
    orderBy?: contact_eventOrderByWithRelationInput | contact_eventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for contact_events.
     */
    cursor?: contact_eventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contact_events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contact_events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of contact_events.
     */
    distinct?: Contact_eventScalarFieldEnum | Contact_eventScalarFieldEnum[]
  }

  /**
   * contact_event findMany
   */
  export type contact_eventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contact_event
     */
    select?: contact_eventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contact_event
     */
    omit?: contact_eventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contact_eventInclude<ExtArgs> | null
    /**
     * Filter, which contact_events to fetch.
     */
    where?: contact_eventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contact_events to fetch.
     */
    orderBy?: contact_eventOrderByWithRelationInput | contact_eventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing contact_events.
     */
    cursor?: contact_eventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contact_events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contact_events.
     */
    skip?: number
    distinct?: Contact_eventScalarFieldEnum | Contact_eventScalarFieldEnum[]
  }

  /**
   * contact_event create
   */
  export type contact_eventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contact_event
     */
    select?: contact_eventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contact_event
     */
    omit?: contact_eventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contact_eventInclude<ExtArgs> | null
    /**
     * The data needed to create a contact_event.
     */
    data: XOR<contact_eventCreateInput, contact_eventUncheckedCreateInput>
  }

  /**
   * contact_event createMany
   */
  export type contact_eventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many contact_events.
     */
    data: contact_eventCreateManyInput | contact_eventCreateManyInput[]
  }

  /**
   * contact_event update
   */
  export type contact_eventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contact_event
     */
    select?: contact_eventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contact_event
     */
    omit?: contact_eventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contact_eventInclude<ExtArgs> | null
    /**
     * The data needed to update a contact_event.
     */
    data: XOR<contact_eventUpdateInput, contact_eventUncheckedUpdateInput>
    /**
     * Choose, which contact_event to update.
     */
    where: contact_eventWhereUniqueInput
  }

  /**
   * contact_event updateMany
   */
  export type contact_eventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update contact_events.
     */
    data: XOR<contact_eventUpdateManyMutationInput, contact_eventUncheckedUpdateManyInput>
    /**
     * Filter which contact_events to update
     */
    where?: contact_eventWhereInput
    /**
     * Limit how many contact_events to update.
     */
    limit?: number
  }

  /**
   * contact_event upsert
   */
  export type contact_eventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contact_event
     */
    select?: contact_eventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contact_event
     */
    omit?: contact_eventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contact_eventInclude<ExtArgs> | null
    /**
     * The filter to search for the contact_event to update in case it exists.
     */
    where: contact_eventWhereUniqueInput
    /**
     * In case the contact_event found by the `where` argument doesn't exist, create a new contact_event with this data.
     */
    create: XOR<contact_eventCreateInput, contact_eventUncheckedCreateInput>
    /**
     * In case the contact_event was found with the provided `where` argument, update it with this data.
     */
    update: XOR<contact_eventUpdateInput, contact_eventUncheckedUpdateInput>
  }

  /**
   * contact_event delete
   */
  export type contact_eventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contact_event
     */
    select?: contact_eventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contact_event
     */
    omit?: contact_eventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contact_eventInclude<ExtArgs> | null
    /**
     * Filter which contact_event to delete.
     */
    where: contact_eventWhereUniqueInput
  }

  /**
   * contact_event deleteMany
   */
  export type contact_eventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which contact_events to delete
     */
    where?: contact_eventWhereInput
    /**
     * Limit how many contact_events to delete.
     */
    limit?: number
  }

  /**
   * contact_event findRaw
   */
  export type contact_eventFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * contact_event aggregateRaw
   */
  export type contact_eventAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * contact_event without action
   */
  export type contact_eventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contact_event
     */
    select?: contact_eventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contact_event
     */
    omit?: contact_eventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contact_eventInclude<ExtArgs> | null
  }


  /**
   * Model audit_log
   */

  export type AggregateAudit_log = {
    _count: Audit_logCountAggregateOutputType | null
    _min: Audit_logMinAggregateOutputType | null
    _max: Audit_logMaxAggregateOutputType | null
  }

  export type Audit_logMinAggregateOutputType = {
    id: string | null
    actor_user_id: string | null
    actor_role: $Enums.user_role | null
    entity_type: string | null
    entity_id: string | null
    action: string | null
    status: $Enums.audit_status | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type Audit_logMaxAggregateOutputType = {
    id: string | null
    actor_user_id: string | null
    actor_role: $Enums.user_role | null
    entity_type: string | null
    entity_id: string | null
    action: string | null
    status: $Enums.audit_status | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type Audit_logCountAggregateOutputType = {
    id: number
    actor_user_id: number
    actor_role: number
    entity_type: number
    entity_id: number
    action: number
    payload: number
    status: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type Audit_logMinAggregateInputType = {
    id?: true
    actor_user_id?: true
    actor_role?: true
    entity_type?: true
    entity_id?: true
    action?: true
    status?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type Audit_logMaxAggregateInputType = {
    id?: true
    actor_user_id?: true
    actor_role?: true
    entity_type?: true
    entity_id?: true
    action?: true
    status?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type Audit_logCountAggregateInputType = {
    id?: true
    actor_user_id?: true
    actor_role?: true
    entity_type?: true
    entity_id?: true
    action?: true
    payload?: true
    status?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type Audit_logAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which audit_log to aggregate.
     */
    where?: audit_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of audit_logs to fetch.
     */
    orderBy?: audit_logOrderByWithRelationInput | audit_logOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: audit_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` audit_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` audit_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned audit_logs
    **/
    _count?: true | Audit_logCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Audit_logMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Audit_logMaxAggregateInputType
  }

  export type GetAudit_logAggregateType<T extends Audit_logAggregateArgs> = {
        [P in keyof T & keyof AggregateAudit_log]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAudit_log[P]>
      : GetScalarType<T[P], AggregateAudit_log[P]>
  }




  export type audit_logGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: audit_logWhereInput
    orderBy?: audit_logOrderByWithAggregationInput | audit_logOrderByWithAggregationInput[]
    by: Audit_logScalarFieldEnum[] | Audit_logScalarFieldEnum
    having?: audit_logScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Audit_logCountAggregateInputType | true
    _min?: Audit_logMinAggregateInputType
    _max?: Audit_logMaxAggregateInputType
  }

  export type Audit_logGroupByOutputType = {
    id: string
    actor_user_id: string | null
    actor_role: $Enums.user_role | null
    entity_type: string
    entity_id: string
    action: string
    payload: JsonValue | null
    status: $Enums.audit_status
    created_at: Date
    updated_at: Date
    deleted_at: Date | null
    _count: Audit_logCountAggregateOutputType | null
    _min: Audit_logMinAggregateOutputType | null
    _max: Audit_logMaxAggregateOutputType | null
  }

  type GetAudit_logGroupByPayload<T extends audit_logGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Audit_logGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Audit_logGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Audit_logGroupByOutputType[P]>
            : GetScalarType<T[P], Audit_logGroupByOutputType[P]>
        }
      >
    >


  export type audit_logSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    actor_user_id?: boolean
    actor_role?: boolean
    entity_type?: boolean
    entity_id?: boolean
    action?: boolean
    payload?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }, ExtArgs["result"]["audit_log"]>



  export type audit_logSelectScalar = {
    id?: boolean
    actor_user_id?: boolean
    actor_role?: boolean
    entity_type?: boolean
    entity_id?: boolean
    action?: boolean
    payload?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }

  export type audit_logOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "actor_user_id" | "actor_role" | "entity_type" | "entity_id" | "action" | "payload" | "status" | "created_at" | "updated_at" | "deleted_at", ExtArgs["result"]["audit_log"]>

  export type $audit_logPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "audit_log"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      actor_user_id: string | null
      actor_role: $Enums.user_role | null
      entity_type: string
      entity_id: string
      action: string
      payload: Prisma.JsonValue | null
      status: $Enums.audit_status
      created_at: Date
      updated_at: Date
      deleted_at: Date | null
    }, ExtArgs["result"]["audit_log"]>
    composites: {}
  }

  type audit_logGetPayload<S extends boolean | null | undefined | audit_logDefaultArgs> = $Result.GetResult<Prisma.$audit_logPayload, S>

  type audit_logCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<audit_logFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Audit_logCountAggregateInputType | true
    }

  export interface audit_logDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['audit_log'], meta: { name: 'audit_log' } }
    /**
     * Find zero or one Audit_log that matches the filter.
     * @param {audit_logFindUniqueArgs} args - Arguments to find a Audit_log
     * @example
     * // Get one Audit_log
     * const audit_log = await prisma.audit_log.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends audit_logFindUniqueArgs>(args: SelectSubset<T, audit_logFindUniqueArgs<ExtArgs>>): Prisma__audit_logClient<$Result.GetResult<Prisma.$audit_logPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Audit_log that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {audit_logFindUniqueOrThrowArgs} args - Arguments to find a Audit_log
     * @example
     * // Get one Audit_log
     * const audit_log = await prisma.audit_log.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends audit_logFindUniqueOrThrowArgs>(args: SelectSubset<T, audit_logFindUniqueOrThrowArgs<ExtArgs>>): Prisma__audit_logClient<$Result.GetResult<Prisma.$audit_logPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Audit_log that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {audit_logFindFirstArgs} args - Arguments to find a Audit_log
     * @example
     * // Get one Audit_log
     * const audit_log = await prisma.audit_log.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends audit_logFindFirstArgs>(args?: SelectSubset<T, audit_logFindFirstArgs<ExtArgs>>): Prisma__audit_logClient<$Result.GetResult<Prisma.$audit_logPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Audit_log that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {audit_logFindFirstOrThrowArgs} args - Arguments to find a Audit_log
     * @example
     * // Get one Audit_log
     * const audit_log = await prisma.audit_log.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends audit_logFindFirstOrThrowArgs>(args?: SelectSubset<T, audit_logFindFirstOrThrowArgs<ExtArgs>>): Prisma__audit_logClient<$Result.GetResult<Prisma.$audit_logPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Audit_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {audit_logFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Audit_logs
     * const audit_logs = await prisma.audit_log.findMany()
     * 
     * // Get first 10 Audit_logs
     * const audit_logs = await prisma.audit_log.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const audit_logWithIdOnly = await prisma.audit_log.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends audit_logFindManyArgs>(args?: SelectSubset<T, audit_logFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$audit_logPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Audit_log.
     * @param {audit_logCreateArgs} args - Arguments to create a Audit_log.
     * @example
     * // Create one Audit_log
     * const Audit_log = await prisma.audit_log.create({
     *   data: {
     *     // ... data to create a Audit_log
     *   }
     * })
     * 
     */
    create<T extends audit_logCreateArgs>(args: SelectSubset<T, audit_logCreateArgs<ExtArgs>>): Prisma__audit_logClient<$Result.GetResult<Prisma.$audit_logPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Audit_logs.
     * @param {audit_logCreateManyArgs} args - Arguments to create many Audit_logs.
     * @example
     * // Create many Audit_logs
     * const audit_log = await prisma.audit_log.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends audit_logCreateManyArgs>(args?: SelectSubset<T, audit_logCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Audit_log.
     * @param {audit_logDeleteArgs} args - Arguments to delete one Audit_log.
     * @example
     * // Delete one Audit_log
     * const Audit_log = await prisma.audit_log.delete({
     *   where: {
     *     // ... filter to delete one Audit_log
     *   }
     * })
     * 
     */
    delete<T extends audit_logDeleteArgs>(args: SelectSubset<T, audit_logDeleteArgs<ExtArgs>>): Prisma__audit_logClient<$Result.GetResult<Prisma.$audit_logPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Audit_log.
     * @param {audit_logUpdateArgs} args - Arguments to update one Audit_log.
     * @example
     * // Update one Audit_log
     * const audit_log = await prisma.audit_log.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends audit_logUpdateArgs>(args: SelectSubset<T, audit_logUpdateArgs<ExtArgs>>): Prisma__audit_logClient<$Result.GetResult<Prisma.$audit_logPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Audit_logs.
     * @param {audit_logDeleteManyArgs} args - Arguments to filter Audit_logs to delete.
     * @example
     * // Delete a few Audit_logs
     * const { count } = await prisma.audit_log.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends audit_logDeleteManyArgs>(args?: SelectSubset<T, audit_logDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Audit_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {audit_logUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Audit_logs
     * const audit_log = await prisma.audit_log.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends audit_logUpdateManyArgs>(args: SelectSubset<T, audit_logUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Audit_log.
     * @param {audit_logUpsertArgs} args - Arguments to update or create a Audit_log.
     * @example
     * // Update or create a Audit_log
     * const audit_log = await prisma.audit_log.upsert({
     *   create: {
     *     // ... data to create a Audit_log
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Audit_log we want to update
     *   }
     * })
     */
    upsert<T extends audit_logUpsertArgs>(args: SelectSubset<T, audit_logUpsertArgs<ExtArgs>>): Prisma__audit_logClient<$Result.GetResult<Prisma.$audit_logPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Audit_logs that matches the filter.
     * @param {audit_logFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const audit_log = await prisma.audit_log.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: audit_logFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Audit_log.
     * @param {audit_logAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const audit_log = await prisma.audit_log.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: audit_logAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Audit_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {audit_logCountArgs} args - Arguments to filter Audit_logs to count.
     * @example
     * // Count the number of Audit_logs
     * const count = await prisma.audit_log.count({
     *   where: {
     *     // ... the filter for the Audit_logs we want to count
     *   }
     * })
    **/
    count<T extends audit_logCountArgs>(
      args?: Subset<T, audit_logCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Audit_logCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Audit_log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Audit_logAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Audit_logAggregateArgs>(args: Subset<T, Audit_logAggregateArgs>): Prisma.PrismaPromise<GetAudit_logAggregateType<T>>

    /**
     * Group by Audit_log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {audit_logGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends audit_logGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: audit_logGroupByArgs['orderBy'] }
        : { orderBy?: audit_logGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, audit_logGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAudit_logGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the audit_log model
   */
  readonly fields: audit_logFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for audit_log.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__audit_logClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the audit_log model
   */
  interface audit_logFieldRefs {
    readonly id: FieldRef<"audit_log", 'String'>
    readonly actor_user_id: FieldRef<"audit_log", 'String'>
    readonly actor_role: FieldRef<"audit_log", 'user_role'>
    readonly entity_type: FieldRef<"audit_log", 'String'>
    readonly entity_id: FieldRef<"audit_log", 'String'>
    readonly action: FieldRef<"audit_log", 'String'>
    readonly payload: FieldRef<"audit_log", 'Json'>
    readonly status: FieldRef<"audit_log", 'audit_status'>
    readonly created_at: FieldRef<"audit_log", 'DateTime'>
    readonly updated_at: FieldRef<"audit_log", 'DateTime'>
    readonly deleted_at: FieldRef<"audit_log", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * audit_log findUnique
   */
  export type audit_logFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_log
     */
    select?: audit_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_log
     */
    omit?: audit_logOmit<ExtArgs> | null
    /**
     * Filter, which audit_log to fetch.
     */
    where: audit_logWhereUniqueInput
  }

  /**
   * audit_log findUniqueOrThrow
   */
  export type audit_logFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_log
     */
    select?: audit_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_log
     */
    omit?: audit_logOmit<ExtArgs> | null
    /**
     * Filter, which audit_log to fetch.
     */
    where: audit_logWhereUniqueInput
  }

  /**
   * audit_log findFirst
   */
  export type audit_logFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_log
     */
    select?: audit_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_log
     */
    omit?: audit_logOmit<ExtArgs> | null
    /**
     * Filter, which audit_log to fetch.
     */
    where?: audit_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of audit_logs to fetch.
     */
    orderBy?: audit_logOrderByWithRelationInput | audit_logOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for audit_logs.
     */
    cursor?: audit_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` audit_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` audit_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of audit_logs.
     */
    distinct?: Audit_logScalarFieldEnum | Audit_logScalarFieldEnum[]
  }

  /**
   * audit_log findFirstOrThrow
   */
  export type audit_logFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_log
     */
    select?: audit_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_log
     */
    omit?: audit_logOmit<ExtArgs> | null
    /**
     * Filter, which audit_log to fetch.
     */
    where?: audit_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of audit_logs to fetch.
     */
    orderBy?: audit_logOrderByWithRelationInput | audit_logOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for audit_logs.
     */
    cursor?: audit_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` audit_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` audit_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of audit_logs.
     */
    distinct?: Audit_logScalarFieldEnum | Audit_logScalarFieldEnum[]
  }

  /**
   * audit_log findMany
   */
  export type audit_logFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_log
     */
    select?: audit_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_log
     */
    omit?: audit_logOmit<ExtArgs> | null
    /**
     * Filter, which audit_logs to fetch.
     */
    where?: audit_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of audit_logs to fetch.
     */
    orderBy?: audit_logOrderByWithRelationInput | audit_logOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing audit_logs.
     */
    cursor?: audit_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` audit_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` audit_logs.
     */
    skip?: number
    distinct?: Audit_logScalarFieldEnum | Audit_logScalarFieldEnum[]
  }

  /**
   * audit_log create
   */
  export type audit_logCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_log
     */
    select?: audit_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_log
     */
    omit?: audit_logOmit<ExtArgs> | null
    /**
     * The data needed to create a audit_log.
     */
    data: XOR<audit_logCreateInput, audit_logUncheckedCreateInput>
  }

  /**
   * audit_log createMany
   */
  export type audit_logCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many audit_logs.
     */
    data: audit_logCreateManyInput | audit_logCreateManyInput[]
  }

  /**
   * audit_log update
   */
  export type audit_logUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_log
     */
    select?: audit_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_log
     */
    omit?: audit_logOmit<ExtArgs> | null
    /**
     * The data needed to update a audit_log.
     */
    data: XOR<audit_logUpdateInput, audit_logUncheckedUpdateInput>
    /**
     * Choose, which audit_log to update.
     */
    where: audit_logWhereUniqueInput
  }

  /**
   * audit_log updateMany
   */
  export type audit_logUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update audit_logs.
     */
    data: XOR<audit_logUpdateManyMutationInput, audit_logUncheckedUpdateManyInput>
    /**
     * Filter which audit_logs to update
     */
    where?: audit_logWhereInput
    /**
     * Limit how many audit_logs to update.
     */
    limit?: number
  }

  /**
   * audit_log upsert
   */
  export type audit_logUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_log
     */
    select?: audit_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_log
     */
    omit?: audit_logOmit<ExtArgs> | null
    /**
     * The filter to search for the audit_log to update in case it exists.
     */
    where: audit_logWhereUniqueInput
    /**
     * In case the audit_log found by the `where` argument doesn't exist, create a new audit_log with this data.
     */
    create: XOR<audit_logCreateInput, audit_logUncheckedCreateInput>
    /**
     * In case the audit_log was found with the provided `where` argument, update it with this data.
     */
    update: XOR<audit_logUpdateInput, audit_logUncheckedUpdateInput>
  }

  /**
   * audit_log delete
   */
  export type audit_logDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_log
     */
    select?: audit_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_log
     */
    omit?: audit_logOmit<ExtArgs> | null
    /**
     * Filter which audit_log to delete.
     */
    where: audit_logWhereUniqueInput
  }

  /**
   * audit_log deleteMany
   */
  export type audit_logDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which audit_logs to delete
     */
    where?: audit_logWhereInput
    /**
     * Limit how many audit_logs to delete.
     */
    limit?: number
  }

  /**
   * audit_log findRaw
   */
  export type audit_logFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * audit_log aggregateRaw
   */
  export type audit_logAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * audit_log without action
   */
  export type audit_logDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_log
     */
    select?: audit_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_log
     */
    omit?: audit_logOmit<ExtArgs> | null
  }


  /**
   * Model webhook_event
   */

  export type AggregateWebhook_event = {
    _count: Webhook_eventCountAggregateOutputType | null
    _avg: Webhook_eventAvgAggregateOutputType | null
    _sum: Webhook_eventSumAggregateOutputType | null
    _min: Webhook_eventMinAggregateOutputType | null
    _max: Webhook_eventMaxAggregateOutputType | null
  }

  export type Webhook_eventAvgAggregateOutputType = {
    retry_count: number | null
  }

  export type Webhook_eventSumAggregateOutputType = {
    retry_count: number | null
  }

  export type Webhook_eventMinAggregateOutputType = {
    id: string | null
    provider: $Enums.provider_kind | null
    event_type: string | null
    related_type: string | null
    related_id: string | null
    status: $Enums.webhook_status | null
    retry_count: number | null
    last_error: string | null
    next_retry_at: Date | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type Webhook_eventMaxAggregateOutputType = {
    id: string | null
    provider: $Enums.provider_kind | null
    event_type: string | null
    related_type: string | null
    related_id: string | null
    status: $Enums.webhook_status | null
    retry_count: number | null
    last_error: string | null
    next_retry_at: Date | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type Webhook_eventCountAggregateOutputType = {
    id: number
    provider: number
    event_type: number
    payload: number
    related_type: number
    related_id: number
    status: number
    retry_count: number
    last_error: number
    next_retry_at: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type Webhook_eventAvgAggregateInputType = {
    retry_count?: true
  }

  export type Webhook_eventSumAggregateInputType = {
    retry_count?: true
  }

  export type Webhook_eventMinAggregateInputType = {
    id?: true
    provider?: true
    event_type?: true
    related_type?: true
    related_id?: true
    status?: true
    retry_count?: true
    last_error?: true
    next_retry_at?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type Webhook_eventMaxAggregateInputType = {
    id?: true
    provider?: true
    event_type?: true
    related_type?: true
    related_id?: true
    status?: true
    retry_count?: true
    last_error?: true
    next_retry_at?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type Webhook_eventCountAggregateInputType = {
    id?: true
    provider?: true
    event_type?: true
    payload?: true
    related_type?: true
    related_id?: true
    status?: true
    retry_count?: true
    last_error?: true
    next_retry_at?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type Webhook_eventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which webhook_event to aggregate.
     */
    where?: webhook_eventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of webhook_events to fetch.
     */
    orderBy?: webhook_eventOrderByWithRelationInput | webhook_eventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: webhook_eventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` webhook_events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` webhook_events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned webhook_events
    **/
    _count?: true | Webhook_eventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Webhook_eventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Webhook_eventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Webhook_eventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Webhook_eventMaxAggregateInputType
  }

  export type GetWebhook_eventAggregateType<T extends Webhook_eventAggregateArgs> = {
        [P in keyof T & keyof AggregateWebhook_event]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWebhook_event[P]>
      : GetScalarType<T[P], AggregateWebhook_event[P]>
  }




  export type webhook_eventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: webhook_eventWhereInput
    orderBy?: webhook_eventOrderByWithAggregationInput | webhook_eventOrderByWithAggregationInput[]
    by: Webhook_eventScalarFieldEnum[] | Webhook_eventScalarFieldEnum
    having?: webhook_eventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Webhook_eventCountAggregateInputType | true
    _avg?: Webhook_eventAvgAggregateInputType
    _sum?: Webhook_eventSumAggregateInputType
    _min?: Webhook_eventMinAggregateInputType
    _max?: Webhook_eventMaxAggregateInputType
  }

  export type Webhook_eventGroupByOutputType = {
    id: string
    provider: $Enums.provider_kind
    event_type: string
    payload: JsonValue
    related_type: string | null
    related_id: string | null
    status: $Enums.webhook_status
    retry_count: number
    last_error: string | null
    next_retry_at: Date | null
    created_at: Date
    updated_at: Date
    deleted_at: Date | null
    _count: Webhook_eventCountAggregateOutputType | null
    _avg: Webhook_eventAvgAggregateOutputType | null
    _sum: Webhook_eventSumAggregateOutputType | null
    _min: Webhook_eventMinAggregateOutputType | null
    _max: Webhook_eventMaxAggregateOutputType | null
  }

  type GetWebhook_eventGroupByPayload<T extends webhook_eventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Webhook_eventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Webhook_eventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Webhook_eventGroupByOutputType[P]>
            : GetScalarType<T[P], Webhook_eventGroupByOutputType[P]>
        }
      >
    >


  export type webhook_eventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    provider?: boolean
    event_type?: boolean
    payload?: boolean
    related_type?: boolean
    related_id?: boolean
    status?: boolean
    retry_count?: boolean
    last_error?: boolean
    next_retry_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }, ExtArgs["result"]["webhook_event"]>



  export type webhook_eventSelectScalar = {
    id?: boolean
    provider?: boolean
    event_type?: boolean
    payload?: boolean
    related_type?: boolean
    related_id?: boolean
    status?: boolean
    retry_count?: boolean
    last_error?: boolean
    next_retry_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }

  export type webhook_eventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "provider" | "event_type" | "payload" | "related_type" | "related_id" | "status" | "retry_count" | "last_error" | "next_retry_at" | "created_at" | "updated_at" | "deleted_at", ExtArgs["result"]["webhook_event"]>

  export type $webhook_eventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "webhook_event"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      provider: $Enums.provider_kind
      event_type: string
      payload: Prisma.JsonValue
      related_type: string | null
      related_id: string | null
      status: $Enums.webhook_status
      retry_count: number
      last_error: string | null
      next_retry_at: Date | null
      created_at: Date
      updated_at: Date
      deleted_at: Date | null
    }, ExtArgs["result"]["webhook_event"]>
    composites: {}
  }

  type webhook_eventGetPayload<S extends boolean | null | undefined | webhook_eventDefaultArgs> = $Result.GetResult<Prisma.$webhook_eventPayload, S>

  type webhook_eventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<webhook_eventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Webhook_eventCountAggregateInputType | true
    }

  export interface webhook_eventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['webhook_event'], meta: { name: 'webhook_event' } }
    /**
     * Find zero or one Webhook_event that matches the filter.
     * @param {webhook_eventFindUniqueArgs} args - Arguments to find a Webhook_event
     * @example
     * // Get one Webhook_event
     * const webhook_event = await prisma.webhook_event.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends webhook_eventFindUniqueArgs>(args: SelectSubset<T, webhook_eventFindUniqueArgs<ExtArgs>>): Prisma__webhook_eventClient<$Result.GetResult<Prisma.$webhook_eventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Webhook_event that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {webhook_eventFindUniqueOrThrowArgs} args - Arguments to find a Webhook_event
     * @example
     * // Get one Webhook_event
     * const webhook_event = await prisma.webhook_event.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends webhook_eventFindUniqueOrThrowArgs>(args: SelectSubset<T, webhook_eventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__webhook_eventClient<$Result.GetResult<Prisma.$webhook_eventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Webhook_event that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {webhook_eventFindFirstArgs} args - Arguments to find a Webhook_event
     * @example
     * // Get one Webhook_event
     * const webhook_event = await prisma.webhook_event.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends webhook_eventFindFirstArgs>(args?: SelectSubset<T, webhook_eventFindFirstArgs<ExtArgs>>): Prisma__webhook_eventClient<$Result.GetResult<Prisma.$webhook_eventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Webhook_event that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {webhook_eventFindFirstOrThrowArgs} args - Arguments to find a Webhook_event
     * @example
     * // Get one Webhook_event
     * const webhook_event = await prisma.webhook_event.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends webhook_eventFindFirstOrThrowArgs>(args?: SelectSubset<T, webhook_eventFindFirstOrThrowArgs<ExtArgs>>): Prisma__webhook_eventClient<$Result.GetResult<Prisma.$webhook_eventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Webhook_events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {webhook_eventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Webhook_events
     * const webhook_events = await prisma.webhook_event.findMany()
     * 
     * // Get first 10 Webhook_events
     * const webhook_events = await prisma.webhook_event.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const webhook_eventWithIdOnly = await prisma.webhook_event.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends webhook_eventFindManyArgs>(args?: SelectSubset<T, webhook_eventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$webhook_eventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Webhook_event.
     * @param {webhook_eventCreateArgs} args - Arguments to create a Webhook_event.
     * @example
     * // Create one Webhook_event
     * const Webhook_event = await prisma.webhook_event.create({
     *   data: {
     *     // ... data to create a Webhook_event
     *   }
     * })
     * 
     */
    create<T extends webhook_eventCreateArgs>(args: SelectSubset<T, webhook_eventCreateArgs<ExtArgs>>): Prisma__webhook_eventClient<$Result.GetResult<Prisma.$webhook_eventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Webhook_events.
     * @param {webhook_eventCreateManyArgs} args - Arguments to create many Webhook_events.
     * @example
     * // Create many Webhook_events
     * const webhook_event = await prisma.webhook_event.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends webhook_eventCreateManyArgs>(args?: SelectSubset<T, webhook_eventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Webhook_event.
     * @param {webhook_eventDeleteArgs} args - Arguments to delete one Webhook_event.
     * @example
     * // Delete one Webhook_event
     * const Webhook_event = await prisma.webhook_event.delete({
     *   where: {
     *     // ... filter to delete one Webhook_event
     *   }
     * })
     * 
     */
    delete<T extends webhook_eventDeleteArgs>(args: SelectSubset<T, webhook_eventDeleteArgs<ExtArgs>>): Prisma__webhook_eventClient<$Result.GetResult<Prisma.$webhook_eventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Webhook_event.
     * @param {webhook_eventUpdateArgs} args - Arguments to update one Webhook_event.
     * @example
     * // Update one Webhook_event
     * const webhook_event = await prisma.webhook_event.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends webhook_eventUpdateArgs>(args: SelectSubset<T, webhook_eventUpdateArgs<ExtArgs>>): Prisma__webhook_eventClient<$Result.GetResult<Prisma.$webhook_eventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Webhook_events.
     * @param {webhook_eventDeleteManyArgs} args - Arguments to filter Webhook_events to delete.
     * @example
     * // Delete a few Webhook_events
     * const { count } = await prisma.webhook_event.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends webhook_eventDeleteManyArgs>(args?: SelectSubset<T, webhook_eventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Webhook_events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {webhook_eventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Webhook_events
     * const webhook_event = await prisma.webhook_event.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends webhook_eventUpdateManyArgs>(args: SelectSubset<T, webhook_eventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Webhook_event.
     * @param {webhook_eventUpsertArgs} args - Arguments to update or create a Webhook_event.
     * @example
     * // Update or create a Webhook_event
     * const webhook_event = await prisma.webhook_event.upsert({
     *   create: {
     *     // ... data to create a Webhook_event
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Webhook_event we want to update
     *   }
     * })
     */
    upsert<T extends webhook_eventUpsertArgs>(args: SelectSubset<T, webhook_eventUpsertArgs<ExtArgs>>): Prisma__webhook_eventClient<$Result.GetResult<Prisma.$webhook_eventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Webhook_events that matches the filter.
     * @param {webhook_eventFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const webhook_event = await prisma.webhook_event.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: webhook_eventFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Webhook_event.
     * @param {webhook_eventAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const webhook_event = await prisma.webhook_event.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: webhook_eventAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Webhook_events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {webhook_eventCountArgs} args - Arguments to filter Webhook_events to count.
     * @example
     * // Count the number of Webhook_events
     * const count = await prisma.webhook_event.count({
     *   where: {
     *     // ... the filter for the Webhook_events we want to count
     *   }
     * })
    **/
    count<T extends webhook_eventCountArgs>(
      args?: Subset<T, webhook_eventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Webhook_eventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Webhook_event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Webhook_eventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Webhook_eventAggregateArgs>(args: Subset<T, Webhook_eventAggregateArgs>): Prisma.PrismaPromise<GetWebhook_eventAggregateType<T>>

    /**
     * Group by Webhook_event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {webhook_eventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends webhook_eventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: webhook_eventGroupByArgs['orderBy'] }
        : { orderBy?: webhook_eventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, webhook_eventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWebhook_eventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the webhook_event model
   */
  readonly fields: webhook_eventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for webhook_event.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__webhook_eventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the webhook_event model
   */
  interface webhook_eventFieldRefs {
    readonly id: FieldRef<"webhook_event", 'String'>
    readonly provider: FieldRef<"webhook_event", 'provider_kind'>
    readonly event_type: FieldRef<"webhook_event", 'String'>
    readonly payload: FieldRef<"webhook_event", 'Json'>
    readonly related_type: FieldRef<"webhook_event", 'String'>
    readonly related_id: FieldRef<"webhook_event", 'String'>
    readonly status: FieldRef<"webhook_event", 'webhook_status'>
    readonly retry_count: FieldRef<"webhook_event", 'Int'>
    readonly last_error: FieldRef<"webhook_event", 'String'>
    readonly next_retry_at: FieldRef<"webhook_event", 'DateTime'>
    readonly created_at: FieldRef<"webhook_event", 'DateTime'>
    readonly updated_at: FieldRef<"webhook_event", 'DateTime'>
    readonly deleted_at: FieldRef<"webhook_event", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * webhook_event findUnique
   */
  export type webhook_eventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the webhook_event
     */
    select?: webhook_eventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the webhook_event
     */
    omit?: webhook_eventOmit<ExtArgs> | null
    /**
     * Filter, which webhook_event to fetch.
     */
    where: webhook_eventWhereUniqueInput
  }

  /**
   * webhook_event findUniqueOrThrow
   */
  export type webhook_eventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the webhook_event
     */
    select?: webhook_eventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the webhook_event
     */
    omit?: webhook_eventOmit<ExtArgs> | null
    /**
     * Filter, which webhook_event to fetch.
     */
    where: webhook_eventWhereUniqueInput
  }

  /**
   * webhook_event findFirst
   */
  export type webhook_eventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the webhook_event
     */
    select?: webhook_eventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the webhook_event
     */
    omit?: webhook_eventOmit<ExtArgs> | null
    /**
     * Filter, which webhook_event to fetch.
     */
    where?: webhook_eventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of webhook_events to fetch.
     */
    orderBy?: webhook_eventOrderByWithRelationInput | webhook_eventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for webhook_events.
     */
    cursor?: webhook_eventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` webhook_events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` webhook_events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of webhook_events.
     */
    distinct?: Webhook_eventScalarFieldEnum | Webhook_eventScalarFieldEnum[]
  }

  /**
   * webhook_event findFirstOrThrow
   */
  export type webhook_eventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the webhook_event
     */
    select?: webhook_eventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the webhook_event
     */
    omit?: webhook_eventOmit<ExtArgs> | null
    /**
     * Filter, which webhook_event to fetch.
     */
    where?: webhook_eventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of webhook_events to fetch.
     */
    orderBy?: webhook_eventOrderByWithRelationInput | webhook_eventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for webhook_events.
     */
    cursor?: webhook_eventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` webhook_events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` webhook_events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of webhook_events.
     */
    distinct?: Webhook_eventScalarFieldEnum | Webhook_eventScalarFieldEnum[]
  }

  /**
   * webhook_event findMany
   */
  export type webhook_eventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the webhook_event
     */
    select?: webhook_eventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the webhook_event
     */
    omit?: webhook_eventOmit<ExtArgs> | null
    /**
     * Filter, which webhook_events to fetch.
     */
    where?: webhook_eventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of webhook_events to fetch.
     */
    orderBy?: webhook_eventOrderByWithRelationInput | webhook_eventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing webhook_events.
     */
    cursor?: webhook_eventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` webhook_events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` webhook_events.
     */
    skip?: number
    distinct?: Webhook_eventScalarFieldEnum | Webhook_eventScalarFieldEnum[]
  }

  /**
   * webhook_event create
   */
  export type webhook_eventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the webhook_event
     */
    select?: webhook_eventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the webhook_event
     */
    omit?: webhook_eventOmit<ExtArgs> | null
    /**
     * The data needed to create a webhook_event.
     */
    data: XOR<webhook_eventCreateInput, webhook_eventUncheckedCreateInput>
  }

  /**
   * webhook_event createMany
   */
  export type webhook_eventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many webhook_events.
     */
    data: webhook_eventCreateManyInput | webhook_eventCreateManyInput[]
  }

  /**
   * webhook_event update
   */
  export type webhook_eventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the webhook_event
     */
    select?: webhook_eventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the webhook_event
     */
    omit?: webhook_eventOmit<ExtArgs> | null
    /**
     * The data needed to update a webhook_event.
     */
    data: XOR<webhook_eventUpdateInput, webhook_eventUncheckedUpdateInput>
    /**
     * Choose, which webhook_event to update.
     */
    where: webhook_eventWhereUniqueInput
  }

  /**
   * webhook_event updateMany
   */
  export type webhook_eventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update webhook_events.
     */
    data: XOR<webhook_eventUpdateManyMutationInput, webhook_eventUncheckedUpdateManyInput>
    /**
     * Filter which webhook_events to update
     */
    where?: webhook_eventWhereInput
    /**
     * Limit how many webhook_events to update.
     */
    limit?: number
  }

  /**
   * webhook_event upsert
   */
  export type webhook_eventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the webhook_event
     */
    select?: webhook_eventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the webhook_event
     */
    omit?: webhook_eventOmit<ExtArgs> | null
    /**
     * The filter to search for the webhook_event to update in case it exists.
     */
    where: webhook_eventWhereUniqueInput
    /**
     * In case the webhook_event found by the `where` argument doesn't exist, create a new webhook_event with this data.
     */
    create: XOR<webhook_eventCreateInput, webhook_eventUncheckedCreateInput>
    /**
     * In case the webhook_event was found with the provided `where` argument, update it with this data.
     */
    update: XOR<webhook_eventUpdateInput, webhook_eventUncheckedUpdateInput>
  }

  /**
   * webhook_event delete
   */
  export type webhook_eventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the webhook_event
     */
    select?: webhook_eventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the webhook_event
     */
    omit?: webhook_eventOmit<ExtArgs> | null
    /**
     * Filter which webhook_event to delete.
     */
    where: webhook_eventWhereUniqueInput
  }

  /**
   * webhook_event deleteMany
   */
  export type webhook_eventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which webhook_events to delete
     */
    where?: webhook_eventWhereInput
    /**
     * Limit how many webhook_events to delete.
     */
    limit?: number
  }

  /**
   * webhook_event findRaw
   */
  export type webhook_eventFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * webhook_event aggregateRaw
   */
  export type webhook_eventAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * webhook_event without action
   */
  export type webhook_eventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the webhook_event
     */
    select?: webhook_eventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the webhook_event
     */
    omit?: webhook_eventOmit<ExtArgs> | null
  }


  /**
   * Model session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    session_token: string | null
    ip: string | null
    user_agent: string | null
    expires_at: Date | null
    status: $Enums.setting_status | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    session_token: string | null
    ip: string | null
    user_agent: string | null
    expires_at: Date | null
    status: $Enums.setting_status | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    user_id: number
    session_token: number
    ip: number
    user_agent: number
    expires_at: number
    status: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    user_id?: true
    session_token?: true
    ip?: true
    user_agent?: true
    expires_at?: true
    status?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    user_id?: true
    session_token?: true
    ip?: true
    user_agent?: true
    expires_at?: true
    status?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    user_id?: true
    session_token?: true
    ip?: true
    user_agent?: true
    expires_at?: true
    status?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which session to aggregate.
     */
    where?: sessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionOrderByWithRelationInput | sessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: sessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type sessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sessionWhereInput
    orderBy?: sessionOrderByWithAggregationInput | sessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: sessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    user_id: string
    session_token: string
    ip: string | null
    user_agent: string | null
    expires_at: Date
    status: $Enums.setting_status
    created_at: Date
    updated_at: Date
    deleted_at: Date | null
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends sessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type sessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    session_token?: boolean
    ip?: boolean
    user_agent?: boolean
    expires_at?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>



  export type sessionSelectScalar = {
    id?: boolean
    user_id?: boolean
    session_token?: boolean
    ip?: boolean
    user_agent?: boolean
    expires_at?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }

  export type sessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "session_token" | "ip" | "user_agent" | "expires_at" | "status" | "created_at" | "updated_at" | "deleted_at", ExtArgs["result"]["session"]>
  export type sessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $sessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "session"
    objects: {
      user: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      session_token: string
      ip: string | null
      user_agent: string | null
      expires_at: Date
      status: $Enums.setting_status
      created_at: Date
      updated_at: Date
      deleted_at: Date | null
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type sessionGetPayload<S extends boolean | null | undefined | sessionDefaultArgs> = $Result.GetResult<Prisma.$sessionPayload, S>

  type sessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<sessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface sessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['session'], meta: { name: 'session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {sessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends sessionFindUniqueArgs>(args: SelectSubset<T, sessionFindUniqueArgs<ExtArgs>>): Prisma__sessionClient<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {sessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends sessionFindUniqueOrThrowArgs>(args: SelectSubset<T, sessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__sessionClient<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends sessionFindFirstArgs>(args?: SelectSubset<T, sessionFindFirstArgs<ExtArgs>>): Prisma__sessionClient<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends sessionFindFirstOrThrowArgs>(args?: SelectSubset<T, sessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__sessionClient<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends sessionFindManyArgs>(args?: SelectSubset<T, sessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {sessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends sessionCreateArgs>(args: SelectSubset<T, sessionCreateArgs<ExtArgs>>): Prisma__sessionClient<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {sessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends sessionCreateManyArgs>(args?: SelectSubset<T, sessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Session.
     * @param {sessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends sessionDeleteArgs>(args: SelectSubset<T, sessionDeleteArgs<ExtArgs>>): Prisma__sessionClient<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {sessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends sessionUpdateArgs>(args: SelectSubset<T, sessionUpdateArgs<ExtArgs>>): Prisma__sessionClient<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {sessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends sessionDeleteManyArgs>(args?: SelectSubset<T, sessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends sessionUpdateManyArgs>(args: SelectSubset<T, sessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Session.
     * @param {sessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends sessionUpsertArgs>(args: SelectSubset<T, sessionUpsertArgs<ExtArgs>>): Prisma__sessionClient<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * @param {sessionFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const session = await prisma.session.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: sessionFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Session.
     * @param {sessionAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const session = await prisma.session.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: sessionAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends sessionCountArgs>(
      args?: Subset<T, sessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends sessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: sessionGroupByArgs['orderBy'] }
        : { orderBy?: sessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, sessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the session model
   */
  readonly fields: sessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__sessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the session model
   */
  interface sessionFieldRefs {
    readonly id: FieldRef<"session", 'String'>
    readonly user_id: FieldRef<"session", 'String'>
    readonly session_token: FieldRef<"session", 'String'>
    readonly ip: FieldRef<"session", 'String'>
    readonly user_agent: FieldRef<"session", 'String'>
    readonly expires_at: FieldRef<"session", 'DateTime'>
    readonly status: FieldRef<"session", 'setting_status'>
    readonly created_at: FieldRef<"session", 'DateTime'>
    readonly updated_at: FieldRef<"session", 'DateTime'>
    readonly deleted_at: FieldRef<"session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * session findUnique
   */
  export type sessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionInclude<ExtArgs> | null
    /**
     * Filter, which session to fetch.
     */
    where: sessionWhereUniqueInput
  }

  /**
   * session findUniqueOrThrow
   */
  export type sessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionInclude<ExtArgs> | null
    /**
     * Filter, which session to fetch.
     */
    where: sessionWhereUniqueInput
  }

  /**
   * session findFirst
   */
  export type sessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionInclude<ExtArgs> | null
    /**
     * Filter, which session to fetch.
     */
    where?: sessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionOrderByWithRelationInput | sessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sessions.
     */
    cursor?: sessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * session findFirstOrThrow
   */
  export type sessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionInclude<ExtArgs> | null
    /**
     * Filter, which session to fetch.
     */
    where?: sessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionOrderByWithRelationInput | sessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sessions.
     */
    cursor?: sessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * session findMany
   */
  export type sessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionInclude<ExtArgs> | null
    /**
     * Filter, which sessions to fetch.
     */
    where?: sessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionOrderByWithRelationInput | sessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sessions.
     */
    cursor?: sessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * session create
   */
  export type sessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionInclude<ExtArgs> | null
    /**
     * The data needed to create a session.
     */
    data: XOR<sessionCreateInput, sessionUncheckedCreateInput>
  }

  /**
   * session createMany
   */
  export type sessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many sessions.
     */
    data: sessionCreateManyInput | sessionCreateManyInput[]
  }

  /**
   * session update
   */
  export type sessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionInclude<ExtArgs> | null
    /**
     * The data needed to update a session.
     */
    data: XOR<sessionUpdateInput, sessionUncheckedUpdateInput>
    /**
     * Choose, which session to update.
     */
    where: sessionWhereUniqueInput
  }

  /**
   * session updateMany
   */
  export type sessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update sessions.
     */
    data: XOR<sessionUpdateManyMutationInput, sessionUncheckedUpdateManyInput>
    /**
     * Filter which sessions to update
     */
    where?: sessionWhereInput
    /**
     * Limit how many sessions to update.
     */
    limit?: number
  }

  /**
   * session upsert
   */
  export type sessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionInclude<ExtArgs> | null
    /**
     * The filter to search for the session to update in case it exists.
     */
    where: sessionWhereUniqueInput
    /**
     * In case the session found by the `where` argument doesn't exist, create a new session with this data.
     */
    create: XOR<sessionCreateInput, sessionUncheckedCreateInput>
    /**
     * In case the session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<sessionUpdateInput, sessionUncheckedUpdateInput>
  }

  /**
   * session delete
   */
  export type sessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionInclude<ExtArgs> | null
    /**
     * Filter which session to delete.
     */
    where: sessionWhereUniqueInput
  }

  /**
   * session deleteMany
   */
  export type sessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sessions to delete
     */
    where?: sessionWhereInput
    /**
     * Limit how many sessions to delete.
     */
    limit?: number
  }

  /**
   * session findRaw
   */
  export type sessionFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * session aggregateRaw
   */
  export type sessionAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * session without action
   */
  export type sessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password_hash: 'password_hash',
    role: 'role',
    status: 'status',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ProfileScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    username: 'username',
    display_name: 'display_name',
    bio: 'bio',
    avatar_url: 'avatar_url',
    state: 'state',
    city: 'city',
    city_slug: 'city_slug',
    contact_email: 'contact_email',
    whatsapp: 'whatsapp',
    twitch: 'twitch',
    youtube: 'youtube',
    instagram: 'instagram',
    featured_media_id: 'featured_media_id',
    tags_count: 'tags_count',
    status: 'status',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type ProfileScalarFieldEnum = (typeof ProfileScalarFieldEnum)[keyof typeof ProfileScalarFieldEnum]


  export const MediaScalarFieldEnum: {
    id: 'id',
    player_id: 'player_id',
    type: 'type',
    source: 'source',
    url: 'url',
    poster_url: 'poster_url',
    blur_data_url: 'blur_data_url',
    width: 'width',
    height: 'height',
    duration_sec: 'duration_sec',
    focal_point_x: 'focal_point_x',
    focal_point_y: 'focal_point_y',
    variants: 'variants',
    hls_url: 'hls_url',
    nsfw_score: 'nsfw_score',
    nsfw_labels: 'nsfw_labels',
    title: 'title',
    tags_cache: 'tags_cache',
    status: 'status',
    moderation_history: 'moderation_history',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type MediaScalarFieldEnum = (typeof MediaScalarFieldEnum)[keyof typeof MediaScalarFieldEnum]


  export const TagScalarFieldEnum: {
    id: 'id',
    slug: 'slug',
    label: 'label',
    aliases: 'aliases',
    status: 'status',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type TagScalarFieldEnum = (typeof TagScalarFieldEnum)[keyof typeof TagScalarFieldEnum]


  export const Player_tagScalarFieldEnum: {
    id: 'id',
    player_id: 'player_id',
    tag_id: 'tag_id',
    status: 'status',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type Player_tagScalarFieldEnum = (typeof Player_tagScalarFieldEnum)[keyof typeof Player_tagScalarFieldEnum]


  export const BoostScalarFieldEnum: {
    id: 'id',
    player_id: 'player_id',
    status: 'status',
    starts_at: 'starts_at',
    ends_at: 'ends_at',
    provider: 'provider',
    external_id: 'external_id',
    amount_cents: 'amount_cents',
    currency: 'currency',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type BoostScalarFieldEnum = (typeof BoostScalarFieldEnum)[keyof typeof BoostScalarFieldEnum]


  export const ReportScalarFieldEnum: {
    id: 'id',
    reporter_user_id: 'reporter_user_id',
    target_type: 'target_type',
    target_id: 'target_id',
    reason: 'reason',
    details: 'details',
    severity: 'severity',
    status: 'status',
    resolution_note: 'resolution_note',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type ReportScalarFieldEnum = (typeof ReportScalarFieldEnum)[keyof typeof ReportScalarFieldEnum]


  export const StrikeScalarFieldEnum: {
    id: 'id',
    player_id: 'player_id',
    reason: 'reason',
    severity: 'severity',
    expires_at: 'expires_at',
    status: 'status',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type StrikeScalarFieldEnum = (typeof StrikeScalarFieldEnum)[keyof typeof StrikeScalarFieldEnum]


  export const User_noteScalarFieldEnum: {
    id: 'id',
    player_id: 'player_id',
    author_id: 'author_id',
    note: 'note',
    status: 'status',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type User_noteScalarFieldEnum = (typeof User_noteScalarFieldEnum)[keyof typeof User_noteScalarFieldEnum]


  export const AnnouncementScalarFieldEnum: {
    id: 'id',
    title: 'title',
    body_md: 'body_md',
    status: 'status',
    starts_at: 'starts_at',
    ends_at: 'ends_at',
    segment_tags: 'segment_tags',
    segment_states: 'segment_states',
    segment_devices: 'segment_devices',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type AnnouncementScalarFieldEnum = (typeof AnnouncementScalarFieldEnum)[keyof typeof AnnouncementScalarFieldEnum]


  export const Feature_slotScalarFieldEnum: {
    id: 'id',
    slot_key: 'slot_key',
    description: 'description',
    status: 'status',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type Feature_slotScalarFieldEnum = (typeof Feature_slotScalarFieldEnum)[keyof typeof Feature_slotScalarFieldEnum]


  export const Featured_assignmentScalarFieldEnum: {
    id: 'id',
    slot_key: 'slot_key',
    player_id: 'player_id',
    media_id: 'media_id',
    starts_at: 'starts_at',
    ends_at: 'ends_at',
    priority: 'priority',
    status: 'status',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type Featured_assignmentScalarFieldEnum = (typeof Featured_assignmentScalarFieldEnum)[keyof typeof Featured_assignmentScalarFieldEnum]


  export const SettingScalarFieldEnum: {
    id: 'id',
    key: 'key',
    value_json: 'value_json',
    status: 'status',
    version: 'version',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type SettingScalarFieldEnum = (typeof SettingScalarFieldEnum)[keyof typeof SettingScalarFieldEnum]


  export const Support_ticketScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    email: 'email',
    subject: 'subject',
    message: 'message',
    priority: 'priority',
    status: 'status',
    assigned_to: 'assigned_to',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type Support_ticketScalarFieldEnum = (typeof Support_ticketScalarFieldEnum)[keyof typeof Support_ticketScalarFieldEnum]


  export const Contact_eventScalarFieldEnum: {
    id: 'id',
    player_id: 'player_id',
    channel: 'channel',
    requester_ip: 'requester_ip',
    user_agent: 'user_agent',
    referrer: 'referrer',
    message: 'message',
    status: 'status',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type Contact_eventScalarFieldEnum = (typeof Contact_eventScalarFieldEnum)[keyof typeof Contact_eventScalarFieldEnum]


  export const Audit_logScalarFieldEnum: {
    id: 'id',
    actor_user_id: 'actor_user_id',
    actor_role: 'actor_role',
    entity_type: 'entity_type',
    entity_id: 'entity_id',
    action: 'action',
    payload: 'payload',
    status: 'status',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type Audit_logScalarFieldEnum = (typeof Audit_logScalarFieldEnum)[keyof typeof Audit_logScalarFieldEnum]


  export const Webhook_eventScalarFieldEnum: {
    id: 'id',
    provider: 'provider',
    event_type: 'event_type',
    payload: 'payload',
    related_type: 'related_type',
    related_id: 'related_id',
    status: 'status',
    retry_count: 'retry_count',
    last_error: 'last_error',
    next_retry_at: 'next_retry_at',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type Webhook_eventScalarFieldEnum = (typeof Webhook_eventScalarFieldEnum)[keyof typeof Webhook_eventScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    session_token: 'session_token',
    ip: 'ip',
    user_agent: 'user_agent',
    expires_at: 'expires_at',
    status: 'status',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'user_role'
   */
  export type Enumuser_roleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'user_role'>
    


  /**
   * Reference to a field of type 'user_role[]'
   */
  export type ListEnumuser_roleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'user_role[]'>
    


  /**
   * Reference to a field of type 'user_status'
   */
  export type Enumuser_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'user_status'>
    


  /**
   * Reference to a field of type 'user_status[]'
   */
  export type ListEnumuser_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'user_status[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'profile_status'
   */
  export type Enumprofile_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'profile_status'>
    


  /**
   * Reference to a field of type 'profile_status[]'
   */
  export type ListEnumprofile_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'profile_status[]'>
    


  /**
   * Reference to a field of type 'media_type'
   */
  export type Enummedia_typeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'media_type'>
    


  /**
   * Reference to a field of type 'media_type[]'
   */
  export type ListEnummedia_typeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'media_type[]'>
    


  /**
   * Reference to a field of type 'media_source'
   */
  export type Enummedia_sourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'media_source'>
    


  /**
   * Reference to a field of type 'media_source[]'
   */
  export type ListEnummedia_sourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'media_source[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'media_status'
   */
  export type Enummedia_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'media_status'>
    


  /**
   * Reference to a field of type 'media_status[]'
   */
  export type ListEnummedia_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'media_status[]'>
    


  /**
   * Reference to a field of type 'setting_status'
   */
  export type Enumsetting_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'setting_status'>
    


  /**
   * Reference to a field of type 'setting_status[]'
   */
  export type ListEnumsetting_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'setting_status[]'>
    


  /**
   * Reference to a field of type 'boost_status'
   */
  export type Enumboost_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'boost_status'>
    


  /**
   * Reference to a field of type 'boost_status[]'
   */
  export type ListEnumboost_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'boost_status[]'>
    


  /**
   * Reference to a field of type 'provider_kind'
   */
  export type Enumprovider_kindFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'provider_kind'>
    


  /**
   * Reference to a field of type 'provider_kind[]'
   */
  export type ListEnumprovider_kindFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'provider_kind[]'>
    


  /**
   * Reference to a field of type 'report_reason'
   */
  export type Enumreport_reasonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'report_reason'>
    


  /**
   * Reference to a field of type 'report_reason[]'
   */
  export type ListEnumreport_reasonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'report_reason[]'>
    


  /**
   * Reference to a field of type 'severity_level'
   */
  export type Enumseverity_levelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'severity_level'>
    


  /**
   * Reference to a field of type 'severity_level[]'
   */
  export type ListEnumseverity_levelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'severity_level[]'>
    


  /**
   * Reference to a field of type 'report_status'
   */
  export type Enumreport_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'report_status'>
    


  /**
   * Reference to a field of type 'report_status[]'
   */
  export type ListEnumreport_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'report_status[]'>
    


  /**
   * Reference to a field of type 'announcement_status'
   */
  export type Enumannouncement_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'announcement_status'>
    


  /**
   * Reference to a field of type 'announcement_status[]'
   */
  export type ListEnumannouncement_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'announcement_status[]'>
    


  /**
   * Reference to a field of type 'feature_slot_key'
   */
  export type Enumfeature_slot_keyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'feature_slot_key'>
    


  /**
   * Reference to a field of type 'feature_slot_key[]'
   */
  export type ListEnumfeature_slot_keyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'feature_slot_key[]'>
    


  /**
   * Reference to a field of type 'ticket_priority'
   */
  export type Enumticket_priorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ticket_priority'>
    


  /**
   * Reference to a field of type 'ticket_priority[]'
   */
  export type ListEnumticket_priorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ticket_priority[]'>
    


  /**
   * Reference to a field of type 'ticket_status'
   */
  export type Enumticket_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ticket_status'>
    


  /**
   * Reference to a field of type 'ticket_status[]'
   */
  export type ListEnumticket_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ticket_status[]'>
    


  /**
   * Reference to a field of type 'contact_channel'
   */
  export type Enumcontact_channelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'contact_channel'>
    


  /**
   * Reference to a field of type 'contact_channel[]'
   */
  export type ListEnumcontact_channelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'contact_channel[]'>
    


  /**
   * Reference to a field of type 'audit_status'
   */
  export type Enumaudit_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'audit_status'>
    


  /**
   * Reference to a field of type 'audit_status[]'
   */
  export type ListEnumaudit_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'audit_status[]'>
    


  /**
   * Reference to a field of type 'webhook_status'
   */
  export type Enumwebhook_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'webhook_status'>
    


  /**
   * Reference to a field of type 'webhook_status[]'
   */
  export type ListEnumwebhook_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'webhook_status[]'>
    
  /**
   * Deep Input Types
   */


  export type userWhereInput = {
    AND?: userWhereInput | userWhereInput[]
    OR?: userWhereInput[]
    NOT?: userWhereInput | userWhereInput[]
    id?: StringFilter<"user"> | string
    email?: StringFilter<"user"> | string
    password_hash?: StringFilter<"user"> | string
    role?: Enumuser_roleFilter<"user"> | $Enums.user_role
    status?: Enumuser_statusFilter<"user"> | $Enums.user_status
    created_at?: DateTimeFilter<"user"> | Date | string
    updated_at?: DateTimeFilter<"user"> | Date | string
    deleted_at?: DateTimeNullableFilter<"user"> | Date | string | null
    profile?: XOR<ProfileNullableScalarRelationFilter, profileWhereInput> | null
    tickets?: Support_ticketListRelationFilter
    assigned_tickets?: Support_ticketListRelationFilter
    reports_made?: ReportListRelationFilter
    notes_authored?: User_noteListRelationFilter
    sessions?: SessionListRelationFilter
  }

  export type userOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    role?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    profile?: profileOrderByWithRelationInput
    tickets?: support_ticketOrderByRelationAggregateInput
    assigned_tickets?: support_ticketOrderByRelationAggregateInput
    reports_made?: reportOrderByRelationAggregateInput
    notes_authored?: user_noteOrderByRelationAggregateInput
    sessions?: sessionOrderByRelationAggregateInput
  }

  export type userWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: userWhereInput | userWhereInput[]
    OR?: userWhereInput[]
    NOT?: userWhereInput | userWhereInput[]
    password_hash?: StringFilter<"user"> | string
    role?: Enumuser_roleFilter<"user"> | $Enums.user_role
    status?: Enumuser_statusFilter<"user"> | $Enums.user_status
    created_at?: DateTimeFilter<"user"> | Date | string
    updated_at?: DateTimeFilter<"user"> | Date | string
    deleted_at?: DateTimeNullableFilter<"user"> | Date | string | null
    profile?: XOR<ProfileNullableScalarRelationFilter, profileWhereInput> | null
    tickets?: Support_ticketListRelationFilter
    assigned_tickets?: Support_ticketListRelationFilter
    reports_made?: ReportListRelationFilter
    notes_authored?: User_noteListRelationFilter
    sessions?: SessionListRelationFilter
  }, "id" | "email">

  export type userOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    role?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    _count?: userCountOrderByAggregateInput
    _max?: userMaxOrderByAggregateInput
    _min?: userMinOrderByAggregateInput
  }

  export type userScalarWhereWithAggregatesInput = {
    AND?: userScalarWhereWithAggregatesInput | userScalarWhereWithAggregatesInput[]
    OR?: userScalarWhereWithAggregatesInput[]
    NOT?: userScalarWhereWithAggregatesInput | userScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"user"> | string
    email?: StringWithAggregatesFilter<"user"> | string
    password_hash?: StringWithAggregatesFilter<"user"> | string
    role?: Enumuser_roleWithAggregatesFilter<"user"> | $Enums.user_role
    status?: Enumuser_statusWithAggregatesFilter<"user"> | $Enums.user_status
    created_at?: DateTimeWithAggregatesFilter<"user"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"user"> | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"user"> | Date | string | null
  }

  export type profileWhereInput = {
    AND?: profileWhereInput | profileWhereInput[]
    OR?: profileWhereInput[]
    NOT?: profileWhereInput | profileWhereInput[]
    id?: StringFilter<"profile"> | string
    user_id?: StringFilter<"profile"> | string
    username?: StringFilter<"profile"> | string
    display_name?: StringFilter<"profile"> | string
    bio?: StringNullableFilter<"profile"> | string | null
    avatar_url?: StringNullableFilter<"profile"> | string | null
    state?: StringFilter<"profile"> | string
    city?: StringFilter<"profile"> | string
    city_slug?: StringNullableFilter<"profile"> | string | null
    contact_email?: StringNullableFilter<"profile"> | string | null
    whatsapp?: StringNullableFilter<"profile"> | string | null
    twitch?: StringNullableFilter<"profile"> | string | null
    youtube?: StringNullableFilter<"profile"> | string | null
    instagram?: StringNullableFilter<"profile"> | string | null
    featured_media_id?: StringNullableFilter<"profile"> | string | null
    tags_count?: IntNullableFilter<"profile"> | number | null
    status?: Enumprofile_statusFilter<"profile"> | $Enums.profile_status
    created_at?: DateTimeFilter<"profile"> | Date | string
    updated_at?: DateTimeFilter<"profile"> | Date | string
    deleted_at?: DateTimeNullableFilter<"profile"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, userWhereInput>
    media?: MediaListRelationFilter
    boosts?: BoostListRelationFilter
    strikes?: StrikeListRelationFilter
    notes?: User_noteListRelationFilter
    contact_events?: Contact_eventListRelationFilter
    reports_against?: ReportListRelationFilter
    player_tags?: Player_tagListRelationFilter
    featured_assignments?: Featured_assignmentListRelationFilter
  }

  export type profileOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    username?: SortOrder
    display_name?: SortOrder
    bio?: SortOrder
    avatar_url?: SortOrder
    state?: SortOrder
    city?: SortOrder
    city_slug?: SortOrder
    contact_email?: SortOrder
    whatsapp?: SortOrder
    twitch?: SortOrder
    youtube?: SortOrder
    instagram?: SortOrder
    featured_media_id?: SortOrder
    tags_count?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    user?: userOrderByWithRelationInput
    media?: mediaOrderByRelationAggregateInput
    boosts?: boostOrderByRelationAggregateInput
    strikes?: strikeOrderByRelationAggregateInput
    notes?: user_noteOrderByRelationAggregateInput
    contact_events?: contact_eventOrderByRelationAggregateInput
    reports_against?: reportOrderByRelationAggregateInput
    player_tags?: player_tagOrderByRelationAggregateInput
    featured_assignments?: featured_assignmentOrderByRelationAggregateInput
  }

  export type profileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    user_id?: string
    username?: string
    AND?: profileWhereInput | profileWhereInput[]
    OR?: profileWhereInput[]
    NOT?: profileWhereInput | profileWhereInput[]
    display_name?: StringFilter<"profile"> | string
    bio?: StringNullableFilter<"profile"> | string | null
    avatar_url?: StringNullableFilter<"profile"> | string | null
    state?: StringFilter<"profile"> | string
    city?: StringFilter<"profile"> | string
    city_slug?: StringNullableFilter<"profile"> | string | null
    contact_email?: StringNullableFilter<"profile"> | string | null
    whatsapp?: StringNullableFilter<"profile"> | string | null
    twitch?: StringNullableFilter<"profile"> | string | null
    youtube?: StringNullableFilter<"profile"> | string | null
    instagram?: StringNullableFilter<"profile"> | string | null
    featured_media_id?: StringNullableFilter<"profile"> | string | null
    tags_count?: IntNullableFilter<"profile"> | number | null
    status?: Enumprofile_statusFilter<"profile"> | $Enums.profile_status
    created_at?: DateTimeFilter<"profile"> | Date | string
    updated_at?: DateTimeFilter<"profile"> | Date | string
    deleted_at?: DateTimeNullableFilter<"profile"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, userWhereInput>
    media?: MediaListRelationFilter
    boosts?: BoostListRelationFilter
    strikes?: StrikeListRelationFilter
    notes?: User_noteListRelationFilter
    contact_events?: Contact_eventListRelationFilter
    reports_against?: ReportListRelationFilter
    player_tags?: Player_tagListRelationFilter
    featured_assignments?: Featured_assignmentListRelationFilter
  }, "id" | "user_id" | "username">

  export type profileOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    username?: SortOrder
    display_name?: SortOrder
    bio?: SortOrder
    avatar_url?: SortOrder
    state?: SortOrder
    city?: SortOrder
    city_slug?: SortOrder
    contact_email?: SortOrder
    whatsapp?: SortOrder
    twitch?: SortOrder
    youtube?: SortOrder
    instagram?: SortOrder
    featured_media_id?: SortOrder
    tags_count?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    _count?: profileCountOrderByAggregateInput
    _avg?: profileAvgOrderByAggregateInput
    _max?: profileMaxOrderByAggregateInput
    _min?: profileMinOrderByAggregateInput
    _sum?: profileSumOrderByAggregateInput
  }

  export type profileScalarWhereWithAggregatesInput = {
    AND?: profileScalarWhereWithAggregatesInput | profileScalarWhereWithAggregatesInput[]
    OR?: profileScalarWhereWithAggregatesInput[]
    NOT?: profileScalarWhereWithAggregatesInput | profileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"profile"> | string
    user_id?: StringWithAggregatesFilter<"profile"> | string
    username?: StringWithAggregatesFilter<"profile"> | string
    display_name?: StringWithAggregatesFilter<"profile"> | string
    bio?: StringNullableWithAggregatesFilter<"profile"> | string | null
    avatar_url?: StringNullableWithAggregatesFilter<"profile"> | string | null
    state?: StringWithAggregatesFilter<"profile"> | string
    city?: StringWithAggregatesFilter<"profile"> | string
    city_slug?: StringNullableWithAggregatesFilter<"profile"> | string | null
    contact_email?: StringNullableWithAggregatesFilter<"profile"> | string | null
    whatsapp?: StringNullableWithAggregatesFilter<"profile"> | string | null
    twitch?: StringNullableWithAggregatesFilter<"profile"> | string | null
    youtube?: StringNullableWithAggregatesFilter<"profile"> | string | null
    instagram?: StringNullableWithAggregatesFilter<"profile"> | string | null
    featured_media_id?: StringNullableWithAggregatesFilter<"profile"> | string | null
    tags_count?: IntNullableWithAggregatesFilter<"profile"> | number | null
    status?: Enumprofile_statusWithAggregatesFilter<"profile"> | $Enums.profile_status
    created_at?: DateTimeWithAggregatesFilter<"profile"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"profile"> | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"profile"> | Date | string | null
  }

  export type mediaWhereInput = {
    AND?: mediaWhereInput | mediaWhereInput[]
    OR?: mediaWhereInput[]
    NOT?: mediaWhereInput | mediaWhereInput[]
    id?: StringFilter<"media"> | string
    player_id?: StringFilter<"media"> | string
    type?: Enummedia_typeFilter<"media"> | $Enums.media_type
    source?: Enummedia_sourceFilter<"media"> | $Enums.media_source
    url?: StringFilter<"media"> | string
    poster_url?: StringNullableFilter<"media"> | string | null
    blur_data_url?: StringNullableFilter<"media"> | string | null
    width?: IntNullableFilter<"media"> | number | null
    height?: IntNullableFilter<"media"> | number | null
    duration_sec?: IntNullableFilter<"media"> | number | null
    focal_point_x?: IntNullableFilter<"media"> | number | null
    focal_point_y?: IntNullableFilter<"media"> | number | null
    variants?: JsonNullableFilter<"media">
    hls_url?: StringNullableFilter<"media"> | string | null
    nsfw_score?: FloatNullableFilter<"media"> | number | null
    nsfw_labels?: JsonNullableFilter<"media">
    title?: StringNullableFilter<"media"> | string | null
    tags_cache?: StringNullableListFilter<"media">
    status?: Enummedia_statusFilter<"media"> | $Enums.media_status
    moderation_history?: JsonNullableFilter<"media">
    created_at?: DateTimeFilter<"media"> | Date | string
    updated_at?: DateTimeFilter<"media"> | Date | string
    deleted_at?: DateTimeNullableFilter<"media"> | Date | string | null
    player?: XOR<ProfileScalarRelationFilter, profileWhereInput>
    reports_against?: ReportListRelationFilter
    featured_assignments?: Featured_assignmentListRelationFilter
  }

  export type mediaOrderByWithRelationInput = {
    id?: SortOrder
    player_id?: SortOrder
    type?: SortOrder
    source?: SortOrder
    url?: SortOrder
    poster_url?: SortOrder
    blur_data_url?: SortOrder
    width?: SortOrder
    height?: SortOrder
    duration_sec?: SortOrder
    focal_point_x?: SortOrder
    focal_point_y?: SortOrder
    variants?: SortOrder
    hls_url?: SortOrder
    nsfw_score?: SortOrder
    nsfw_labels?: SortOrder
    title?: SortOrder
    tags_cache?: SortOrder
    status?: SortOrder
    moderation_history?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    player?: profileOrderByWithRelationInput
    reports_against?: reportOrderByRelationAggregateInput
    featured_assignments?: featured_assignmentOrderByRelationAggregateInput
  }

  export type mediaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: mediaWhereInput | mediaWhereInput[]
    OR?: mediaWhereInput[]
    NOT?: mediaWhereInput | mediaWhereInput[]
    player_id?: StringFilter<"media"> | string
    type?: Enummedia_typeFilter<"media"> | $Enums.media_type
    source?: Enummedia_sourceFilter<"media"> | $Enums.media_source
    url?: StringFilter<"media"> | string
    poster_url?: StringNullableFilter<"media"> | string | null
    blur_data_url?: StringNullableFilter<"media"> | string | null
    width?: IntNullableFilter<"media"> | number | null
    height?: IntNullableFilter<"media"> | number | null
    duration_sec?: IntNullableFilter<"media"> | number | null
    focal_point_x?: IntNullableFilter<"media"> | number | null
    focal_point_y?: IntNullableFilter<"media"> | number | null
    variants?: JsonNullableFilter<"media">
    hls_url?: StringNullableFilter<"media"> | string | null
    nsfw_score?: FloatNullableFilter<"media"> | number | null
    nsfw_labels?: JsonNullableFilter<"media">
    title?: StringNullableFilter<"media"> | string | null
    tags_cache?: StringNullableListFilter<"media">
    status?: Enummedia_statusFilter<"media"> | $Enums.media_status
    moderation_history?: JsonNullableFilter<"media">
    created_at?: DateTimeFilter<"media"> | Date | string
    updated_at?: DateTimeFilter<"media"> | Date | string
    deleted_at?: DateTimeNullableFilter<"media"> | Date | string | null
    player?: XOR<ProfileScalarRelationFilter, profileWhereInput>
    reports_against?: ReportListRelationFilter
    featured_assignments?: Featured_assignmentListRelationFilter
  }, "id">

  export type mediaOrderByWithAggregationInput = {
    id?: SortOrder
    player_id?: SortOrder
    type?: SortOrder
    source?: SortOrder
    url?: SortOrder
    poster_url?: SortOrder
    blur_data_url?: SortOrder
    width?: SortOrder
    height?: SortOrder
    duration_sec?: SortOrder
    focal_point_x?: SortOrder
    focal_point_y?: SortOrder
    variants?: SortOrder
    hls_url?: SortOrder
    nsfw_score?: SortOrder
    nsfw_labels?: SortOrder
    title?: SortOrder
    tags_cache?: SortOrder
    status?: SortOrder
    moderation_history?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    _count?: mediaCountOrderByAggregateInput
    _avg?: mediaAvgOrderByAggregateInput
    _max?: mediaMaxOrderByAggregateInput
    _min?: mediaMinOrderByAggregateInput
    _sum?: mediaSumOrderByAggregateInput
  }

  export type mediaScalarWhereWithAggregatesInput = {
    AND?: mediaScalarWhereWithAggregatesInput | mediaScalarWhereWithAggregatesInput[]
    OR?: mediaScalarWhereWithAggregatesInput[]
    NOT?: mediaScalarWhereWithAggregatesInput | mediaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"media"> | string
    player_id?: StringWithAggregatesFilter<"media"> | string
    type?: Enummedia_typeWithAggregatesFilter<"media"> | $Enums.media_type
    source?: Enummedia_sourceWithAggregatesFilter<"media"> | $Enums.media_source
    url?: StringWithAggregatesFilter<"media"> | string
    poster_url?: StringNullableWithAggregatesFilter<"media"> | string | null
    blur_data_url?: StringNullableWithAggregatesFilter<"media"> | string | null
    width?: IntNullableWithAggregatesFilter<"media"> | number | null
    height?: IntNullableWithAggregatesFilter<"media"> | number | null
    duration_sec?: IntNullableWithAggregatesFilter<"media"> | number | null
    focal_point_x?: IntNullableWithAggregatesFilter<"media"> | number | null
    focal_point_y?: IntNullableWithAggregatesFilter<"media"> | number | null
    variants?: JsonNullableWithAggregatesFilter<"media">
    hls_url?: StringNullableWithAggregatesFilter<"media"> | string | null
    nsfw_score?: FloatNullableWithAggregatesFilter<"media"> | number | null
    nsfw_labels?: JsonNullableWithAggregatesFilter<"media">
    title?: StringNullableWithAggregatesFilter<"media"> | string | null
    tags_cache?: StringNullableListFilter<"media">
    status?: Enummedia_statusWithAggregatesFilter<"media"> | $Enums.media_status
    moderation_history?: JsonNullableWithAggregatesFilter<"media">
    created_at?: DateTimeWithAggregatesFilter<"media"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"media"> | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"media"> | Date | string | null
  }

  export type tagWhereInput = {
    AND?: tagWhereInput | tagWhereInput[]
    OR?: tagWhereInput[]
    NOT?: tagWhereInput | tagWhereInput[]
    id?: StringFilter<"tag"> | string
    slug?: StringFilter<"tag"> | string
    label?: StringFilter<"tag"> | string
    aliases?: StringNullableListFilter<"tag">
    status?: Enumsetting_statusFilter<"tag"> | $Enums.setting_status
    created_at?: DateTimeFilter<"tag"> | Date | string
    updated_at?: DateTimeFilter<"tag"> | Date | string
    deleted_at?: DateTimeNullableFilter<"tag"> | Date | string | null
    player_tags?: Player_tagListRelationFilter
  }

  export type tagOrderByWithRelationInput = {
    id?: SortOrder
    slug?: SortOrder
    label?: SortOrder
    aliases?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    player_tags?: player_tagOrderByRelationAggregateInput
  }

  export type tagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: tagWhereInput | tagWhereInput[]
    OR?: tagWhereInput[]
    NOT?: tagWhereInput | tagWhereInput[]
    label?: StringFilter<"tag"> | string
    aliases?: StringNullableListFilter<"tag">
    status?: Enumsetting_statusFilter<"tag"> | $Enums.setting_status
    created_at?: DateTimeFilter<"tag"> | Date | string
    updated_at?: DateTimeFilter<"tag"> | Date | string
    deleted_at?: DateTimeNullableFilter<"tag"> | Date | string | null
    player_tags?: Player_tagListRelationFilter
  }, "id" | "slug">

  export type tagOrderByWithAggregationInput = {
    id?: SortOrder
    slug?: SortOrder
    label?: SortOrder
    aliases?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    _count?: tagCountOrderByAggregateInput
    _max?: tagMaxOrderByAggregateInput
    _min?: tagMinOrderByAggregateInput
  }

  export type tagScalarWhereWithAggregatesInput = {
    AND?: tagScalarWhereWithAggregatesInput | tagScalarWhereWithAggregatesInput[]
    OR?: tagScalarWhereWithAggregatesInput[]
    NOT?: tagScalarWhereWithAggregatesInput | tagScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"tag"> | string
    slug?: StringWithAggregatesFilter<"tag"> | string
    label?: StringWithAggregatesFilter<"tag"> | string
    aliases?: StringNullableListFilter<"tag">
    status?: Enumsetting_statusWithAggregatesFilter<"tag"> | $Enums.setting_status
    created_at?: DateTimeWithAggregatesFilter<"tag"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"tag"> | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"tag"> | Date | string | null
  }

  export type player_tagWhereInput = {
    AND?: player_tagWhereInput | player_tagWhereInput[]
    OR?: player_tagWhereInput[]
    NOT?: player_tagWhereInput | player_tagWhereInput[]
    id?: StringFilter<"player_tag"> | string
    player_id?: StringFilter<"player_tag"> | string
    tag_id?: StringFilter<"player_tag"> | string
    status?: Enumsetting_statusFilter<"player_tag"> | $Enums.setting_status
    created_at?: DateTimeFilter<"player_tag"> | Date | string
    updated_at?: DateTimeFilter<"player_tag"> | Date | string
    deleted_at?: DateTimeNullableFilter<"player_tag"> | Date | string | null
    player?: XOR<ProfileScalarRelationFilter, profileWhereInput>
    tag_ref?: XOR<TagScalarRelationFilter, tagWhereInput>
  }

  export type player_tagOrderByWithRelationInput = {
    id?: SortOrder
    player_id?: SortOrder
    tag_id?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    player?: profileOrderByWithRelationInput
    tag_ref?: tagOrderByWithRelationInput
  }

  export type player_tagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    player_id_tag_id?: player_tagPlayer_idTag_idCompoundUniqueInput
    AND?: player_tagWhereInput | player_tagWhereInput[]
    OR?: player_tagWhereInput[]
    NOT?: player_tagWhereInput | player_tagWhereInput[]
    player_id?: StringFilter<"player_tag"> | string
    tag_id?: StringFilter<"player_tag"> | string
    status?: Enumsetting_statusFilter<"player_tag"> | $Enums.setting_status
    created_at?: DateTimeFilter<"player_tag"> | Date | string
    updated_at?: DateTimeFilter<"player_tag"> | Date | string
    deleted_at?: DateTimeNullableFilter<"player_tag"> | Date | string | null
    player?: XOR<ProfileScalarRelationFilter, profileWhereInput>
    tag_ref?: XOR<TagScalarRelationFilter, tagWhereInput>
  }, "id" | "player_id_tag_id">

  export type player_tagOrderByWithAggregationInput = {
    id?: SortOrder
    player_id?: SortOrder
    tag_id?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    _count?: player_tagCountOrderByAggregateInput
    _max?: player_tagMaxOrderByAggregateInput
    _min?: player_tagMinOrderByAggregateInput
  }

  export type player_tagScalarWhereWithAggregatesInput = {
    AND?: player_tagScalarWhereWithAggregatesInput | player_tagScalarWhereWithAggregatesInput[]
    OR?: player_tagScalarWhereWithAggregatesInput[]
    NOT?: player_tagScalarWhereWithAggregatesInput | player_tagScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"player_tag"> | string
    player_id?: StringWithAggregatesFilter<"player_tag"> | string
    tag_id?: StringWithAggregatesFilter<"player_tag"> | string
    status?: Enumsetting_statusWithAggregatesFilter<"player_tag"> | $Enums.setting_status
    created_at?: DateTimeWithAggregatesFilter<"player_tag"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"player_tag"> | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"player_tag"> | Date | string | null
  }

  export type boostWhereInput = {
    AND?: boostWhereInput | boostWhereInput[]
    OR?: boostWhereInput[]
    NOT?: boostWhereInput | boostWhereInput[]
    id?: StringFilter<"boost"> | string
    player_id?: StringFilter<"boost"> | string
    status?: Enumboost_statusFilter<"boost"> | $Enums.boost_status
    starts_at?: DateTimeFilter<"boost"> | Date | string
    ends_at?: DateTimeFilter<"boost"> | Date | string
    provider?: Enumprovider_kindFilter<"boost"> | $Enums.provider_kind
    external_id?: StringNullableFilter<"boost"> | string | null
    amount_cents?: IntFilter<"boost"> | number
    currency?: StringFilter<"boost"> | string
    created_at?: DateTimeFilter<"boost"> | Date | string
    updated_at?: DateTimeFilter<"boost"> | Date | string
    deleted_at?: DateTimeNullableFilter<"boost"> | Date | string | null
    player?: XOR<ProfileScalarRelationFilter, profileWhereInput>
  }

  export type boostOrderByWithRelationInput = {
    id?: SortOrder
    player_id?: SortOrder
    status?: SortOrder
    starts_at?: SortOrder
    ends_at?: SortOrder
    provider?: SortOrder
    external_id?: SortOrder
    amount_cents?: SortOrder
    currency?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    player?: profileOrderByWithRelationInput
  }

  export type boostWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: boostWhereInput | boostWhereInput[]
    OR?: boostWhereInput[]
    NOT?: boostWhereInput | boostWhereInput[]
    player_id?: StringFilter<"boost"> | string
    status?: Enumboost_statusFilter<"boost"> | $Enums.boost_status
    starts_at?: DateTimeFilter<"boost"> | Date | string
    ends_at?: DateTimeFilter<"boost"> | Date | string
    provider?: Enumprovider_kindFilter<"boost"> | $Enums.provider_kind
    external_id?: StringNullableFilter<"boost"> | string | null
    amount_cents?: IntFilter<"boost"> | number
    currency?: StringFilter<"boost"> | string
    created_at?: DateTimeFilter<"boost"> | Date | string
    updated_at?: DateTimeFilter<"boost"> | Date | string
    deleted_at?: DateTimeNullableFilter<"boost"> | Date | string | null
    player?: XOR<ProfileScalarRelationFilter, profileWhereInput>
  }, "id">

  export type boostOrderByWithAggregationInput = {
    id?: SortOrder
    player_id?: SortOrder
    status?: SortOrder
    starts_at?: SortOrder
    ends_at?: SortOrder
    provider?: SortOrder
    external_id?: SortOrder
    amount_cents?: SortOrder
    currency?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    _count?: boostCountOrderByAggregateInput
    _avg?: boostAvgOrderByAggregateInput
    _max?: boostMaxOrderByAggregateInput
    _min?: boostMinOrderByAggregateInput
    _sum?: boostSumOrderByAggregateInput
  }

  export type boostScalarWhereWithAggregatesInput = {
    AND?: boostScalarWhereWithAggregatesInput | boostScalarWhereWithAggregatesInput[]
    OR?: boostScalarWhereWithAggregatesInput[]
    NOT?: boostScalarWhereWithAggregatesInput | boostScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"boost"> | string
    player_id?: StringWithAggregatesFilter<"boost"> | string
    status?: Enumboost_statusWithAggregatesFilter<"boost"> | $Enums.boost_status
    starts_at?: DateTimeWithAggregatesFilter<"boost"> | Date | string
    ends_at?: DateTimeWithAggregatesFilter<"boost"> | Date | string
    provider?: Enumprovider_kindWithAggregatesFilter<"boost"> | $Enums.provider_kind
    external_id?: StringNullableWithAggregatesFilter<"boost"> | string | null
    amount_cents?: IntWithAggregatesFilter<"boost"> | number
    currency?: StringWithAggregatesFilter<"boost"> | string
    created_at?: DateTimeWithAggregatesFilter<"boost"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"boost"> | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"boost"> | Date | string | null
  }

  export type reportWhereInput = {
    AND?: reportWhereInput | reportWhereInput[]
    OR?: reportWhereInput[]
    NOT?: reportWhereInput | reportWhereInput[]
    id?: StringFilter<"report"> | string
    reporter_user_id?: StringNullableFilter<"report"> | string | null
    target_type?: StringFilter<"report"> | string
    target_id?: StringFilter<"report"> | string
    reason?: Enumreport_reasonFilter<"report"> | $Enums.report_reason
    details?: StringNullableFilter<"report"> | string | null
    severity?: Enumseverity_levelFilter<"report"> | $Enums.severity_level
    status?: Enumreport_statusFilter<"report"> | $Enums.report_status
    resolution_note?: StringNullableFilter<"report"> | string | null
    created_at?: DateTimeFilter<"report"> | Date | string
    updated_at?: DateTimeFilter<"report"> | Date | string
    deleted_at?: DateTimeNullableFilter<"report"> | Date | string | null
    media_target?: XOR<MediaNullableScalarRelationFilter, mediaWhereInput> | null
    profile_target?: XOR<ProfileNullableScalarRelationFilter, profileWhereInput> | null
    reporter_user?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
  }

  export type reportOrderByWithRelationInput = {
    id?: SortOrder
    reporter_user_id?: SortOrder
    target_type?: SortOrder
    target_id?: SortOrder
    reason?: SortOrder
    details?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    resolution_note?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    media_target?: mediaOrderByWithRelationInput
    profile_target?: profileOrderByWithRelationInput
    reporter_user?: userOrderByWithRelationInput
  }

  export type reportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: reportWhereInput | reportWhereInput[]
    OR?: reportWhereInput[]
    NOT?: reportWhereInput | reportWhereInput[]
    reporter_user_id?: StringNullableFilter<"report"> | string | null
    target_type?: StringFilter<"report"> | string
    target_id?: StringFilter<"report"> | string
    reason?: Enumreport_reasonFilter<"report"> | $Enums.report_reason
    details?: StringNullableFilter<"report"> | string | null
    severity?: Enumseverity_levelFilter<"report"> | $Enums.severity_level
    status?: Enumreport_statusFilter<"report"> | $Enums.report_status
    resolution_note?: StringNullableFilter<"report"> | string | null
    created_at?: DateTimeFilter<"report"> | Date | string
    updated_at?: DateTimeFilter<"report"> | Date | string
    deleted_at?: DateTimeNullableFilter<"report"> | Date | string | null
    media_target?: XOR<MediaNullableScalarRelationFilter, mediaWhereInput> | null
    profile_target?: XOR<ProfileNullableScalarRelationFilter, profileWhereInput> | null
    reporter_user?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
  }, "id">

  export type reportOrderByWithAggregationInput = {
    id?: SortOrder
    reporter_user_id?: SortOrder
    target_type?: SortOrder
    target_id?: SortOrder
    reason?: SortOrder
    details?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    resolution_note?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    _count?: reportCountOrderByAggregateInput
    _max?: reportMaxOrderByAggregateInput
    _min?: reportMinOrderByAggregateInput
  }

  export type reportScalarWhereWithAggregatesInput = {
    AND?: reportScalarWhereWithAggregatesInput | reportScalarWhereWithAggregatesInput[]
    OR?: reportScalarWhereWithAggregatesInput[]
    NOT?: reportScalarWhereWithAggregatesInput | reportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"report"> | string
    reporter_user_id?: StringNullableWithAggregatesFilter<"report"> | string | null
    target_type?: StringWithAggregatesFilter<"report"> | string
    target_id?: StringWithAggregatesFilter<"report"> | string
    reason?: Enumreport_reasonWithAggregatesFilter<"report"> | $Enums.report_reason
    details?: StringNullableWithAggregatesFilter<"report"> | string | null
    severity?: Enumseverity_levelWithAggregatesFilter<"report"> | $Enums.severity_level
    status?: Enumreport_statusWithAggregatesFilter<"report"> | $Enums.report_status
    resolution_note?: StringNullableWithAggregatesFilter<"report"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"report"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"report"> | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"report"> | Date | string | null
  }

  export type strikeWhereInput = {
    AND?: strikeWhereInput | strikeWhereInput[]
    OR?: strikeWhereInput[]
    NOT?: strikeWhereInput | strikeWhereInput[]
    id?: StringFilter<"strike"> | string
    player_id?: StringFilter<"strike"> | string
    reason?: StringFilter<"strike"> | string
    severity?: Enumseverity_levelFilter<"strike"> | $Enums.severity_level
    expires_at?: DateTimeNullableFilter<"strike"> | Date | string | null
    status?: Enumsetting_statusFilter<"strike"> | $Enums.setting_status
    created_at?: DateTimeFilter<"strike"> | Date | string
    updated_at?: DateTimeFilter<"strike"> | Date | string
    deleted_at?: DateTimeNullableFilter<"strike"> | Date | string | null
    player?: XOR<ProfileScalarRelationFilter, profileWhereInput>
  }

  export type strikeOrderByWithRelationInput = {
    id?: SortOrder
    player_id?: SortOrder
    reason?: SortOrder
    severity?: SortOrder
    expires_at?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    player?: profileOrderByWithRelationInput
  }

  export type strikeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: strikeWhereInput | strikeWhereInput[]
    OR?: strikeWhereInput[]
    NOT?: strikeWhereInput | strikeWhereInput[]
    player_id?: StringFilter<"strike"> | string
    reason?: StringFilter<"strike"> | string
    severity?: Enumseverity_levelFilter<"strike"> | $Enums.severity_level
    expires_at?: DateTimeNullableFilter<"strike"> | Date | string | null
    status?: Enumsetting_statusFilter<"strike"> | $Enums.setting_status
    created_at?: DateTimeFilter<"strike"> | Date | string
    updated_at?: DateTimeFilter<"strike"> | Date | string
    deleted_at?: DateTimeNullableFilter<"strike"> | Date | string | null
    player?: XOR<ProfileScalarRelationFilter, profileWhereInput>
  }, "id">

  export type strikeOrderByWithAggregationInput = {
    id?: SortOrder
    player_id?: SortOrder
    reason?: SortOrder
    severity?: SortOrder
    expires_at?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    _count?: strikeCountOrderByAggregateInput
    _max?: strikeMaxOrderByAggregateInput
    _min?: strikeMinOrderByAggregateInput
  }

  export type strikeScalarWhereWithAggregatesInput = {
    AND?: strikeScalarWhereWithAggregatesInput | strikeScalarWhereWithAggregatesInput[]
    OR?: strikeScalarWhereWithAggregatesInput[]
    NOT?: strikeScalarWhereWithAggregatesInput | strikeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"strike"> | string
    player_id?: StringWithAggregatesFilter<"strike"> | string
    reason?: StringWithAggregatesFilter<"strike"> | string
    severity?: Enumseverity_levelWithAggregatesFilter<"strike"> | $Enums.severity_level
    expires_at?: DateTimeNullableWithAggregatesFilter<"strike"> | Date | string | null
    status?: Enumsetting_statusWithAggregatesFilter<"strike"> | $Enums.setting_status
    created_at?: DateTimeWithAggregatesFilter<"strike"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"strike"> | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"strike"> | Date | string | null
  }

  export type user_noteWhereInput = {
    AND?: user_noteWhereInput | user_noteWhereInput[]
    OR?: user_noteWhereInput[]
    NOT?: user_noteWhereInput | user_noteWhereInput[]
    id?: StringFilter<"user_note"> | string
    player_id?: StringFilter<"user_note"> | string
    author_id?: StringFilter<"user_note"> | string
    note?: StringFilter<"user_note"> | string
    status?: Enumsetting_statusFilter<"user_note"> | $Enums.setting_status
    created_at?: DateTimeFilter<"user_note"> | Date | string
    updated_at?: DateTimeFilter<"user_note"> | Date | string
    deleted_at?: DateTimeNullableFilter<"user_note"> | Date | string | null
    player?: XOR<ProfileScalarRelationFilter, profileWhereInput>
    author?: XOR<UserScalarRelationFilter, userWhereInput>
  }

  export type user_noteOrderByWithRelationInput = {
    id?: SortOrder
    player_id?: SortOrder
    author_id?: SortOrder
    note?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    player?: profileOrderByWithRelationInput
    author?: userOrderByWithRelationInput
  }

  export type user_noteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: user_noteWhereInput | user_noteWhereInput[]
    OR?: user_noteWhereInput[]
    NOT?: user_noteWhereInput | user_noteWhereInput[]
    player_id?: StringFilter<"user_note"> | string
    author_id?: StringFilter<"user_note"> | string
    note?: StringFilter<"user_note"> | string
    status?: Enumsetting_statusFilter<"user_note"> | $Enums.setting_status
    created_at?: DateTimeFilter<"user_note"> | Date | string
    updated_at?: DateTimeFilter<"user_note"> | Date | string
    deleted_at?: DateTimeNullableFilter<"user_note"> | Date | string | null
    player?: XOR<ProfileScalarRelationFilter, profileWhereInput>
    author?: XOR<UserScalarRelationFilter, userWhereInput>
  }, "id">

  export type user_noteOrderByWithAggregationInput = {
    id?: SortOrder
    player_id?: SortOrder
    author_id?: SortOrder
    note?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    _count?: user_noteCountOrderByAggregateInput
    _max?: user_noteMaxOrderByAggregateInput
    _min?: user_noteMinOrderByAggregateInput
  }

  export type user_noteScalarWhereWithAggregatesInput = {
    AND?: user_noteScalarWhereWithAggregatesInput | user_noteScalarWhereWithAggregatesInput[]
    OR?: user_noteScalarWhereWithAggregatesInput[]
    NOT?: user_noteScalarWhereWithAggregatesInput | user_noteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"user_note"> | string
    player_id?: StringWithAggregatesFilter<"user_note"> | string
    author_id?: StringWithAggregatesFilter<"user_note"> | string
    note?: StringWithAggregatesFilter<"user_note"> | string
    status?: Enumsetting_statusWithAggregatesFilter<"user_note"> | $Enums.setting_status
    created_at?: DateTimeWithAggregatesFilter<"user_note"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"user_note"> | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"user_note"> | Date | string | null
  }

  export type announcementWhereInput = {
    AND?: announcementWhereInput | announcementWhereInput[]
    OR?: announcementWhereInput[]
    NOT?: announcementWhereInput | announcementWhereInput[]
    id?: StringFilter<"announcement"> | string
    title?: StringFilter<"announcement"> | string
    body_md?: StringFilter<"announcement"> | string
    status?: Enumannouncement_statusFilter<"announcement"> | $Enums.announcement_status
    starts_at?: DateTimeNullableFilter<"announcement"> | Date | string | null
    ends_at?: DateTimeNullableFilter<"announcement"> | Date | string | null
    segment_tags?: StringNullableListFilter<"announcement">
    segment_states?: StringNullableListFilter<"announcement">
    segment_devices?: StringNullableListFilter<"announcement">
    created_at?: DateTimeFilter<"announcement"> | Date | string
    updated_at?: DateTimeFilter<"announcement"> | Date | string
    deleted_at?: DateTimeNullableFilter<"announcement"> | Date | string | null
  }

  export type announcementOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    body_md?: SortOrder
    status?: SortOrder
    starts_at?: SortOrder
    ends_at?: SortOrder
    segment_tags?: SortOrder
    segment_states?: SortOrder
    segment_devices?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type announcementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: announcementWhereInput | announcementWhereInput[]
    OR?: announcementWhereInput[]
    NOT?: announcementWhereInput | announcementWhereInput[]
    title?: StringFilter<"announcement"> | string
    body_md?: StringFilter<"announcement"> | string
    status?: Enumannouncement_statusFilter<"announcement"> | $Enums.announcement_status
    starts_at?: DateTimeNullableFilter<"announcement"> | Date | string | null
    ends_at?: DateTimeNullableFilter<"announcement"> | Date | string | null
    segment_tags?: StringNullableListFilter<"announcement">
    segment_states?: StringNullableListFilter<"announcement">
    segment_devices?: StringNullableListFilter<"announcement">
    created_at?: DateTimeFilter<"announcement"> | Date | string
    updated_at?: DateTimeFilter<"announcement"> | Date | string
    deleted_at?: DateTimeNullableFilter<"announcement"> | Date | string | null
  }, "id">

  export type announcementOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    body_md?: SortOrder
    status?: SortOrder
    starts_at?: SortOrder
    ends_at?: SortOrder
    segment_tags?: SortOrder
    segment_states?: SortOrder
    segment_devices?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    _count?: announcementCountOrderByAggregateInput
    _max?: announcementMaxOrderByAggregateInput
    _min?: announcementMinOrderByAggregateInput
  }

  export type announcementScalarWhereWithAggregatesInput = {
    AND?: announcementScalarWhereWithAggregatesInput | announcementScalarWhereWithAggregatesInput[]
    OR?: announcementScalarWhereWithAggregatesInput[]
    NOT?: announcementScalarWhereWithAggregatesInput | announcementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"announcement"> | string
    title?: StringWithAggregatesFilter<"announcement"> | string
    body_md?: StringWithAggregatesFilter<"announcement"> | string
    status?: Enumannouncement_statusWithAggregatesFilter<"announcement"> | $Enums.announcement_status
    starts_at?: DateTimeNullableWithAggregatesFilter<"announcement"> | Date | string | null
    ends_at?: DateTimeNullableWithAggregatesFilter<"announcement"> | Date | string | null
    segment_tags?: StringNullableListFilter<"announcement">
    segment_states?: StringNullableListFilter<"announcement">
    segment_devices?: StringNullableListFilter<"announcement">
    created_at?: DateTimeWithAggregatesFilter<"announcement"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"announcement"> | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"announcement"> | Date | string | null
  }

  export type feature_slotWhereInput = {
    AND?: feature_slotWhereInput | feature_slotWhereInput[]
    OR?: feature_slotWhereInput[]
    NOT?: feature_slotWhereInput | feature_slotWhereInput[]
    id?: StringFilter<"feature_slot"> | string
    slot_key?: Enumfeature_slot_keyFilter<"feature_slot"> | $Enums.feature_slot_key
    description?: StringNullableFilter<"feature_slot"> | string | null
    status?: Enumsetting_statusFilter<"feature_slot"> | $Enums.setting_status
    created_at?: DateTimeFilter<"feature_slot"> | Date | string
    updated_at?: DateTimeFilter<"feature_slot"> | Date | string
    deleted_at?: DateTimeNullableFilter<"feature_slot"> | Date | string | null
  }

  export type feature_slotOrderByWithRelationInput = {
    id?: SortOrder
    slot_key?: SortOrder
    description?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type feature_slotWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slot_key?: $Enums.feature_slot_key
    AND?: feature_slotWhereInput | feature_slotWhereInput[]
    OR?: feature_slotWhereInput[]
    NOT?: feature_slotWhereInput | feature_slotWhereInput[]
    description?: StringNullableFilter<"feature_slot"> | string | null
    status?: Enumsetting_statusFilter<"feature_slot"> | $Enums.setting_status
    created_at?: DateTimeFilter<"feature_slot"> | Date | string
    updated_at?: DateTimeFilter<"feature_slot"> | Date | string
    deleted_at?: DateTimeNullableFilter<"feature_slot"> | Date | string | null
  }, "id" | "slot_key">

  export type feature_slotOrderByWithAggregationInput = {
    id?: SortOrder
    slot_key?: SortOrder
    description?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    _count?: feature_slotCountOrderByAggregateInput
    _max?: feature_slotMaxOrderByAggregateInput
    _min?: feature_slotMinOrderByAggregateInput
  }

  export type feature_slotScalarWhereWithAggregatesInput = {
    AND?: feature_slotScalarWhereWithAggregatesInput | feature_slotScalarWhereWithAggregatesInput[]
    OR?: feature_slotScalarWhereWithAggregatesInput[]
    NOT?: feature_slotScalarWhereWithAggregatesInput | feature_slotScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"feature_slot"> | string
    slot_key?: Enumfeature_slot_keyWithAggregatesFilter<"feature_slot"> | $Enums.feature_slot_key
    description?: StringNullableWithAggregatesFilter<"feature_slot"> | string | null
    status?: Enumsetting_statusWithAggregatesFilter<"feature_slot"> | $Enums.setting_status
    created_at?: DateTimeWithAggregatesFilter<"feature_slot"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"feature_slot"> | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"feature_slot"> | Date | string | null
  }

  export type featured_assignmentWhereInput = {
    AND?: featured_assignmentWhereInput | featured_assignmentWhereInput[]
    OR?: featured_assignmentWhereInput[]
    NOT?: featured_assignmentWhereInput | featured_assignmentWhereInput[]
    id?: StringFilter<"featured_assignment"> | string
    slot_key?: Enumfeature_slot_keyFilter<"featured_assignment"> | $Enums.feature_slot_key
    player_id?: StringFilter<"featured_assignment"> | string
    media_id?: StringNullableFilter<"featured_assignment"> | string | null
    starts_at?: DateTimeFilter<"featured_assignment"> | Date | string
    ends_at?: DateTimeFilter<"featured_assignment"> | Date | string
    priority?: IntFilter<"featured_assignment"> | number
    status?: Enumsetting_statusFilter<"featured_assignment"> | $Enums.setting_status
    created_at?: DateTimeFilter<"featured_assignment"> | Date | string
    updated_at?: DateTimeFilter<"featured_assignment"> | Date | string
    deleted_at?: DateTimeNullableFilter<"featured_assignment"> | Date | string | null
    player?: XOR<ProfileScalarRelationFilter, profileWhereInput>
    media_ref?: XOR<MediaNullableScalarRelationFilter, mediaWhereInput> | null
  }

  export type featured_assignmentOrderByWithRelationInput = {
    id?: SortOrder
    slot_key?: SortOrder
    player_id?: SortOrder
    media_id?: SortOrder
    starts_at?: SortOrder
    ends_at?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    player?: profileOrderByWithRelationInput
    media_ref?: mediaOrderByWithRelationInput
  }

  export type featured_assignmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: featured_assignmentWhereInput | featured_assignmentWhereInput[]
    OR?: featured_assignmentWhereInput[]
    NOT?: featured_assignmentWhereInput | featured_assignmentWhereInput[]
    slot_key?: Enumfeature_slot_keyFilter<"featured_assignment"> | $Enums.feature_slot_key
    player_id?: StringFilter<"featured_assignment"> | string
    media_id?: StringNullableFilter<"featured_assignment"> | string | null
    starts_at?: DateTimeFilter<"featured_assignment"> | Date | string
    ends_at?: DateTimeFilter<"featured_assignment"> | Date | string
    priority?: IntFilter<"featured_assignment"> | number
    status?: Enumsetting_statusFilter<"featured_assignment"> | $Enums.setting_status
    created_at?: DateTimeFilter<"featured_assignment"> | Date | string
    updated_at?: DateTimeFilter<"featured_assignment"> | Date | string
    deleted_at?: DateTimeNullableFilter<"featured_assignment"> | Date | string | null
    player?: XOR<ProfileScalarRelationFilter, profileWhereInput>
    media_ref?: XOR<MediaNullableScalarRelationFilter, mediaWhereInput> | null
  }, "id">

  export type featured_assignmentOrderByWithAggregationInput = {
    id?: SortOrder
    slot_key?: SortOrder
    player_id?: SortOrder
    media_id?: SortOrder
    starts_at?: SortOrder
    ends_at?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    _count?: featured_assignmentCountOrderByAggregateInput
    _avg?: featured_assignmentAvgOrderByAggregateInput
    _max?: featured_assignmentMaxOrderByAggregateInput
    _min?: featured_assignmentMinOrderByAggregateInput
    _sum?: featured_assignmentSumOrderByAggregateInput
  }

  export type featured_assignmentScalarWhereWithAggregatesInput = {
    AND?: featured_assignmentScalarWhereWithAggregatesInput | featured_assignmentScalarWhereWithAggregatesInput[]
    OR?: featured_assignmentScalarWhereWithAggregatesInput[]
    NOT?: featured_assignmentScalarWhereWithAggregatesInput | featured_assignmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"featured_assignment"> | string
    slot_key?: Enumfeature_slot_keyWithAggregatesFilter<"featured_assignment"> | $Enums.feature_slot_key
    player_id?: StringWithAggregatesFilter<"featured_assignment"> | string
    media_id?: StringNullableWithAggregatesFilter<"featured_assignment"> | string | null
    starts_at?: DateTimeWithAggregatesFilter<"featured_assignment"> | Date | string
    ends_at?: DateTimeWithAggregatesFilter<"featured_assignment"> | Date | string
    priority?: IntWithAggregatesFilter<"featured_assignment"> | number
    status?: Enumsetting_statusWithAggregatesFilter<"featured_assignment"> | $Enums.setting_status
    created_at?: DateTimeWithAggregatesFilter<"featured_assignment"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"featured_assignment"> | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"featured_assignment"> | Date | string | null
  }

  export type settingWhereInput = {
    AND?: settingWhereInput | settingWhereInput[]
    OR?: settingWhereInput[]
    NOT?: settingWhereInput | settingWhereInput[]
    id?: StringFilter<"setting"> | string
    key?: StringFilter<"setting"> | string
    value_json?: JsonFilter<"setting">
    status?: Enumsetting_statusFilter<"setting"> | $Enums.setting_status
    version?: IntFilter<"setting"> | number
    created_at?: DateTimeFilter<"setting"> | Date | string
    updated_at?: DateTimeFilter<"setting"> | Date | string
    deleted_at?: DateTimeNullableFilter<"setting"> | Date | string | null
  }

  export type settingOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    value_json?: SortOrder
    status?: SortOrder
    version?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type settingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    key?: string
    AND?: settingWhereInput | settingWhereInput[]
    OR?: settingWhereInput[]
    NOT?: settingWhereInput | settingWhereInput[]
    value_json?: JsonFilter<"setting">
    status?: Enumsetting_statusFilter<"setting"> | $Enums.setting_status
    version?: IntFilter<"setting"> | number
    created_at?: DateTimeFilter<"setting"> | Date | string
    updated_at?: DateTimeFilter<"setting"> | Date | string
    deleted_at?: DateTimeNullableFilter<"setting"> | Date | string | null
  }, "id" | "key">

  export type settingOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    value_json?: SortOrder
    status?: SortOrder
    version?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    _count?: settingCountOrderByAggregateInput
    _avg?: settingAvgOrderByAggregateInput
    _max?: settingMaxOrderByAggregateInput
    _min?: settingMinOrderByAggregateInput
    _sum?: settingSumOrderByAggregateInput
  }

  export type settingScalarWhereWithAggregatesInput = {
    AND?: settingScalarWhereWithAggregatesInput | settingScalarWhereWithAggregatesInput[]
    OR?: settingScalarWhereWithAggregatesInput[]
    NOT?: settingScalarWhereWithAggregatesInput | settingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"setting"> | string
    key?: StringWithAggregatesFilter<"setting"> | string
    value_json?: JsonWithAggregatesFilter<"setting">
    status?: Enumsetting_statusWithAggregatesFilter<"setting"> | $Enums.setting_status
    version?: IntWithAggregatesFilter<"setting"> | number
    created_at?: DateTimeWithAggregatesFilter<"setting"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"setting"> | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"setting"> | Date | string | null
  }

  export type support_ticketWhereInput = {
    AND?: support_ticketWhereInput | support_ticketWhereInput[]
    OR?: support_ticketWhereInput[]
    NOT?: support_ticketWhereInput | support_ticketWhereInput[]
    id?: StringFilter<"support_ticket"> | string
    user_id?: StringNullableFilter<"support_ticket"> | string | null
    email?: StringNullableFilter<"support_ticket"> | string | null
    subject?: StringFilter<"support_ticket"> | string
    message?: StringFilter<"support_ticket"> | string
    priority?: Enumticket_priorityFilter<"support_ticket"> | $Enums.ticket_priority
    status?: Enumticket_statusFilter<"support_ticket"> | $Enums.ticket_status
    assigned_to?: StringNullableFilter<"support_ticket"> | string | null
    created_at?: DateTimeFilter<"support_ticket"> | Date | string
    updated_at?: DateTimeFilter<"support_ticket"> | Date | string
    deleted_at?: DateTimeNullableFilter<"support_ticket"> | Date | string | null
    user?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
    assignee?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
  }

  export type support_ticketOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    email?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    assigned_to?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    user?: userOrderByWithRelationInput
    assignee?: userOrderByWithRelationInput
  }

  export type support_ticketWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: support_ticketWhereInput | support_ticketWhereInput[]
    OR?: support_ticketWhereInput[]
    NOT?: support_ticketWhereInput | support_ticketWhereInput[]
    user_id?: StringNullableFilter<"support_ticket"> | string | null
    email?: StringNullableFilter<"support_ticket"> | string | null
    subject?: StringFilter<"support_ticket"> | string
    message?: StringFilter<"support_ticket"> | string
    priority?: Enumticket_priorityFilter<"support_ticket"> | $Enums.ticket_priority
    status?: Enumticket_statusFilter<"support_ticket"> | $Enums.ticket_status
    assigned_to?: StringNullableFilter<"support_ticket"> | string | null
    created_at?: DateTimeFilter<"support_ticket"> | Date | string
    updated_at?: DateTimeFilter<"support_ticket"> | Date | string
    deleted_at?: DateTimeNullableFilter<"support_ticket"> | Date | string | null
    user?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
    assignee?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
  }, "id">

  export type support_ticketOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    email?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    assigned_to?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    _count?: support_ticketCountOrderByAggregateInput
    _max?: support_ticketMaxOrderByAggregateInput
    _min?: support_ticketMinOrderByAggregateInput
  }

  export type support_ticketScalarWhereWithAggregatesInput = {
    AND?: support_ticketScalarWhereWithAggregatesInput | support_ticketScalarWhereWithAggregatesInput[]
    OR?: support_ticketScalarWhereWithAggregatesInput[]
    NOT?: support_ticketScalarWhereWithAggregatesInput | support_ticketScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"support_ticket"> | string
    user_id?: StringNullableWithAggregatesFilter<"support_ticket"> | string | null
    email?: StringNullableWithAggregatesFilter<"support_ticket"> | string | null
    subject?: StringWithAggregatesFilter<"support_ticket"> | string
    message?: StringWithAggregatesFilter<"support_ticket"> | string
    priority?: Enumticket_priorityWithAggregatesFilter<"support_ticket"> | $Enums.ticket_priority
    status?: Enumticket_statusWithAggregatesFilter<"support_ticket"> | $Enums.ticket_status
    assigned_to?: StringNullableWithAggregatesFilter<"support_ticket"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"support_ticket"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"support_ticket"> | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"support_ticket"> | Date | string | null
  }

  export type contact_eventWhereInput = {
    AND?: contact_eventWhereInput | contact_eventWhereInput[]
    OR?: contact_eventWhereInput[]
    NOT?: contact_eventWhereInput | contact_eventWhereInput[]
    id?: StringFilter<"contact_event"> | string
    player_id?: StringFilter<"contact_event"> | string
    channel?: Enumcontact_channelFilter<"contact_event"> | $Enums.contact_channel
    requester_ip?: StringNullableFilter<"contact_event"> | string | null
    user_agent?: StringNullableFilter<"contact_event"> | string | null
    referrer?: StringNullableFilter<"contact_event"> | string | null
    message?: StringNullableFilter<"contact_event"> | string | null
    status?: Enumsetting_statusFilter<"contact_event"> | $Enums.setting_status
    created_at?: DateTimeFilter<"contact_event"> | Date | string
    updated_at?: DateTimeFilter<"contact_event"> | Date | string
    deleted_at?: DateTimeNullableFilter<"contact_event"> | Date | string | null
    player?: XOR<ProfileScalarRelationFilter, profileWhereInput>
  }

  export type contact_eventOrderByWithRelationInput = {
    id?: SortOrder
    player_id?: SortOrder
    channel?: SortOrder
    requester_ip?: SortOrder
    user_agent?: SortOrder
    referrer?: SortOrder
    message?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    player?: profileOrderByWithRelationInput
  }

  export type contact_eventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: contact_eventWhereInput | contact_eventWhereInput[]
    OR?: contact_eventWhereInput[]
    NOT?: contact_eventWhereInput | contact_eventWhereInput[]
    player_id?: StringFilter<"contact_event"> | string
    channel?: Enumcontact_channelFilter<"contact_event"> | $Enums.contact_channel
    requester_ip?: StringNullableFilter<"contact_event"> | string | null
    user_agent?: StringNullableFilter<"contact_event"> | string | null
    referrer?: StringNullableFilter<"contact_event"> | string | null
    message?: StringNullableFilter<"contact_event"> | string | null
    status?: Enumsetting_statusFilter<"contact_event"> | $Enums.setting_status
    created_at?: DateTimeFilter<"contact_event"> | Date | string
    updated_at?: DateTimeFilter<"contact_event"> | Date | string
    deleted_at?: DateTimeNullableFilter<"contact_event"> | Date | string | null
    player?: XOR<ProfileScalarRelationFilter, profileWhereInput>
  }, "id">

  export type contact_eventOrderByWithAggregationInput = {
    id?: SortOrder
    player_id?: SortOrder
    channel?: SortOrder
    requester_ip?: SortOrder
    user_agent?: SortOrder
    referrer?: SortOrder
    message?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    _count?: contact_eventCountOrderByAggregateInput
    _max?: contact_eventMaxOrderByAggregateInput
    _min?: contact_eventMinOrderByAggregateInput
  }

  export type contact_eventScalarWhereWithAggregatesInput = {
    AND?: contact_eventScalarWhereWithAggregatesInput | contact_eventScalarWhereWithAggregatesInput[]
    OR?: contact_eventScalarWhereWithAggregatesInput[]
    NOT?: contact_eventScalarWhereWithAggregatesInput | contact_eventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"contact_event"> | string
    player_id?: StringWithAggregatesFilter<"contact_event"> | string
    channel?: Enumcontact_channelWithAggregatesFilter<"contact_event"> | $Enums.contact_channel
    requester_ip?: StringNullableWithAggregatesFilter<"contact_event"> | string | null
    user_agent?: StringNullableWithAggregatesFilter<"contact_event"> | string | null
    referrer?: StringNullableWithAggregatesFilter<"contact_event"> | string | null
    message?: StringNullableWithAggregatesFilter<"contact_event"> | string | null
    status?: Enumsetting_statusWithAggregatesFilter<"contact_event"> | $Enums.setting_status
    created_at?: DateTimeWithAggregatesFilter<"contact_event"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"contact_event"> | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"contact_event"> | Date | string | null
  }

  export type audit_logWhereInput = {
    AND?: audit_logWhereInput | audit_logWhereInput[]
    OR?: audit_logWhereInput[]
    NOT?: audit_logWhereInput | audit_logWhereInput[]
    id?: StringFilter<"audit_log"> | string
    actor_user_id?: StringNullableFilter<"audit_log"> | string | null
    actor_role?: Enumuser_roleNullableFilter<"audit_log"> | $Enums.user_role | null
    entity_type?: StringFilter<"audit_log"> | string
    entity_id?: StringFilter<"audit_log"> | string
    action?: StringFilter<"audit_log"> | string
    payload?: JsonNullableFilter<"audit_log">
    status?: Enumaudit_statusFilter<"audit_log"> | $Enums.audit_status
    created_at?: DateTimeFilter<"audit_log"> | Date | string
    updated_at?: DateTimeFilter<"audit_log"> | Date | string
    deleted_at?: DateTimeNullableFilter<"audit_log"> | Date | string | null
  }

  export type audit_logOrderByWithRelationInput = {
    id?: SortOrder
    actor_user_id?: SortOrder
    actor_role?: SortOrder
    entity_type?: SortOrder
    entity_id?: SortOrder
    action?: SortOrder
    payload?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type audit_logWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: audit_logWhereInput | audit_logWhereInput[]
    OR?: audit_logWhereInput[]
    NOT?: audit_logWhereInput | audit_logWhereInput[]
    actor_user_id?: StringNullableFilter<"audit_log"> | string | null
    actor_role?: Enumuser_roleNullableFilter<"audit_log"> | $Enums.user_role | null
    entity_type?: StringFilter<"audit_log"> | string
    entity_id?: StringFilter<"audit_log"> | string
    action?: StringFilter<"audit_log"> | string
    payload?: JsonNullableFilter<"audit_log">
    status?: Enumaudit_statusFilter<"audit_log"> | $Enums.audit_status
    created_at?: DateTimeFilter<"audit_log"> | Date | string
    updated_at?: DateTimeFilter<"audit_log"> | Date | string
    deleted_at?: DateTimeNullableFilter<"audit_log"> | Date | string | null
  }, "id">

  export type audit_logOrderByWithAggregationInput = {
    id?: SortOrder
    actor_user_id?: SortOrder
    actor_role?: SortOrder
    entity_type?: SortOrder
    entity_id?: SortOrder
    action?: SortOrder
    payload?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    _count?: audit_logCountOrderByAggregateInput
    _max?: audit_logMaxOrderByAggregateInput
    _min?: audit_logMinOrderByAggregateInput
  }

  export type audit_logScalarWhereWithAggregatesInput = {
    AND?: audit_logScalarWhereWithAggregatesInput | audit_logScalarWhereWithAggregatesInput[]
    OR?: audit_logScalarWhereWithAggregatesInput[]
    NOT?: audit_logScalarWhereWithAggregatesInput | audit_logScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"audit_log"> | string
    actor_user_id?: StringNullableWithAggregatesFilter<"audit_log"> | string | null
    actor_role?: Enumuser_roleNullableWithAggregatesFilter<"audit_log"> | $Enums.user_role | null
    entity_type?: StringWithAggregatesFilter<"audit_log"> | string
    entity_id?: StringWithAggregatesFilter<"audit_log"> | string
    action?: StringWithAggregatesFilter<"audit_log"> | string
    payload?: JsonNullableWithAggregatesFilter<"audit_log">
    status?: Enumaudit_statusWithAggregatesFilter<"audit_log"> | $Enums.audit_status
    created_at?: DateTimeWithAggregatesFilter<"audit_log"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"audit_log"> | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"audit_log"> | Date | string | null
  }

  export type webhook_eventWhereInput = {
    AND?: webhook_eventWhereInput | webhook_eventWhereInput[]
    OR?: webhook_eventWhereInput[]
    NOT?: webhook_eventWhereInput | webhook_eventWhereInput[]
    id?: StringFilter<"webhook_event"> | string
    provider?: Enumprovider_kindFilter<"webhook_event"> | $Enums.provider_kind
    event_type?: StringFilter<"webhook_event"> | string
    payload?: JsonFilter<"webhook_event">
    related_type?: StringNullableFilter<"webhook_event"> | string | null
    related_id?: StringNullableFilter<"webhook_event"> | string | null
    status?: Enumwebhook_statusFilter<"webhook_event"> | $Enums.webhook_status
    retry_count?: IntFilter<"webhook_event"> | number
    last_error?: StringNullableFilter<"webhook_event"> | string | null
    next_retry_at?: DateTimeNullableFilter<"webhook_event"> | Date | string | null
    created_at?: DateTimeFilter<"webhook_event"> | Date | string
    updated_at?: DateTimeFilter<"webhook_event"> | Date | string
    deleted_at?: DateTimeNullableFilter<"webhook_event"> | Date | string | null
  }

  export type webhook_eventOrderByWithRelationInput = {
    id?: SortOrder
    provider?: SortOrder
    event_type?: SortOrder
    payload?: SortOrder
    related_type?: SortOrder
    related_id?: SortOrder
    status?: SortOrder
    retry_count?: SortOrder
    last_error?: SortOrder
    next_retry_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type webhook_eventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: webhook_eventWhereInput | webhook_eventWhereInput[]
    OR?: webhook_eventWhereInput[]
    NOT?: webhook_eventWhereInput | webhook_eventWhereInput[]
    provider?: Enumprovider_kindFilter<"webhook_event"> | $Enums.provider_kind
    event_type?: StringFilter<"webhook_event"> | string
    payload?: JsonFilter<"webhook_event">
    related_type?: StringNullableFilter<"webhook_event"> | string | null
    related_id?: StringNullableFilter<"webhook_event"> | string | null
    status?: Enumwebhook_statusFilter<"webhook_event"> | $Enums.webhook_status
    retry_count?: IntFilter<"webhook_event"> | number
    last_error?: StringNullableFilter<"webhook_event"> | string | null
    next_retry_at?: DateTimeNullableFilter<"webhook_event"> | Date | string | null
    created_at?: DateTimeFilter<"webhook_event"> | Date | string
    updated_at?: DateTimeFilter<"webhook_event"> | Date | string
    deleted_at?: DateTimeNullableFilter<"webhook_event"> | Date | string | null
  }, "id">

  export type webhook_eventOrderByWithAggregationInput = {
    id?: SortOrder
    provider?: SortOrder
    event_type?: SortOrder
    payload?: SortOrder
    related_type?: SortOrder
    related_id?: SortOrder
    status?: SortOrder
    retry_count?: SortOrder
    last_error?: SortOrder
    next_retry_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    _count?: webhook_eventCountOrderByAggregateInput
    _avg?: webhook_eventAvgOrderByAggregateInput
    _max?: webhook_eventMaxOrderByAggregateInput
    _min?: webhook_eventMinOrderByAggregateInput
    _sum?: webhook_eventSumOrderByAggregateInput
  }

  export type webhook_eventScalarWhereWithAggregatesInput = {
    AND?: webhook_eventScalarWhereWithAggregatesInput | webhook_eventScalarWhereWithAggregatesInput[]
    OR?: webhook_eventScalarWhereWithAggregatesInput[]
    NOT?: webhook_eventScalarWhereWithAggregatesInput | webhook_eventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"webhook_event"> | string
    provider?: Enumprovider_kindWithAggregatesFilter<"webhook_event"> | $Enums.provider_kind
    event_type?: StringWithAggregatesFilter<"webhook_event"> | string
    payload?: JsonWithAggregatesFilter<"webhook_event">
    related_type?: StringNullableWithAggregatesFilter<"webhook_event"> | string | null
    related_id?: StringNullableWithAggregatesFilter<"webhook_event"> | string | null
    status?: Enumwebhook_statusWithAggregatesFilter<"webhook_event"> | $Enums.webhook_status
    retry_count?: IntWithAggregatesFilter<"webhook_event"> | number
    last_error?: StringNullableWithAggregatesFilter<"webhook_event"> | string | null
    next_retry_at?: DateTimeNullableWithAggregatesFilter<"webhook_event"> | Date | string | null
    created_at?: DateTimeWithAggregatesFilter<"webhook_event"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"webhook_event"> | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"webhook_event"> | Date | string | null
  }

  export type sessionWhereInput = {
    AND?: sessionWhereInput | sessionWhereInput[]
    OR?: sessionWhereInput[]
    NOT?: sessionWhereInput | sessionWhereInput[]
    id?: StringFilter<"session"> | string
    user_id?: StringFilter<"session"> | string
    session_token?: StringFilter<"session"> | string
    ip?: StringNullableFilter<"session"> | string | null
    user_agent?: StringNullableFilter<"session"> | string | null
    expires_at?: DateTimeFilter<"session"> | Date | string
    status?: Enumsetting_statusFilter<"session"> | $Enums.setting_status
    created_at?: DateTimeFilter<"session"> | Date | string
    updated_at?: DateTimeFilter<"session"> | Date | string
    deleted_at?: DateTimeNullableFilter<"session"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }

  export type sessionOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    session_token?: SortOrder
    ip?: SortOrder
    user_agent?: SortOrder
    expires_at?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    user?: userOrderByWithRelationInput
  }

  export type sessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    session_token?: string
    AND?: sessionWhereInput | sessionWhereInput[]
    OR?: sessionWhereInput[]
    NOT?: sessionWhereInput | sessionWhereInput[]
    user_id?: StringFilter<"session"> | string
    ip?: StringNullableFilter<"session"> | string | null
    user_agent?: StringNullableFilter<"session"> | string | null
    expires_at?: DateTimeFilter<"session"> | Date | string
    status?: Enumsetting_statusFilter<"session"> | $Enums.setting_status
    created_at?: DateTimeFilter<"session"> | Date | string
    updated_at?: DateTimeFilter<"session"> | Date | string
    deleted_at?: DateTimeNullableFilter<"session"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }, "id" | "session_token">

  export type sessionOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    session_token?: SortOrder
    ip?: SortOrder
    user_agent?: SortOrder
    expires_at?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    _count?: sessionCountOrderByAggregateInput
    _max?: sessionMaxOrderByAggregateInput
    _min?: sessionMinOrderByAggregateInput
  }

  export type sessionScalarWhereWithAggregatesInput = {
    AND?: sessionScalarWhereWithAggregatesInput | sessionScalarWhereWithAggregatesInput[]
    OR?: sessionScalarWhereWithAggregatesInput[]
    NOT?: sessionScalarWhereWithAggregatesInput | sessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"session"> | string
    user_id?: StringWithAggregatesFilter<"session"> | string
    session_token?: StringWithAggregatesFilter<"session"> | string
    ip?: StringNullableWithAggregatesFilter<"session"> | string | null
    user_agent?: StringNullableWithAggregatesFilter<"session"> | string | null
    expires_at?: DateTimeWithAggregatesFilter<"session"> | Date | string
    status?: Enumsetting_statusWithAggregatesFilter<"session"> | $Enums.setting_status
    created_at?: DateTimeWithAggregatesFilter<"session"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"session"> | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"session"> | Date | string | null
  }

  export type userCreateInput = {
    id?: string
    email: string
    password_hash: string
    role?: $Enums.user_role
    status?: $Enums.user_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    profile?: profileCreateNestedOneWithoutUserInput
    tickets?: support_ticketCreateNestedManyWithoutUserInput
    assigned_tickets?: support_ticketCreateNestedManyWithoutAssigneeInput
    reports_made?: reportCreateNestedManyWithoutReporter_userInput
    notes_authored?: user_noteCreateNestedManyWithoutAuthorInput
    sessions?: sessionCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateInput = {
    id?: string
    email: string
    password_hash: string
    role?: $Enums.user_role
    status?: $Enums.user_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    profile?: profileUncheckedCreateNestedOneWithoutUserInput
    tickets?: support_ticketUncheckedCreateNestedManyWithoutUserInput
    assigned_tickets?: support_ticketUncheckedCreateNestedManyWithoutAssigneeInput
    reports_made?: reportUncheckedCreateNestedManyWithoutReporter_userInput
    notes_authored?: user_noteUncheckedCreateNestedManyWithoutAuthorInput
    sessions?: sessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type userUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: Enumuser_roleFieldUpdateOperationsInput | $Enums.user_role
    status?: Enumuser_statusFieldUpdateOperationsInput | $Enums.user_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: profileUpdateOneWithoutUserNestedInput
    tickets?: support_ticketUpdateManyWithoutUserNestedInput
    assigned_tickets?: support_ticketUpdateManyWithoutAssigneeNestedInput
    reports_made?: reportUpdateManyWithoutReporter_userNestedInput
    notes_authored?: user_noteUpdateManyWithoutAuthorNestedInput
    sessions?: sessionUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: Enumuser_roleFieldUpdateOperationsInput | $Enums.user_role
    status?: Enumuser_statusFieldUpdateOperationsInput | $Enums.user_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: profileUncheckedUpdateOneWithoutUserNestedInput
    tickets?: support_ticketUncheckedUpdateManyWithoutUserNestedInput
    assigned_tickets?: support_ticketUncheckedUpdateManyWithoutAssigneeNestedInput
    reports_made?: reportUncheckedUpdateManyWithoutReporter_userNestedInput
    notes_authored?: user_noteUncheckedUpdateManyWithoutAuthorNestedInput
    sessions?: sessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateManyInput = {
    id?: string
    email: string
    password_hash: string
    role?: $Enums.user_role
    status?: $Enums.user_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type userUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: Enumuser_roleFieldUpdateOperationsInput | $Enums.user_role
    status?: Enumuser_statusFieldUpdateOperationsInput | $Enums.user_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userUncheckedUpdateManyInput = {
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: Enumuser_roleFieldUpdateOperationsInput | $Enums.user_role
    status?: Enumuser_statusFieldUpdateOperationsInput | $Enums.user_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type profileCreateInput = {
    id?: string
    username: string
    display_name: string
    bio?: string | null
    avatar_url?: string | null
    state: string
    city: string
    city_slug?: string | null
    contact_email?: string | null
    whatsapp?: string | null
    twitch?: string | null
    youtube?: string | null
    instagram?: string | null
    featured_media_id?: string | null
    tags_count?: number | null
    status?: $Enums.profile_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    user: userCreateNestedOneWithoutProfileInput
    media?: mediaCreateNestedManyWithoutPlayerInput
    boosts?: boostCreateNestedManyWithoutPlayerInput
    strikes?: strikeCreateNestedManyWithoutPlayerInput
    notes?: user_noteCreateNestedManyWithoutPlayerInput
    contact_events?: contact_eventCreateNestedManyWithoutPlayerInput
    reports_against?: reportCreateNestedManyWithoutProfile_targetInput
    player_tags?: player_tagCreateNestedManyWithoutPlayerInput
    featured_assignments?: featured_assignmentCreateNestedManyWithoutPlayerInput
  }

  export type profileUncheckedCreateInput = {
    id?: string
    user_id: string
    username: string
    display_name: string
    bio?: string | null
    avatar_url?: string | null
    state: string
    city: string
    city_slug?: string | null
    contact_email?: string | null
    whatsapp?: string | null
    twitch?: string | null
    youtube?: string | null
    instagram?: string | null
    featured_media_id?: string | null
    tags_count?: number | null
    status?: $Enums.profile_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    media?: mediaUncheckedCreateNestedManyWithoutPlayerInput
    boosts?: boostUncheckedCreateNestedManyWithoutPlayerInput
    strikes?: strikeUncheckedCreateNestedManyWithoutPlayerInput
    notes?: user_noteUncheckedCreateNestedManyWithoutPlayerInput
    contact_events?: contact_eventUncheckedCreateNestedManyWithoutPlayerInput
    reports_against?: reportUncheckedCreateNestedManyWithoutProfile_targetInput
    player_tags?: player_tagUncheckedCreateNestedManyWithoutPlayerInput
    featured_assignments?: featured_assignmentUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type profileUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    display_name?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    city_slug?: NullableStringFieldUpdateOperationsInput | string | null
    contact_email?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    twitch?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    featured_media_id?: NullableStringFieldUpdateOperationsInput | string | null
    tags_count?: NullableIntFieldUpdateOperationsInput | number | null
    status?: Enumprofile_statusFieldUpdateOperationsInput | $Enums.profile_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneRequiredWithoutProfileNestedInput
    media?: mediaUpdateManyWithoutPlayerNestedInput
    boosts?: boostUpdateManyWithoutPlayerNestedInput
    strikes?: strikeUpdateManyWithoutPlayerNestedInput
    notes?: user_noteUpdateManyWithoutPlayerNestedInput
    contact_events?: contact_eventUpdateManyWithoutPlayerNestedInput
    reports_against?: reportUpdateManyWithoutProfile_targetNestedInput
    player_tags?: player_tagUpdateManyWithoutPlayerNestedInput
    featured_assignments?: featured_assignmentUpdateManyWithoutPlayerNestedInput
  }

  export type profileUncheckedUpdateInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    display_name?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    city_slug?: NullableStringFieldUpdateOperationsInput | string | null
    contact_email?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    twitch?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    featured_media_id?: NullableStringFieldUpdateOperationsInput | string | null
    tags_count?: NullableIntFieldUpdateOperationsInput | number | null
    status?: Enumprofile_statusFieldUpdateOperationsInput | $Enums.profile_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    media?: mediaUncheckedUpdateManyWithoutPlayerNestedInput
    boosts?: boostUncheckedUpdateManyWithoutPlayerNestedInput
    strikes?: strikeUncheckedUpdateManyWithoutPlayerNestedInput
    notes?: user_noteUncheckedUpdateManyWithoutPlayerNestedInput
    contact_events?: contact_eventUncheckedUpdateManyWithoutPlayerNestedInput
    reports_against?: reportUncheckedUpdateManyWithoutProfile_targetNestedInput
    player_tags?: player_tagUncheckedUpdateManyWithoutPlayerNestedInput
    featured_assignments?: featured_assignmentUncheckedUpdateManyWithoutPlayerNestedInput
  }

  export type profileCreateManyInput = {
    id?: string
    user_id: string
    username: string
    display_name: string
    bio?: string | null
    avatar_url?: string | null
    state: string
    city: string
    city_slug?: string | null
    contact_email?: string | null
    whatsapp?: string | null
    twitch?: string | null
    youtube?: string | null
    instagram?: string | null
    featured_media_id?: string | null
    tags_count?: number | null
    status?: $Enums.profile_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type profileUpdateManyMutationInput = {
    username?: StringFieldUpdateOperationsInput | string
    display_name?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    city_slug?: NullableStringFieldUpdateOperationsInput | string | null
    contact_email?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    twitch?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    featured_media_id?: NullableStringFieldUpdateOperationsInput | string | null
    tags_count?: NullableIntFieldUpdateOperationsInput | number | null
    status?: Enumprofile_statusFieldUpdateOperationsInput | $Enums.profile_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type profileUncheckedUpdateManyInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    display_name?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    city_slug?: NullableStringFieldUpdateOperationsInput | string | null
    contact_email?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    twitch?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    featured_media_id?: NullableStringFieldUpdateOperationsInput | string | null
    tags_count?: NullableIntFieldUpdateOperationsInput | number | null
    status?: Enumprofile_statusFieldUpdateOperationsInput | $Enums.profile_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type mediaCreateInput = {
    id?: string
    type: $Enums.media_type
    source?: $Enums.media_source
    url: string
    poster_url?: string | null
    blur_data_url?: string | null
    width?: number | null
    height?: number | null
    duration_sec?: number | null
    focal_point_x?: number | null
    focal_point_y?: number | null
    variants?: InputJsonValue | null
    hls_url?: string | null
    nsfw_score?: number | null
    nsfw_labels?: InputJsonValue | null
    title?: string | null
    tags_cache?: mediaCreatetags_cacheInput | string[]
    status?: $Enums.media_status
    moderation_history?: InputJsonValue | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    player: profileCreateNestedOneWithoutMediaInput
    reports_against?: reportCreateNestedManyWithoutMedia_targetInput
    featured_assignments?: featured_assignmentCreateNestedManyWithoutMedia_refInput
  }

  export type mediaUncheckedCreateInput = {
    id?: string
    player_id: string
    type: $Enums.media_type
    source?: $Enums.media_source
    url: string
    poster_url?: string | null
    blur_data_url?: string | null
    width?: number | null
    height?: number | null
    duration_sec?: number | null
    focal_point_x?: number | null
    focal_point_y?: number | null
    variants?: InputJsonValue | null
    hls_url?: string | null
    nsfw_score?: number | null
    nsfw_labels?: InputJsonValue | null
    title?: string | null
    tags_cache?: mediaCreatetags_cacheInput | string[]
    status?: $Enums.media_status
    moderation_history?: InputJsonValue | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    reports_against?: reportUncheckedCreateNestedManyWithoutMedia_targetInput
    featured_assignments?: featured_assignmentUncheckedCreateNestedManyWithoutMedia_refInput
  }

  export type mediaUpdateInput = {
    type?: Enummedia_typeFieldUpdateOperationsInput | $Enums.media_type
    source?: Enummedia_sourceFieldUpdateOperationsInput | $Enums.media_source
    url?: StringFieldUpdateOperationsInput | string
    poster_url?: NullableStringFieldUpdateOperationsInput | string | null
    blur_data_url?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    duration_sec?: NullableIntFieldUpdateOperationsInput | number | null
    focal_point_x?: NullableIntFieldUpdateOperationsInput | number | null
    focal_point_y?: NullableIntFieldUpdateOperationsInput | number | null
    variants?: InputJsonValue | InputJsonValue | null
    hls_url?: NullableStringFieldUpdateOperationsInput | string | null
    nsfw_score?: NullableFloatFieldUpdateOperationsInput | number | null
    nsfw_labels?: InputJsonValue | InputJsonValue | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    tags_cache?: mediaUpdatetags_cacheInput | string[]
    status?: Enummedia_statusFieldUpdateOperationsInput | $Enums.media_status
    moderation_history?: InputJsonValue | InputJsonValue | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    player?: profileUpdateOneRequiredWithoutMediaNestedInput
    reports_against?: reportUpdateManyWithoutMedia_targetNestedInput
    featured_assignments?: featured_assignmentUpdateManyWithoutMedia_refNestedInput
  }

  export type mediaUncheckedUpdateInput = {
    player_id?: StringFieldUpdateOperationsInput | string
    type?: Enummedia_typeFieldUpdateOperationsInput | $Enums.media_type
    source?: Enummedia_sourceFieldUpdateOperationsInput | $Enums.media_source
    url?: StringFieldUpdateOperationsInput | string
    poster_url?: NullableStringFieldUpdateOperationsInput | string | null
    blur_data_url?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    duration_sec?: NullableIntFieldUpdateOperationsInput | number | null
    focal_point_x?: NullableIntFieldUpdateOperationsInput | number | null
    focal_point_y?: NullableIntFieldUpdateOperationsInput | number | null
    variants?: InputJsonValue | InputJsonValue | null
    hls_url?: NullableStringFieldUpdateOperationsInput | string | null
    nsfw_score?: NullableFloatFieldUpdateOperationsInput | number | null
    nsfw_labels?: InputJsonValue | InputJsonValue | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    tags_cache?: mediaUpdatetags_cacheInput | string[]
    status?: Enummedia_statusFieldUpdateOperationsInput | $Enums.media_status
    moderation_history?: InputJsonValue | InputJsonValue | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reports_against?: reportUncheckedUpdateManyWithoutMedia_targetNestedInput
    featured_assignments?: featured_assignmentUncheckedUpdateManyWithoutMedia_refNestedInput
  }

  export type mediaCreateManyInput = {
    id?: string
    player_id: string
    type: $Enums.media_type
    source?: $Enums.media_source
    url: string
    poster_url?: string | null
    blur_data_url?: string | null
    width?: number | null
    height?: number | null
    duration_sec?: number | null
    focal_point_x?: number | null
    focal_point_y?: number | null
    variants?: InputJsonValue | null
    hls_url?: string | null
    nsfw_score?: number | null
    nsfw_labels?: InputJsonValue | null
    title?: string | null
    tags_cache?: mediaCreatetags_cacheInput | string[]
    status?: $Enums.media_status
    moderation_history?: InputJsonValue | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type mediaUpdateManyMutationInput = {
    type?: Enummedia_typeFieldUpdateOperationsInput | $Enums.media_type
    source?: Enummedia_sourceFieldUpdateOperationsInput | $Enums.media_source
    url?: StringFieldUpdateOperationsInput | string
    poster_url?: NullableStringFieldUpdateOperationsInput | string | null
    blur_data_url?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    duration_sec?: NullableIntFieldUpdateOperationsInput | number | null
    focal_point_x?: NullableIntFieldUpdateOperationsInput | number | null
    focal_point_y?: NullableIntFieldUpdateOperationsInput | number | null
    variants?: InputJsonValue | InputJsonValue | null
    hls_url?: NullableStringFieldUpdateOperationsInput | string | null
    nsfw_score?: NullableFloatFieldUpdateOperationsInput | number | null
    nsfw_labels?: InputJsonValue | InputJsonValue | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    tags_cache?: mediaUpdatetags_cacheInput | string[]
    status?: Enummedia_statusFieldUpdateOperationsInput | $Enums.media_status
    moderation_history?: InputJsonValue | InputJsonValue | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type mediaUncheckedUpdateManyInput = {
    player_id?: StringFieldUpdateOperationsInput | string
    type?: Enummedia_typeFieldUpdateOperationsInput | $Enums.media_type
    source?: Enummedia_sourceFieldUpdateOperationsInput | $Enums.media_source
    url?: StringFieldUpdateOperationsInput | string
    poster_url?: NullableStringFieldUpdateOperationsInput | string | null
    blur_data_url?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    duration_sec?: NullableIntFieldUpdateOperationsInput | number | null
    focal_point_x?: NullableIntFieldUpdateOperationsInput | number | null
    focal_point_y?: NullableIntFieldUpdateOperationsInput | number | null
    variants?: InputJsonValue | InputJsonValue | null
    hls_url?: NullableStringFieldUpdateOperationsInput | string | null
    nsfw_score?: NullableFloatFieldUpdateOperationsInput | number | null
    nsfw_labels?: InputJsonValue | InputJsonValue | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    tags_cache?: mediaUpdatetags_cacheInput | string[]
    status?: Enummedia_statusFieldUpdateOperationsInput | $Enums.media_status
    moderation_history?: InputJsonValue | InputJsonValue | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type tagCreateInput = {
    id?: string
    slug: string
    label: string
    aliases?: tagCreatealiasesInput | string[]
    status?: $Enums.setting_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    player_tags?: player_tagCreateNestedManyWithoutTag_refInput
  }

  export type tagUncheckedCreateInput = {
    id?: string
    slug: string
    label: string
    aliases?: tagCreatealiasesInput | string[]
    status?: $Enums.setting_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    player_tags?: player_tagUncheckedCreateNestedManyWithoutTag_refInput
  }

  export type tagUpdateInput = {
    slug?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    aliases?: tagUpdatealiasesInput | string[]
    status?: Enumsetting_statusFieldUpdateOperationsInput | $Enums.setting_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    player_tags?: player_tagUpdateManyWithoutTag_refNestedInput
  }

  export type tagUncheckedUpdateInput = {
    slug?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    aliases?: tagUpdatealiasesInput | string[]
    status?: Enumsetting_statusFieldUpdateOperationsInput | $Enums.setting_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    player_tags?: player_tagUncheckedUpdateManyWithoutTag_refNestedInput
  }

  export type tagCreateManyInput = {
    id?: string
    slug: string
    label: string
    aliases?: tagCreatealiasesInput | string[]
    status?: $Enums.setting_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type tagUpdateManyMutationInput = {
    slug?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    aliases?: tagUpdatealiasesInput | string[]
    status?: Enumsetting_statusFieldUpdateOperationsInput | $Enums.setting_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type tagUncheckedUpdateManyInput = {
    slug?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    aliases?: tagUpdatealiasesInput | string[]
    status?: Enumsetting_statusFieldUpdateOperationsInput | $Enums.setting_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type player_tagCreateInput = {
    id?: string
    status?: $Enums.setting_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    player: profileCreateNestedOneWithoutPlayer_tagsInput
    tag_ref: tagCreateNestedOneWithoutPlayer_tagsInput
  }

  export type player_tagUncheckedCreateInput = {
    id?: string
    player_id: string
    tag_id: string
    status?: $Enums.setting_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type player_tagUpdateInput = {
    status?: Enumsetting_statusFieldUpdateOperationsInput | $Enums.setting_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    player?: profileUpdateOneRequiredWithoutPlayer_tagsNestedInput
    tag_ref?: tagUpdateOneRequiredWithoutPlayer_tagsNestedInput
  }

  export type player_tagUncheckedUpdateInput = {
    player_id?: StringFieldUpdateOperationsInput | string
    tag_id?: StringFieldUpdateOperationsInput | string
    status?: Enumsetting_statusFieldUpdateOperationsInput | $Enums.setting_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type player_tagCreateManyInput = {
    id?: string
    player_id: string
    tag_id: string
    status?: $Enums.setting_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type player_tagUpdateManyMutationInput = {
    status?: Enumsetting_statusFieldUpdateOperationsInput | $Enums.setting_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type player_tagUncheckedUpdateManyInput = {
    player_id?: StringFieldUpdateOperationsInput | string
    tag_id?: StringFieldUpdateOperationsInput | string
    status?: Enumsetting_statusFieldUpdateOperationsInput | $Enums.setting_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type boostCreateInput = {
    id?: string
    status?: $Enums.boost_status
    starts_at: Date | string
    ends_at: Date | string
    provider?: $Enums.provider_kind
    external_id?: string | null
    amount_cents: number
    currency?: string
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    player: profileCreateNestedOneWithoutBoostsInput
  }

  export type boostUncheckedCreateInput = {
    id?: string
    player_id: string
    status?: $Enums.boost_status
    starts_at: Date | string
    ends_at: Date | string
    provider?: $Enums.provider_kind
    external_id?: string | null
    amount_cents: number
    currency?: string
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type boostUpdateInput = {
    status?: Enumboost_statusFieldUpdateOperationsInput | $Enums.boost_status
    starts_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ends_at?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: Enumprovider_kindFieldUpdateOperationsInput | $Enums.provider_kind
    external_id?: NullableStringFieldUpdateOperationsInput | string | null
    amount_cents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    player?: profileUpdateOneRequiredWithoutBoostsNestedInput
  }

  export type boostUncheckedUpdateInput = {
    player_id?: StringFieldUpdateOperationsInput | string
    status?: Enumboost_statusFieldUpdateOperationsInput | $Enums.boost_status
    starts_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ends_at?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: Enumprovider_kindFieldUpdateOperationsInput | $Enums.provider_kind
    external_id?: NullableStringFieldUpdateOperationsInput | string | null
    amount_cents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type boostCreateManyInput = {
    id?: string
    player_id: string
    status?: $Enums.boost_status
    starts_at: Date | string
    ends_at: Date | string
    provider?: $Enums.provider_kind
    external_id?: string | null
    amount_cents: number
    currency?: string
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type boostUpdateManyMutationInput = {
    status?: Enumboost_statusFieldUpdateOperationsInput | $Enums.boost_status
    starts_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ends_at?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: Enumprovider_kindFieldUpdateOperationsInput | $Enums.provider_kind
    external_id?: NullableStringFieldUpdateOperationsInput | string | null
    amount_cents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type boostUncheckedUpdateManyInput = {
    player_id?: StringFieldUpdateOperationsInput | string
    status?: Enumboost_statusFieldUpdateOperationsInput | $Enums.boost_status
    starts_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ends_at?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: Enumprovider_kindFieldUpdateOperationsInput | $Enums.provider_kind
    external_id?: NullableStringFieldUpdateOperationsInput | string | null
    amount_cents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type reportCreateInput = {
    id?: string
    target_type: string
    reason: $Enums.report_reason
    details?: string | null
    severity?: $Enums.severity_level
    status?: $Enums.report_status
    resolution_note?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    media_target?: mediaCreateNestedOneWithoutReports_againstInput
    profile_target?: profileCreateNestedOneWithoutReports_againstInput
    reporter_user?: userCreateNestedOneWithoutReports_madeInput
  }

  export type reportUncheckedCreateInput = {
    id?: string
    reporter_user_id?: string | null
    target_type: string
    target_id: string
    reason: $Enums.report_reason
    details?: string | null
    severity?: $Enums.severity_level
    status?: $Enums.report_status
    resolution_note?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type reportUpdateInput = {
    target_type?: StringFieldUpdateOperationsInput | string
    reason?: Enumreport_reasonFieldUpdateOperationsInput | $Enums.report_reason
    details?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: Enumseverity_levelFieldUpdateOperationsInput | $Enums.severity_level
    status?: Enumreport_statusFieldUpdateOperationsInput | $Enums.report_status
    resolution_note?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    media_target?: mediaUpdateOneWithoutReports_againstNestedInput
    profile_target?: profileUpdateOneWithoutReports_againstNestedInput
    reporter_user?: userUpdateOneWithoutReports_madeNestedInput
  }

  export type reportUncheckedUpdateInput = {
    reporter_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    target_type?: StringFieldUpdateOperationsInput | string
    target_id?: StringFieldUpdateOperationsInput | string
    reason?: Enumreport_reasonFieldUpdateOperationsInput | $Enums.report_reason
    details?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: Enumseverity_levelFieldUpdateOperationsInput | $Enums.severity_level
    status?: Enumreport_statusFieldUpdateOperationsInput | $Enums.report_status
    resolution_note?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type reportCreateManyInput = {
    id?: string
    reporter_user_id?: string | null
    target_type: string
    target_id: string
    reason: $Enums.report_reason
    details?: string | null
    severity?: $Enums.severity_level
    status?: $Enums.report_status
    resolution_note?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type reportUpdateManyMutationInput = {
    target_type?: StringFieldUpdateOperationsInput | string
    reason?: Enumreport_reasonFieldUpdateOperationsInput | $Enums.report_reason
    details?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: Enumseverity_levelFieldUpdateOperationsInput | $Enums.severity_level
    status?: Enumreport_statusFieldUpdateOperationsInput | $Enums.report_status
    resolution_note?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type reportUncheckedUpdateManyInput = {
    reporter_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    target_type?: StringFieldUpdateOperationsInput | string
    target_id?: StringFieldUpdateOperationsInput | string
    reason?: Enumreport_reasonFieldUpdateOperationsInput | $Enums.report_reason
    details?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: Enumseverity_levelFieldUpdateOperationsInput | $Enums.severity_level
    status?: Enumreport_statusFieldUpdateOperationsInput | $Enums.report_status
    resolution_note?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type strikeCreateInput = {
    id?: string
    reason: string
    severity?: $Enums.severity_level
    expires_at?: Date | string | null
    status?: $Enums.setting_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    player: profileCreateNestedOneWithoutStrikesInput
  }

  export type strikeUncheckedCreateInput = {
    id?: string
    player_id: string
    reason: string
    severity?: $Enums.severity_level
    expires_at?: Date | string | null
    status?: $Enums.setting_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type strikeUpdateInput = {
    reason?: StringFieldUpdateOperationsInput | string
    severity?: Enumseverity_levelFieldUpdateOperationsInput | $Enums.severity_level
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumsetting_statusFieldUpdateOperationsInput | $Enums.setting_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    player?: profileUpdateOneRequiredWithoutStrikesNestedInput
  }

  export type strikeUncheckedUpdateInput = {
    player_id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    severity?: Enumseverity_levelFieldUpdateOperationsInput | $Enums.severity_level
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumsetting_statusFieldUpdateOperationsInput | $Enums.setting_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type strikeCreateManyInput = {
    id?: string
    player_id: string
    reason: string
    severity?: $Enums.severity_level
    expires_at?: Date | string | null
    status?: $Enums.setting_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type strikeUpdateManyMutationInput = {
    reason?: StringFieldUpdateOperationsInput | string
    severity?: Enumseverity_levelFieldUpdateOperationsInput | $Enums.severity_level
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumsetting_statusFieldUpdateOperationsInput | $Enums.setting_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type strikeUncheckedUpdateManyInput = {
    player_id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    severity?: Enumseverity_levelFieldUpdateOperationsInput | $Enums.severity_level
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumsetting_statusFieldUpdateOperationsInput | $Enums.setting_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type user_noteCreateInput = {
    id?: string
    note: string
    status?: $Enums.setting_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    player: profileCreateNestedOneWithoutNotesInput
    author: userCreateNestedOneWithoutNotes_authoredInput
  }

  export type user_noteUncheckedCreateInput = {
    id?: string
    player_id: string
    author_id: string
    note: string
    status?: $Enums.setting_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type user_noteUpdateInput = {
    note?: StringFieldUpdateOperationsInput | string
    status?: Enumsetting_statusFieldUpdateOperationsInput | $Enums.setting_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    player?: profileUpdateOneRequiredWithoutNotesNestedInput
    author?: userUpdateOneRequiredWithoutNotes_authoredNestedInput
  }

  export type user_noteUncheckedUpdateInput = {
    player_id?: StringFieldUpdateOperationsInput | string
    author_id?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    status?: Enumsetting_statusFieldUpdateOperationsInput | $Enums.setting_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type user_noteCreateManyInput = {
    id?: string
    player_id: string
    author_id: string
    note: string
    status?: $Enums.setting_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type user_noteUpdateManyMutationInput = {
    note?: StringFieldUpdateOperationsInput | string
    status?: Enumsetting_statusFieldUpdateOperationsInput | $Enums.setting_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type user_noteUncheckedUpdateManyInput = {
    player_id?: StringFieldUpdateOperationsInput | string
    author_id?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    status?: Enumsetting_statusFieldUpdateOperationsInput | $Enums.setting_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type announcementCreateInput = {
    id?: string
    title: string
    body_md: string
    status?: $Enums.announcement_status
    starts_at?: Date | string | null
    ends_at?: Date | string | null
    segment_tags?: announcementCreatesegment_tagsInput | string[]
    segment_states?: announcementCreatesegment_statesInput | string[]
    segment_devices?: announcementCreatesegment_devicesInput | string[]
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type announcementUncheckedCreateInput = {
    id?: string
    title: string
    body_md: string
    status?: $Enums.announcement_status
    starts_at?: Date | string | null
    ends_at?: Date | string | null
    segment_tags?: announcementCreatesegment_tagsInput | string[]
    segment_states?: announcementCreatesegment_statesInput | string[]
    segment_devices?: announcementCreatesegment_devicesInput | string[]
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type announcementUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    body_md?: StringFieldUpdateOperationsInput | string
    status?: Enumannouncement_statusFieldUpdateOperationsInput | $Enums.announcement_status
    starts_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ends_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    segment_tags?: announcementUpdatesegment_tagsInput | string[]
    segment_states?: announcementUpdatesegment_statesInput | string[]
    segment_devices?: announcementUpdatesegment_devicesInput | string[]
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type announcementUncheckedUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    body_md?: StringFieldUpdateOperationsInput | string
    status?: Enumannouncement_statusFieldUpdateOperationsInput | $Enums.announcement_status
    starts_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ends_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    segment_tags?: announcementUpdatesegment_tagsInput | string[]
    segment_states?: announcementUpdatesegment_statesInput | string[]
    segment_devices?: announcementUpdatesegment_devicesInput | string[]
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type announcementCreateManyInput = {
    id?: string
    title: string
    body_md: string
    status?: $Enums.announcement_status
    starts_at?: Date | string | null
    ends_at?: Date | string | null
    segment_tags?: announcementCreatesegment_tagsInput | string[]
    segment_states?: announcementCreatesegment_statesInput | string[]
    segment_devices?: announcementCreatesegment_devicesInput | string[]
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type announcementUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    body_md?: StringFieldUpdateOperationsInput | string
    status?: Enumannouncement_statusFieldUpdateOperationsInput | $Enums.announcement_status
    starts_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ends_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    segment_tags?: announcementUpdatesegment_tagsInput | string[]
    segment_states?: announcementUpdatesegment_statesInput | string[]
    segment_devices?: announcementUpdatesegment_devicesInput | string[]
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type announcementUncheckedUpdateManyInput = {
    title?: StringFieldUpdateOperationsInput | string
    body_md?: StringFieldUpdateOperationsInput | string
    status?: Enumannouncement_statusFieldUpdateOperationsInput | $Enums.announcement_status
    starts_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ends_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    segment_tags?: announcementUpdatesegment_tagsInput | string[]
    segment_states?: announcementUpdatesegment_statesInput | string[]
    segment_devices?: announcementUpdatesegment_devicesInput | string[]
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type feature_slotCreateInput = {
    id?: string
    slot_key: $Enums.feature_slot_key
    description?: string | null
    status?: $Enums.setting_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type feature_slotUncheckedCreateInput = {
    id?: string
    slot_key: $Enums.feature_slot_key
    description?: string | null
    status?: $Enums.setting_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type feature_slotUpdateInput = {
    slot_key?: Enumfeature_slot_keyFieldUpdateOperationsInput | $Enums.feature_slot_key
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enumsetting_statusFieldUpdateOperationsInput | $Enums.setting_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type feature_slotUncheckedUpdateInput = {
    slot_key?: Enumfeature_slot_keyFieldUpdateOperationsInput | $Enums.feature_slot_key
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enumsetting_statusFieldUpdateOperationsInput | $Enums.setting_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type feature_slotCreateManyInput = {
    id?: string
    slot_key: $Enums.feature_slot_key
    description?: string | null
    status?: $Enums.setting_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type feature_slotUpdateManyMutationInput = {
    slot_key?: Enumfeature_slot_keyFieldUpdateOperationsInput | $Enums.feature_slot_key
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enumsetting_statusFieldUpdateOperationsInput | $Enums.setting_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type feature_slotUncheckedUpdateManyInput = {
    slot_key?: Enumfeature_slot_keyFieldUpdateOperationsInput | $Enums.feature_slot_key
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enumsetting_statusFieldUpdateOperationsInput | $Enums.setting_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type featured_assignmentCreateInput = {
    id?: string
    slot_key: $Enums.feature_slot_key
    starts_at: Date | string
    ends_at: Date | string
    priority?: number
    status?: $Enums.setting_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    player: profileCreateNestedOneWithoutFeatured_assignmentsInput
    media_ref?: mediaCreateNestedOneWithoutFeatured_assignmentsInput
  }

  export type featured_assignmentUncheckedCreateInput = {
    id?: string
    slot_key: $Enums.feature_slot_key
    player_id: string
    media_id?: string | null
    starts_at: Date | string
    ends_at: Date | string
    priority?: number
    status?: $Enums.setting_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type featured_assignmentUpdateInput = {
    slot_key?: Enumfeature_slot_keyFieldUpdateOperationsInput | $Enums.feature_slot_key
    starts_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ends_at?: DateTimeFieldUpdateOperationsInput | Date | string
    priority?: IntFieldUpdateOperationsInput | number
    status?: Enumsetting_statusFieldUpdateOperationsInput | $Enums.setting_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    player?: profileUpdateOneRequiredWithoutFeatured_assignmentsNestedInput
    media_ref?: mediaUpdateOneWithoutFeatured_assignmentsNestedInput
  }

  export type featured_assignmentUncheckedUpdateInput = {
    slot_key?: Enumfeature_slot_keyFieldUpdateOperationsInput | $Enums.feature_slot_key
    player_id?: StringFieldUpdateOperationsInput | string
    media_id?: NullableStringFieldUpdateOperationsInput | string | null
    starts_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ends_at?: DateTimeFieldUpdateOperationsInput | Date | string
    priority?: IntFieldUpdateOperationsInput | number
    status?: Enumsetting_statusFieldUpdateOperationsInput | $Enums.setting_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type featured_assignmentCreateManyInput = {
    id?: string
    slot_key: $Enums.feature_slot_key
    player_id: string
    media_id?: string | null
    starts_at: Date | string
    ends_at: Date | string
    priority?: number
    status?: $Enums.setting_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type featured_assignmentUpdateManyMutationInput = {
    slot_key?: Enumfeature_slot_keyFieldUpdateOperationsInput | $Enums.feature_slot_key
    starts_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ends_at?: DateTimeFieldUpdateOperationsInput | Date | string
    priority?: IntFieldUpdateOperationsInput | number
    status?: Enumsetting_statusFieldUpdateOperationsInput | $Enums.setting_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type featured_assignmentUncheckedUpdateManyInput = {
    slot_key?: Enumfeature_slot_keyFieldUpdateOperationsInput | $Enums.feature_slot_key
    player_id?: StringFieldUpdateOperationsInput | string
    media_id?: NullableStringFieldUpdateOperationsInput | string | null
    starts_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ends_at?: DateTimeFieldUpdateOperationsInput | Date | string
    priority?: IntFieldUpdateOperationsInput | number
    status?: Enumsetting_statusFieldUpdateOperationsInput | $Enums.setting_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type settingCreateInput = {
    id?: string
    key: string
    value_json: InputJsonValue
    status?: $Enums.setting_status
    version?: number
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type settingUncheckedCreateInput = {
    id?: string
    key: string
    value_json: InputJsonValue
    status?: $Enums.setting_status
    version?: number
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type settingUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    value_json?: InputJsonValue | InputJsonValue
    status?: Enumsetting_statusFieldUpdateOperationsInput | $Enums.setting_status
    version?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type settingUncheckedUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    value_json?: InputJsonValue | InputJsonValue
    status?: Enumsetting_statusFieldUpdateOperationsInput | $Enums.setting_status
    version?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type settingCreateManyInput = {
    id?: string
    key: string
    value_json: InputJsonValue
    status?: $Enums.setting_status
    version?: number
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type settingUpdateManyMutationInput = {
    key?: StringFieldUpdateOperationsInput | string
    value_json?: InputJsonValue | InputJsonValue
    status?: Enumsetting_statusFieldUpdateOperationsInput | $Enums.setting_status
    version?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type settingUncheckedUpdateManyInput = {
    key?: StringFieldUpdateOperationsInput | string
    value_json?: InputJsonValue | InputJsonValue
    status?: Enumsetting_statusFieldUpdateOperationsInput | $Enums.setting_status
    version?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type support_ticketCreateInput = {
    id?: string
    email?: string | null
    subject: string
    message: string
    priority?: $Enums.ticket_priority
    status?: $Enums.ticket_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    user?: userCreateNestedOneWithoutTicketsInput
    assignee?: userCreateNestedOneWithoutAssigned_ticketsInput
  }

  export type support_ticketUncheckedCreateInput = {
    id?: string
    user_id?: string | null
    email?: string | null
    subject: string
    message: string
    priority?: $Enums.ticket_priority
    status?: $Enums.ticket_status
    assigned_to?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type support_ticketUpdateInput = {
    email?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    priority?: Enumticket_priorityFieldUpdateOperationsInput | $Enums.ticket_priority
    status?: Enumticket_statusFieldUpdateOperationsInput | $Enums.ticket_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneWithoutTicketsNestedInput
    assignee?: userUpdateOneWithoutAssigned_ticketsNestedInput
  }

  export type support_ticketUncheckedUpdateInput = {
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    priority?: Enumticket_priorityFieldUpdateOperationsInput | $Enums.ticket_priority
    status?: Enumticket_statusFieldUpdateOperationsInput | $Enums.ticket_status
    assigned_to?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type support_ticketCreateManyInput = {
    id?: string
    user_id?: string | null
    email?: string | null
    subject: string
    message: string
    priority?: $Enums.ticket_priority
    status?: $Enums.ticket_status
    assigned_to?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type support_ticketUpdateManyMutationInput = {
    email?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    priority?: Enumticket_priorityFieldUpdateOperationsInput | $Enums.ticket_priority
    status?: Enumticket_statusFieldUpdateOperationsInput | $Enums.ticket_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type support_ticketUncheckedUpdateManyInput = {
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    priority?: Enumticket_priorityFieldUpdateOperationsInput | $Enums.ticket_priority
    status?: Enumticket_statusFieldUpdateOperationsInput | $Enums.ticket_status
    assigned_to?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type contact_eventCreateInput = {
    id?: string
    channel: $Enums.contact_channel
    requester_ip?: string | null
    user_agent?: string | null
    referrer?: string | null
    message?: string | null
    status?: $Enums.setting_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    player: profileCreateNestedOneWithoutContact_eventsInput
  }

  export type contact_eventUncheckedCreateInput = {
    id?: string
    player_id: string
    channel: $Enums.contact_channel
    requester_ip?: string | null
    user_agent?: string | null
    referrer?: string | null
    message?: string | null
    status?: $Enums.setting_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type contact_eventUpdateInput = {
    channel?: Enumcontact_channelFieldUpdateOperationsInput | $Enums.contact_channel
    requester_ip?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enumsetting_statusFieldUpdateOperationsInput | $Enums.setting_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    player?: profileUpdateOneRequiredWithoutContact_eventsNestedInput
  }

  export type contact_eventUncheckedUpdateInput = {
    player_id?: StringFieldUpdateOperationsInput | string
    channel?: Enumcontact_channelFieldUpdateOperationsInput | $Enums.contact_channel
    requester_ip?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enumsetting_statusFieldUpdateOperationsInput | $Enums.setting_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type contact_eventCreateManyInput = {
    id?: string
    player_id: string
    channel: $Enums.contact_channel
    requester_ip?: string | null
    user_agent?: string | null
    referrer?: string | null
    message?: string | null
    status?: $Enums.setting_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type contact_eventUpdateManyMutationInput = {
    channel?: Enumcontact_channelFieldUpdateOperationsInput | $Enums.contact_channel
    requester_ip?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enumsetting_statusFieldUpdateOperationsInput | $Enums.setting_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type contact_eventUncheckedUpdateManyInput = {
    player_id?: StringFieldUpdateOperationsInput | string
    channel?: Enumcontact_channelFieldUpdateOperationsInput | $Enums.contact_channel
    requester_ip?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enumsetting_statusFieldUpdateOperationsInput | $Enums.setting_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type audit_logCreateInput = {
    id?: string
    actor_user_id?: string | null
    actor_role?: $Enums.user_role | null
    entity_type: string
    entity_id: string
    action: string
    payload?: InputJsonValue | null
    status?: $Enums.audit_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type audit_logUncheckedCreateInput = {
    id?: string
    actor_user_id?: string | null
    actor_role?: $Enums.user_role | null
    entity_type: string
    entity_id: string
    action: string
    payload?: InputJsonValue | null
    status?: $Enums.audit_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type audit_logUpdateInput = {
    actor_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    actor_role?: NullableEnumuser_roleFieldUpdateOperationsInput | $Enums.user_role | null
    entity_type?: StringFieldUpdateOperationsInput | string
    entity_id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    payload?: InputJsonValue | InputJsonValue | null
    status?: Enumaudit_statusFieldUpdateOperationsInput | $Enums.audit_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type audit_logUncheckedUpdateInput = {
    actor_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    actor_role?: NullableEnumuser_roleFieldUpdateOperationsInput | $Enums.user_role | null
    entity_type?: StringFieldUpdateOperationsInput | string
    entity_id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    payload?: InputJsonValue | InputJsonValue | null
    status?: Enumaudit_statusFieldUpdateOperationsInput | $Enums.audit_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type audit_logCreateManyInput = {
    id?: string
    actor_user_id?: string | null
    actor_role?: $Enums.user_role | null
    entity_type: string
    entity_id: string
    action: string
    payload?: InputJsonValue | null
    status?: $Enums.audit_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type audit_logUpdateManyMutationInput = {
    actor_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    actor_role?: NullableEnumuser_roleFieldUpdateOperationsInput | $Enums.user_role | null
    entity_type?: StringFieldUpdateOperationsInput | string
    entity_id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    payload?: InputJsonValue | InputJsonValue | null
    status?: Enumaudit_statusFieldUpdateOperationsInput | $Enums.audit_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type audit_logUncheckedUpdateManyInput = {
    actor_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    actor_role?: NullableEnumuser_roleFieldUpdateOperationsInput | $Enums.user_role | null
    entity_type?: StringFieldUpdateOperationsInput | string
    entity_id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    payload?: InputJsonValue | InputJsonValue | null
    status?: Enumaudit_statusFieldUpdateOperationsInput | $Enums.audit_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type webhook_eventCreateInput = {
    id?: string
    provider: $Enums.provider_kind
    event_type: string
    payload: InputJsonValue
    related_type?: string | null
    related_id?: string | null
    status?: $Enums.webhook_status
    retry_count?: number
    last_error?: string | null
    next_retry_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type webhook_eventUncheckedCreateInput = {
    id?: string
    provider: $Enums.provider_kind
    event_type: string
    payload: InputJsonValue
    related_type?: string | null
    related_id?: string | null
    status?: $Enums.webhook_status
    retry_count?: number
    last_error?: string | null
    next_retry_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type webhook_eventUpdateInput = {
    provider?: Enumprovider_kindFieldUpdateOperationsInput | $Enums.provider_kind
    event_type?: StringFieldUpdateOperationsInput | string
    payload?: InputJsonValue | InputJsonValue
    related_type?: NullableStringFieldUpdateOperationsInput | string | null
    related_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enumwebhook_statusFieldUpdateOperationsInput | $Enums.webhook_status
    retry_count?: IntFieldUpdateOperationsInput | number
    last_error?: NullableStringFieldUpdateOperationsInput | string | null
    next_retry_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type webhook_eventUncheckedUpdateInput = {
    provider?: Enumprovider_kindFieldUpdateOperationsInput | $Enums.provider_kind
    event_type?: StringFieldUpdateOperationsInput | string
    payload?: InputJsonValue | InputJsonValue
    related_type?: NullableStringFieldUpdateOperationsInput | string | null
    related_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enumwebhook_statusFieldUpdateOperationsInput | $Enums.webhook_status
    retry_count?: IntFieldUpdateOperationsInput | number
    last_error?: NullableStringFieldUpdateOperationsInput | string | null
    next_retry_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type webhook_eventCreateManyInput = {
    id?: string
    provider: $Enums.provider_kind
    event_type: string
    payload: InputJsonValue
    related_type?: string | null
    related_id?: string | null
    status?: $Enums.webhook_status
    retry_count?: number
    last_error?: string | null
    next_retry_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type webhook_eventUpdateManyMutationInput = {
    provider?: Enumprovider_kindFieldUpdateOperationsInput | $Enums.provider_kind
    event_type?: StringFieldUpdateOperationsInput | string
    payload?: InputJsonValue | InputJsonValue
    related_type?: NullableStringFieldUpdateOperationsInput | string | null
    related_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enumwebhook_statusFieldUpdateOperationsInput | $Enums.webhook_status
    retry_count?: IntFieldUpdateOperationsInput | number
    last_error?: NullableStringFieldUpdateOperationsInput | string | null
    next_retry_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type webhook_eventUncheckedUpdateManyInput = {
    provider?: Enumprovider_kindFieldUpdateOperationsInput | $Enums.provider_kind
    event_type?: StringFieldUpdateOperationsInput | string
    payload?: InputJsonValue | InputJsonValue
    related_type?: NullableStringFieldUpdateOperationsInput | string | null
    related_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enumwebhook_statusFieldUpdateOperationsInput | $Enums.webhook_status
    retry_count?: IntFieldUpdateOperationsInput | number
    last_error?: NullableStringFieldUpdateOperationsInput | string | null
    next_retry_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type sessionCreateInput = {
    id?: string
    session_token: string
    ip?: string | null
    user_agent?: string | null
    expires_at: Date | string
    status?: $Enums.setting_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    user: userCreateNestedOneWithoutSessionsInput
  }

  export type sessionUncheckedCreateInput = {
    id?: string
    user_id: string
    session_token: string
    ip?: string | null
    user_agent?: string | null
    expires_at: Date | string
    status?: $Enums.setting_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type sessionUpdateInput = {
    session_token?: StringFieldUpdateOperationsInput | string
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enumsetting_statusFieldUpdateOperationsInput | $Enums.setting_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type sessionUncheckedUpdateInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    session_token?: StringFieldUpdateOperationsInput | string
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enumsetting_statusFieldUpdateOperationsInput | $Enums.setting_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type sessionCreateManyInput = {
    id?: string
    user_id: string
    session_token: string
    ip?: string | null
    user_agent?: string | null
    expires_at: Date | string
    status?: $Enums.setting_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type sessionUpdateManyMutationInput = {
    session_token?: StringFieldUpdateOperationsInput | string
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enumsetting_statusFieldUpdateOperationsInput | $Enums.setting_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type sessionUncheckedUpdateManyInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    session_token?: StringFieldUpdateOperationsInput | string
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enumsetting_statusFieldUpdateOperationsInput | $Enums.setting_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type Enumuser_roleFilter<$PrismaModel = never> = {
    equals?: $Enums.user_role | Enumuser_roleFieldRefInput<$PrismaModel>
    in?: $Enums.user_role[] | ListEnumuser_roleFieldRefInput<$PrismaModel>
    notIn?: $Enums.user_role[] | ListEnumuser_roleFieldRefInput<$PrismaModel>
    not?: NestedEnumuser_roleFilter<$PrismaModel> | $Enums.user_role
  }

  export type Enumuser_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.user_status | Enumuser_statusFieldRefInput<$PrismaModel>
    in?: $Enums.user_status[] | ListEnumuser_statusFieldRefInput<$PrismaModel>
    notIn?: $Enums.user_status[] | ListEnumuser_statusFieldRefInput<$PrismaModel>
    not?: NestedEnumuser_statusFilter<$PrismaModel> | $Enums.user_status
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
    isSet?: boolean
  }

  export type ProfileNullableScalarRelationFilter = {
    is?: profileWhereInput | null
    isNot?: profileWhereInput | null
  }

  export type Support_ticketListRelationFilter = {
    every?: support_ticketWhereInput
    some?: support_ticketWhereInput
    none?: support_ticketWhereInput
  }

  export type ReportListRelationFilter = {
    every?: reportWhereInput
    some?: reportWhereInput
    none?: reportWhereInput
  }

  export type User_noteListRelationFilter = {
    every?: user_noteWhereInput
    some?: user_noteWhereInput
    none?: user_noteWhereInput
  }

  export type SessionListRelationFilter = {
    every?: sessionWhereInput
    some?: sessionWhereInput
    none?: sessionWhereInput
  }

  export type support_ticketOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type reportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type user_noteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type sessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type userCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    role?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type userMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    role?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type userMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    role?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type Enumuser_roleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.user_role | Enumuser_roleFieldRefInput<$PrismaModel>
    in?: $Enums.user_role[] | ListEnumuser_roleFieldRefInput<$PrismaModel>
    notIn?: $Enums.user_role[] | ListEnumuser_roleFieldRefInput<$PrismaModel>
    not?: NestedEnumuser_roleWithAggregatesFilter<$PrismaModel> | $Enums.user_role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumuser_roleFilter<$PrismaModel>
    _max?: NestedEnumuser_roleFilter<$PrismaModel>
  }

  export type Enumuser_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.user_status | Enumuser_statusFieldRefInput<$PrismaModel>
    in?: $Enums.user_status[] | ListEnumuser_statusFieldRefInput<$PrismaModel>
    notIn?: $Enums.user_status[] | ListEnumuser_statusFieldRefInput<$PrismaModel>
    not?: NestedEnumuser_statusWithAggregatesFilter<$PrismaModel> | $Enums.user_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumuser_statusFilter<$PrismaModel>
    _max?: NestedEnumuser_statusFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
    isSet?: boolean
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type Enumprofile_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.profile_status | Enumprofile_statusFieldRefInput<$PrismaModel>
    in?: $Enums.profile_status[] | ListEnumprofile_statusFieldRefInput<$PrismaModel>
    notIn?: $Enums.profile_status[] | ListEnumprofile_statusFieldRefInput<$PrismaModel>
    not?: NestedEnumprofile_statusFilter<$PrismaModel> | $Enums.profile_status
  }

  export type UserScalarRelationFilter = {
    is?: userWhereInput
    isNot?: userWhereInput
  }

  export type MediaListRelationFilter = {
    every?: mediaWhereInput
    some?: mediaWhereInput
    none?: mediaWhereInput
  }

  export type BoostListRelationFilter = {
    every?: boostWhereInput
    some?: boostWhereInput
    none?: boostWhereInput
  }

  export type StrikeListRelationFilter = {
    every?: strikeWhereInput
    some?: strikeWhereInput
    none?: strikeWhereInput
  }

  export type Contact_eventListRelationFilter = {
    every?: contact_eventWhereInput
    some?: contact_eventWhereInput
    none?: contact_eventWhereInput
  }

  export type Player_tagListRelationFilter = {
    every?: player_tagWhereInput
    some?: player_tagWhereInput
    none?: player_tagWhereInput
  }

  export type Featured_assignmentListRelationFilter = {
    every?: featured_assignmentWhereInput
    some?: featured_assignmentWhereInput
    none?: featured_assignmentWhereInput
  }

  export type mediaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type boostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type strikeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type contact_eventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type player_tagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type featured_assignmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type profileCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    username?: SortOrder
    display_name?: SortOrder
    bio?: SortOrder
    avatar_url?: SortOrder
    state?: SortOrder
    city?: SortOrder
    city_slug?: SortOrder
    contact_email?: SortOrder
    whatsapp?: SortOrder
    twitch?: SortOrder
    youtube?: SortOrder
    instagram?: SortOrder
    featured_media_id?: SortOrder
    tags_count?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type profileAvgOrderByAggregateInput = {
    tags_count?: SortOrder
  }

  export type profileMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    username?: SortOrder
    display_name?: SortOrder
    bio?: SortOrder
    avatar_url?: SortOrder
    state?: SortOrder
    city?: SortOrder
    city_slug?: SortOrder
    contact_email?: SortOrder
    whatsapp?: SortOrder
    twitch?: SortOrder
    youtube?: SortOrder
    instagram?: SortOrder
    featured_media_id?: SortOrder
    tags_count?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type profileMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    username?: SortOrder
    display_name?: SortOrder
    bio?: SortOrder
    avatar_url?: SortOrder
    state?: SortOrder
    city?: SortOrder
    city_slug?: SortOrder
    contact_email?: SortOrder
    whatsapp?: SortOrder
    twitch?: SortOrder
    youtube?: SortOrder
    instagram?: SortOrder
    featured_media_id?: SortOrder
    tags_count?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type profileSumOrderByAggregateInput = {
    tags_count?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type Enumprofile_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.profile_status | Enumprofile_statusFieldRefInput<$PrismaModel>
    in?: $Enums.profile_status[] | ListEnumprofile_statusFieldRefInput<$PrismaModel>
    notIn?: $Enums.profile_status[] | ListEnumprofile_statusFieldRefInput<$PrismaModel>
    not?: NestedEnumprofile_statusWithAggregatesFilter<$PrismaModel> | $Enums.profile_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumprofile_statusFilter<$PrismaModel>
    _max?: NestedEnumprofile_statusFilter<$PrismaModel>
  }

  export type Enummedia_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.media_type | Enummedia_typeFieldRefInput<$PrismaModel>
    in?: $Enums.media_type[] | ListEnummedia_typeFieldRefInput<$PrismaModel>
    notIn?: $Enums.media_type[] | ListEnummedia_typeFieldRefInput<$PrismaModel>
    not?: NestedEnummedia_typeFilter<$PrismaModel> | $Enums.media_type
  }

  export type Enummedia_sourceFilter<$PrismaModel = never> = {
    equals?: $Enums.media_source | Enummedia_sourceFieldRefInput<$PrismaModel>
    in?: $Enums.media_source[] | ListEnummedia_sourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.media_source[] | ListEnummedia_sourceFieldRefInput<$PrismaModel>
    not?: NestedEnummedia_sourceFilter<$PrismaModel> | $Enums.media_source
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    isSet?: boolean
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type Enummedia_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.media_status | Enummedia_statusFieldRefInput<$PrismaModel>
    in?: $Enums.media_status[] | ListEnummedia_statusFieldRefInput<$PrismaModel>
    notIn?: $Enums.media_status[] | ListEnummedia_statusFieldRefInput<$PrismaModel>
    not?: NestedEnummedia_statusFilter<$PrismaModel> | $Enums.media_status
  }

  export type ProfileScalarRelationFilter = {
    is?: profileWhereInput
    isNot?: profileWhereInput
  }

  export type mediaCountOrderByAggregateInput = {
    id?: SortOrder
    player_id?: SortOrder
    type?: SortOrder
    source?: SortOrder
    url?: SortOrder
    poster_url?: SortOrder
    blur_data_url?: SortOrder
    width?: SortOrder
    height?: SortOrder
    duration_sec?: SortOrder
    focal_point_x?: SortOrder
    focal_point_y?: SortOrder
    variants?: SortOrder
    hls_url?: SortOrder
    nsfw_score?: SortOrder
    nsfw_labels?: SortOrder
    title?: SortOrder
    tags_cache?: SortOrder
    status?: SortOrder
    moderation_history?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type mediaAvgOrderByAggregateInput = {
    width?: SortOrder
    height?: SortOrder
    duration_sec?: SortOrder
    focal_point_x?: SortOrder
    focal_point_y?: SortOrder
    nsfw_score?: SortOrder
  }

  export type mediaMaxOrderByAggregateInput = {
    id?: SortOrder
    player_id?: SortOrder
    type?: SortOrder
    source?: SortOrder
    url?: SortOrder
    poster_url?: SortOrder
    blur_data_url?: SortOrder
    width?: SortOrder
    height?: SortOrder
    duration_sec?: SortOrder
    focal_point_x?: SortOrder
    focal_point_y?: SortOrder
    hls_url?: SortOrder
    nsfw_score?: SortOrder
    title?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type mediaMinOrderByAggregateInput = {
    id?: SortOrder
    player_id?: SortOrder
    type?: SortOrder
    source?: SortOrder
    url?: SortOrder
    poster_url?: SortOrder
    blur_data_url?: SortOrder
    width?: SortOrder
    height?: SortOrder
    duration_sec?: SortOrder
    focal_point_x?: SortOrder
    focal_point_y?: SortOrder
    hls_url?: SortOrder
    nsfw_score?: SortOrder
    title?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type mediaSumOrderByAggregateInput = {
    width?: SortOrder
    height?: SortOrder
    duration_sec?: SortOrder
    focal_point_x?: SortOrder
    focal_point_y?: SortOrder
    nsfw_score?: SortOrder
  }

  export type Enummedia_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.media_type | Enummedia_typeFieldRefInput<$PrismaModel>
    in?: $Enums.media_type[] | ListEnummedia_typeFieldRefInput<$PrismaModel>
    notIn?: $Enums.media_type[] | ListEnummedia_typeFieldRefInput<$PrismaModel>
    not?: NestedEnummedia_typeWithAggregatesFilter<$PrismaModel> | $Enums.media_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnummedia_typeFilter<$PrismaModel>
    _max?: NestedEnummedia_typeFilter<$PrismaModel>
  }

  export type Enummedia_sourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.media_source | Enummedia_sourceFieldRefInput<$PrismaModel>
    in?: $Enums.media_source[] | ListEnummedia_sourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.media_source[] | ListEnummedia_sourceFieldRefInput<$PrismaModel>
    not?: NestedEnummedia_sourceWithAggregatesFilter<$PrismaModel> | $Enums.media_source
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnummedia_sourceFilter<$PrismaModel>
    _max?: NestedEnummedia_sourceFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type Enummedia_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.media_status | Enummedia_statusFieldRefInput<$PrismaModel>
    in?: $Enums.media_status[] | ListEnummedia_statusFieldRefInput<$PrismaModel>
    notIn?: $Enums.media_status[] | ListEnummedia_statusFieldRefInput<$PrismaModel>
    not?: NestedEnummedia_statusWithAggregatesFilter<$PrismaModel> | $Enums.media_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnummedia_statusFilter<$PrismaModel>
    _max?: NestedEnummedia_statusFilter<$PrismaModel>
  }

  export type Enumsetting_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.setting_status | Enumsetting_statusFieldRefInput<$PrismaModel>
    in?: $Enums.setting_status[] | ListEnumsetting_statusFieldRefInput<$PrismaModel>
    notIn?: $Enums.setting_status[] | ListEnumsetting_statusFieldRefInput<$PrismaModel>
    not?: NestedEnumsetting_statusFilter<$PrismaModel> | $Enums.setting_status
  }

  export type tagCountOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    label?: SortOrder
    aliases?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type tagMaxOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    label?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type tagMinOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    label?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type Enumsetting_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.setting_status | Enumsetting_statusFieldRefInput<$PrismaModel>
    in?: $Enums.setting_status[] | ListEnumsetting_statusFieldRefInput<$PrismaModel>
    notIn?: $Enums.setting_status[] | ListEnumsetting_statusFieldRefInput<$PrismaModel>
    not?: NestedEnumsetting_statusWithAggregatesFilter<$PrismaModel> | $Enums.setting_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumsetting_statusFilter<$PrismaModel>
    _max?: NestedEnumsetting_statusFilter<$PrismaModel>
  }

  export type TagScalarRelationFilter = {
    is?: tagWhereInput
    isNot?: tagWhereInput
  }

  export type player_tagPlayer_idTag_idCompoundUniqueInput = {
    player_id: string
    tag_id: string
  }

  export type player_tagCountOrderByAggregateInput = {
    id?: SortOrder
    player_id?: SortOrder
    tag_id?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type player_tagMaxOrderByAggregateInput = {
    id?: SortOrder
    player_id?: SortOrder
    tag_id?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type player_tagMinOrderByAggregateInput = {
    id?: SortOrder
    player_id?: SortOrder
    tag_id?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type Enumboost_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.boost_status | Enumboost_statusFieldRefInput<$PrismaModel>
    in?: $Enums.boost_status[] | ListEnumboost_statusFieldRefInput<$PrismaModel>
    notIn?: $Enums.boost_status[] | ListEnumboost_statusFieldRefInput<$PrismaModel>
    not?: NestedEnumboost_statusFilter<$PrismaModel> | $Enums.boost_status
  }

  export type Enumprovider_kindFilter<$PrismaModel = never> = {
    equals?: $Enums.provider_kind | Enumprovider_kindFieldRefInput<$PrismaModel>
    in?: $Enums.provider_kind[] | ListEnumprovider_kindFieldRefInput<$PrismaModel>
    notIn?: $Enums.provider_kind[] | ListEnumprovider_kindFieldRefInput<$PrismaModel>
    not?: NestedEnumprovider_kindFilter<$PrismaModel> | $Enums.provider_kind
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type boostCountOrderByAggregateInput = {
    id?: SortOrder
    player_id?: SortOrder
    status?: SortOrder
    starts_at?: SortOrder
    ends_at?: SortOrder
    provider?: SortOrder
    external_id?: SortOrder
    amount_cents?: SortOrder
    currency?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type boostAvgOrderByAggregateInput = {
    amount_cents?: SortOrder
  }

  export type boostMaxOrderByAggregateInput = {
    id?: SortOrder
    player_id?: SortOrder
    status?: SortOrder
    starts_at?: SortOrder
    ends_at?: SortOrder
    provider?: SortOrder
    external_id?: SortOrder
    amount_cents?: SortOrder
    currency?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type boostMinOrderByAggregateInput = {
    id?: SortOrder
    player_id?: SortOrder
    status?: SortOrder
    starts_at?: SortOrder
    ends_at?: SortOrder
    provider?: SortOrder
    external_id?: SortOrder
    amount_cents?: SortOrder
    currency?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type boostSumOrderByAggregateInput = {
    amount_cents?: SortOrder
  }

  export type Enumboost_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.boost_status | Enumboost_statusFieldRefInput<$PrismaModel>
    in?: $Enums.boost_status[] | ListEnumboost_statusFieldRefInput<$PrismaModel>
    notIn?: $Enums.boost_status[] | ListEnumboost_statusFieldRefInput<$PrismaModel>
    not?: NestedEnumboost_statusWithAggregatesFilter<$PrismaModel> | $Enums.boost_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumboost_statusFilter<$PrismaModel>
    _max?: NestedEnumboost_statusFilter<$PrismaModel>
  }

  export type Enumprovider_kindWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.provider_kind | Enumprovider_kindFieldRefInput<$PrismaModel>
    in?: $Enums.provider_kind[] | ListEnumprovider_kindFieldRefInput<$PrismaModel>
    notIn?: $Enums.provider_kind[] | ListEnumprovider_kindFieldRefInput<$PrismaModel>
    not?: NestedEnumprovider_kindWithAggregatesFilter<$PrismaModel> | $Enums.provider_kind
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumprovider_kindFilter<$PrismaModel>
    _max?: NestedEnumprovider_kindFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type Enumreport_reasonFilter<$PrismaModel = never> = {
    equals?: $Enums.report_reason | Enumreport_reasonFieldRefInput<$PrismaModel>
    in?: $Enums.report_reason[] | ListEnumreport_reasonFieldRefInput<$PrismaModel>
    notIn?: $Enums.report_reason[] | ListEnumreport_reasonFieldRefInput<$PrismaModel>
    not?: NestedEnumreport_reasonFilter<$PrismaModel> | $Enums.report_reason
  }

  export type Enumseverity_levelFilter<$PrismaModel = never> = {
    equals?: $Enums.severity_level | Enumseverity_levelFieldRefInput<$PrismaModel>
    in?: $Enums.severity_level[] | ListEnumseverity_levelFieldRefInput<$PrismaModel>
    notIn?: $Enums.severity_level[] | ListEnumseverity_levelFieldRefInput<$PrismaModel>
    not?: NestedEnumseverity_levelFilter<$PrismaModel> | $Enums.severity_level
  }

  export type Enumreport_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.report_status | Enumreport_statusFieldRefInput<$PrismaModel>
    in?: $Enums.report_status[] | ListEnumreport_statusFieldRefInput<$PrismaModel>
    notIn?: $Enums.report_status[] | ListEnumreport_statusFieldRefInput<$PrismaModel>
    not?: NestedEnumreport_statusFilter<$PrismaModel> | $Enums.report_status
  }

  export type MediaNullableScalarRelationFilter = {
    is?: mediaWhereInput | null
    isNot?: mediaWhereInput | null
  }

  export type UserNullableScalarRelationFilter = {
    is?: userWhereInput | null
    isNot?: userWhereInput | null
  }

  export type reportCountOrderByAggregateInput = {
    id?: SortOrder
    reporter_user_id?: SortOrder
    target_type?: SortOrder
    target_id?: SortOrder
    reason?: SortOrder
    details?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    resolution_note?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type reportMaxOrderByAggregateInput = {
    id?: SortOrder
    reporter_user_id?: SortOrder
    target_type?: SortOrder
    target_id?: SortOrder
    reason?: SortOrder
    details?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    resolution_note?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type reportMinOrderByAggregateInput = {
    id?: SortOrder
    reporter_user_id?: SortOrder
    target_type?: SortOrder
    target_id?: SortOrder
    reason?: SortOrder
    details?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    resolution_note?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type Enumreport_reasonWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.report_reason | Enumreport_reasonFieldRefInput<$PrismaModel>
    in?: $Enums.report_reason[] | ListEnumreport_reasonFieldRefInput<$PrismaModel>
    notIn?: $Enums.report_reason[] | ListEnumreport_reasonFieldRefInput<$PrismaModel>
    not?: NestedEnumreport_reasonWithAggregatesFilter<$PrismaModel> | $Enums.report_reason
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumreport_reasonFilter<$PrismaModel>
    _max?: NestedEnumreport_reasonFilter<$PrismaModel>
  }

  export type Enumseverity_levelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.severity_level | Enumseverity_levelFieldRefInput<$PrismaModel>
    in?: $Enums.severity_level[] | ListEnumseverity_levelFieldRefInput<$PrismaModel>
    notIn?: $Enums.severity_level[] | ListEnumseverity_levelFieldRefInput<$PrismaModel>
    not?: NestedEnumseverity_levelWithAggregatesFilter<$PrismaModel> | $Enums.severity_level
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumseverity_levelFilter<$PrismaModel>
    _max?: NestedEnumseverity_levelFilter<$PrismaModel>
  }

  export type Enumreport_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.report_status | Enumreport_statusFieldRefInput<$PrismaModel>
    in?: $Enums.report_status[] | ListEnumreport_statusFieldRefInput<$PrismaModel>
    notIn?: $Enums.report_status[] | ListEnumreport_statusFieldRefInput<$PrismaModel>
    not?: NestedEnumreport_statusWithAggregatesFilter<$PrismaModel> | $Enums.report_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumreport_statusFilter<$PrismaModel>
    _max?: NestedEnumreport_statusFilter<$PrismaModel>
  }

  export type strikeCountOrderByAggregateInput = {
    id?: SortOrder
    player_id?: SortOrder
    reason?: SortOrder
    severity?: SortOrder
    expires_at?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type strikeMaxOrderByAggregateInput = {
    id?: SortOrder
    player_id?: SortOrder
    reason?: SortOrder
    severity?: SortOrder
    expires_at?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type strikeMinOrderByAggregateInput = {
    id?: SortOrder
    player_id?: SortOrder
    reason?: SortOrder
    severity?: SortOrder
    expires_at?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type user_noteCountOrderByAggregateInput = {
    id?: SortOrder
    player_id?: SortOrder
    author_id?: SortOrder
    note?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type user_noteMaxOrderByAggregateInput = {
    id?: SortOrder
    player_id?: SortOrder
    author_id?: SortOrder
    note?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type user_noteMinOrderByAggregateInput = {
    id?: SortOrder
    player_id?: SortOrder
    author_id?: SortOrder
    note?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type Enumannouncement_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.announcement_status | Enumannouncement_statusFieldRefInput<$PrismaModel>
    in?: $Enums.announcement_status[] | ListEnumannouncement_statusFieldRefInput<$PrismaModel>
    notIn?: $Enums.announcement_status[] | ListEnumannouncement_statusFieldRefInput<$PrismaModel>
    not?: NestedEnumannouncement_statusFilter<$PrismaModel> | $Enums.announcement_status
  }

  export type announcementCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    body_md?: SortOrder
    status?: SortOrder
    starts_at?: SortOrder
    ends_at?: SortOrder
    segment_tags?: SortOrder
    segment_states?: SortOrder
    segment_devices?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type announcementMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    body_md?: SortOrder
    status?: SortOrder
    starts_at?: SortOrder
    ends_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type announcementMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    body_md?: SortOrder
    status?: SortOrder
    starts_at?: SortOrder
    ends_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type Enumannouncement_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.announcement_status | Enumannouncement_statusFieldRefInput<$PrismaModel>
    in?: $Enums.announcement_status[] | ListEnumannouncement_statusFieldRefInput<$PrismaModel>
    notIn?: $Enums.announcement_status[] | ListEnumannouncement_statusFieldRefInput<$PrismaModel>
    not?: NestedEnumannouncement_statusWithAggregatesFilter<$PrismaModel> | $Enums.announcement_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumannouncement_statusFilter<$PrismaModel>
    _max?: NestedEnumannouncement_statusFilter<$PrismaModel>
  }

  export type Enumfeature_slot_keyFilter<$PrismaModel = never> = {
    equals?: $Enums.feature_slot_key | Enumfeature_slot_keyFieldRefInput<$PrismaModel>
    in?: $Enums.feature_slot_key[] | ListEnumfeature_slot_keyFieldRefInput<$PrismaModel>
    notIn?: $Enums.feature_slot_key[] | ListEnumfeature_slot_keyFieldRefInput<$PrismaModel>
    not?: NestedEnumfeature_slot_keyFilter<$PrismaModel> | $Enums.feature_slot_key
  }

  export type feature_slotCountOrderByAggregateInput = {
    id?: SortOrder
    slot_key?: SortOrder
    description?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type feature_slotMaxOrderByAggregateInput = {
    id?: SortOrder
    slot_key?: SortOrder
    description?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type feature_slotMinOrderByAggregateInput = {
    id?: SortOrder
    slot_key?: SortOrder
    description?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type Enumfeature_slot_keyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.feature_slot_key | Enumfeature_slot_keyFieldRefInput<$PrismaModel>
    in?: $Enums.feature_slot_key[] | ListEnumfeature_slot_keyFieldRefInput<$PrismaModel>
    notIn?: $Enums.feature_slot_key[] | ListEnumfeature_slot_keyFieldRefInput<$PrismaModel>
    not?: NestedEnumfeature_slot_keyWithAggregatesFilter<$PrismaModel> | $Enums.feature_slot_key
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumfeature_slot_keyFilter<$PrismaModel>
    _max?: NestedEnumfeature_slot_keyFilter<$PrismaModel>
  }

  export type featured_assignmentCountOrderByAggregateInput = {
    id?: SortOrder
    slot_key?: SortOrder
    player_id?: SortOrder
    media_id?: SortOrder
    starts_at?: SortOrder
    ends_at?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type featured_assignmentAvgOrderByAggregateInput = {
    priority?: SortOrder
  }

  export type featured_assignmentMaxOrderByAggregateInput = {
    id?: SortOrder
    slot_key?: SortOrder
    player_id?: SortOrder
    media_id?: SortOrder
    starts_at?: SortOrder
    ends_at?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type featured_assignmentMinOrderByAggregateInput = {
    id?: SortOrder
    slot_key?: SortOrder
    player_id?: SortOrder
    media_id?: SortOrder
    starts_at?: SortOrder
    ends_at?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type featured_assignmentSumOrderByAggregateInput = {
    priority?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
  }

  export type settingCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value_json?: SortOrder
    status?: SortOrder
    version?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type settingAvgOrderByAggregateInput = {
    version?: SortOrder
  }

  export type settingMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    status?: SortOrder
    version?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type settingMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    status?: SortOrder
    version?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type settingSumOrderByAggregateInput = {
    version?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type Enumticket_priorityFilter<$PrismaModel = never> = {
    equals?: $Enums.ticket_priority | Enumticket_priorityFieldRefInput<$PrismaModel>
    in?: $Enums.ticket_priority[] | ListEnumticket_priorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.ticket_priority[] | ListEnumticket_priorityFieldRefInput<$PrismaModel>
    not?: NestedEnumticket_priorityFilter<$PrismaModel> | $Enums.ticket_priority
  }

  export type Enumticket_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.ticket_status | Enumticket_statusFieldRefInput<$PrismaModel>
    in?: $Enums.ticket_status[] | ListEnumticket_statusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ticket_status[] | ListEnumticket_statusFieldRefInput<$PrismaModel>
    not?: NestedEnumticket_statusFilter<$PrismaModel> | $Enums.ticket_status
  }

  export type support_ticketCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    email?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    assigned_to?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type support_ticketMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    email?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    assigned_to?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type support_ticketMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    email?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    assigned_to?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type Enumticket_priorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ticket_priority | Enumticket_priorityFieldRefInput<$PrismaModel>
    in?: $Enums.ticket_priority[] | ListEnumticket_priorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.ticket_priority[] | ListEnumticket_priorityFieldRefInput<$PrismaModel>
    not?: NestedEnumticket_priorityWithAggregatesFilter<$PrismaModel> | $Enums.ticket_priority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumticket_priorityFilter<$PrismaModel>
    _max?: NestedEnumticket_priorityFilter<$PrismaModel>
  }

  export type Enumticket_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ticket_status | Enumticket_statusFieldRefInput<$PrismaModel>
    in?: $Enums.ticket_status[] | ListEnumticket_statusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ticket_status[] | ListEnumticket_statusFieldRefInput<$PrismaModel>
    not?: NestedEnumticket_statusWithAggregatesFilter<$PrismaModel> | $Enums.ticket_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumticket_statusFilter<$PrismaModel>
    _max?: NestedEnumticket_statusFilter<$PrismaModel>
  }

  export type Enumcontact_channelFilter<$PrismaModel = never> = {
    equals?: $Enums.contact_channel | Enumcontact_channelFieldRefInput<$PrismaModel>
    in?: $Enums.contact_channel[] | ListEnumcontact_channelFieldRefInput<$PrismaModel>
    notIn?: $Enums.contact_channel[] | ListEnumcontact_channelFieldRefInput<$PrismaModel>
    not?: NestedEnumcontact_channelFilter<$PrismaModel> | $Enums.contact_channel
  }

  export type contact_eventCountOrderByAggregateInput = {
    id?: SortOrder
    player_id?: SortOrder
    channel?: SortOrder
    requester_ip?: SortOrder
    user_agent?: SortOrder
    referrer?: SortOrder
    message?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type contact_eventMaxOrderByAggregateInput = {
    id?: SortOrder
    player_id?: SortOrder
    channel?: SortOrder
    requester_ip?: SortOrder
    user_agent?: SortOrder
    referrer?: SortOrder
    message?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type contact_eventMinOrderByAggregateInput = {
    id?: SortOrder
    player_id?: SortOrder
    channel?: SortOrder
    requester_ip?: SortOrder
    user_agent?: SortOrder
    referrer?: SortOrder
    message?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type Enumcontact_channelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.contact_channel | Enumcontact_channelFieldRefInput<$PrismaModel>
    in?: $Enums.contact_channel[] | ListEnumcontact_channelFieldRefInput<$PrismaModel>
    notIn?: $Enums.contact_channel[] | ListEnumcontact_channelFieldRefInput<$PrismaModel>
    not?: NestedEnumcontact_channelWithAggregatesFilter<$PrismaModel> | $Enums.contact_channel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumcontact_channelFilter<$PrismaModel>
    _max?: NestedEnumcontact_channelFilter<$PrismaModel>
  }

  export type Enumuser_roleNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.user_role | Enumuser_roleFieldRefInput<$PrismaModel> | null
    in?: $Enums.user_role[] | ListEnumuser_roleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.user_role[] | ListEnumuser_roleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumuser_roleNullableFilter<$PrismaModel> | $Enums.user_role | null
    isSet?: boolean
  }

  export type Enumaudit_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.audit_status | Enumaudit_statusFieldRefInput<$PrismaModel>
    in?: $Enums.audit_status[] | ListEnumaudit_statusFieldRefInput<$PrismaModel>
    notIn?: $Enums.audit_status[] | ListEnumaudit_statusFieldRefInput<$PrismaModel>
    not?: NestedEnumaudit_statusFilter<$PrismaModel> | $Enums.audit_status
  }

  export type audit_logCountOrderByAggregateInput = {
    id?: SortOrder
    actor_user_id?: SortOrder
    actor_role?: SortOrder
    entity_type?: SortOrder
    entity_id?: SortOrder
    action?: SortOrder
    payload?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type audit_logMaxOrderByAggregateInput = {
    id?: SortOrder
    actor_user_id?: SortOrder
    actor_role?: SortOrder
    entity_type?: SortOrder
    entity_id?: SortOrder
    action?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type audit_logMinOrderByAggregateInput = {
    id?: SortOrder
    actor_user_id?: SortOrder
    actor_role?: SortOrder
    entity_type?: SortOrder
    entity_id?: SortOrder
    action?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type Enumuser_roleNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.user_role | Enumuser_roleFieldRefInput<$PrismaModel> | null
    in?: $Enums.user_role[] | ListEnumuser_roleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.user_role[] | ListEnumuser_roleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumuser_roleNullableWithAggregatesFilter<$PrismaModel> | $Enums.user_role | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumuser_roleNullableFilter<$PrismaModel>
    _max?: NestedEnumuser_roleNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type Enumaudit_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.audit_status | Enumaudit_statusFieldRefInput<$PrismaModel>
    in?: $Enums.audit_status[] | ListEnumaudit_statusFieldRefInput<$PrismaModel>
    notIn?: $Enums.audit_status[] | ListEnumaudit_statusFieldRefInput<$PrismaModel>
    not?: NestedEnumaudit_statusWithAggregatesFilter<$PrismaModel> | $Enums.audit_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumaudit_statusFilter<$PrismaModel>
    _max?: NestedEnumaudit_statusFilter<$PrismaModel>
  }

  export type Enumwebhook_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.webhook_status | Enumwebhook_statusFieldRefInput<$PrismaModel>
    in?: $Enums.webhook_status[] | ListEnumwebhook_statusFieldRefInput<$PrismaModel>
    notIn?: $Enums.webhook_status[] | ListEnumwebhook_statusFieldRefInput<$PrismaModel>
    not?: NestedEnumwebhook_statusFilter<$PrismaModel> | $Enums.webhook_status
  }

  export type webhook_eventCountOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    event_type?: SortOrder
    payload?: SortOrder
    related_type?: SortOrder
    related_id?: SortOrder
    status?: SortOrder
    retry_count?: SortOrder
    last_error?: SortOrder
    next_retry_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type webhook_eventAvgOrderByAggregateInput = {
    retry_count?: SortOrder
  }

  export type webhook_eventMaxOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    event_type?: SortOrder
    related_type?: SortOrder
    related_id?: SortOrder
    status?: SortOrder
    retry_count?: SortOrder
    last_error?: SortOrder
    next_retry_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type webhook_eventMinOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    event_type?: SortOrder
    related_type?: SortOrder
    related_id?: SortOrder
    status?: SortOrder
    retry_count?: SortOrder
    last_error?: SortOrder
    next_retry_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type webhook_eventSumOrderByAggregateInput = {
    retry_count?: SortOrder
  }

  export type Enumwebhook_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.webhook_status | Enumwebhook_statusFieldRefInput<$PrismaModel>
    in?: $Enums.webhook_status[] | ListEnumwebhook_statusFieldRefInput<$PrismaModel>
    notIn?: $Enums.webhook_status[] | ListEnumwebhook_statusFieldRefInput<$PrismaModel>
    not?: NestedEnumwebhook_statusWithAggregatesFilter<$PrismaModel> | $Enums.webhook_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumwebhook_statusFilter<$PrismaModel>
    _max?: NestedEnumwebhook_statusFilter<$PrismaModel>
  }

  export type sessionCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    session_token?: SortOrder
    ip?: SortOrder
    user_agent?: SortOrder
    expires_at?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type sessionMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    session_token?: SortOrder
    ip?: SortOrder
    user_agent?: SortOrder
    expires_at?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type sessionMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    session_token?: SortOrder
    ip?: SortOrder
    user_agent?: SortOrder
    expires_at?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type profileCreateNestedOneWithoutUserInput = {
    create?: XOR<profileCreateWithoutUserInput, profileUncheckedCreateWithoutUserInput>
    connectOrCreate?: profileCreateOrConnectWithoutUserInput
    connect?: profileWhereUniqueInput
  }

  export type support_ticketCreateNestedManyWithoutUserInput = {
    create?: XOR<support_ticketCreateWithoutUserInput, support_ticketUncheckedCreateWithoutUserInput> | support_ticketCreateWithoutUserInput[] | support_ticketUncheckedCreateWithoutUserInput[]
    connectOrCreate?: support_ticketCreateOrConnectWithoutUserInput | support_ticketCreateOrConnectWithoutUserInput[]
    createMany?: support_ticketCreateManyUserInputEnvelope
    connect?: support_ticketWhereUniqueInput | support_ticketWhereUniqueInput[]
  }

  export type support_ticketCreateNestedManyWithoutAssigneeInput = {
    create?: XOR<support_ticketCreateWithoutAssigneeInput, support_ticketUncheckedCreateWithoutAssigneeInput> | support_ticketCreateWithoutAssigneeInput[] | support_ticketUncheckedCreateWithoutAssigneeInput[]
    connectOrCreate?: support_ticketCreateOrConnectWithoutAssigneeInput | support_ticketCreateOrConnectWithoutAssigneeInput[]
    createMany?: support_ticketCreateManyAssigneeInputEnvelope
    connect?: support_ticketWhereUniqueInput | support_ticketWhereUniqueInput[]
  }

  export type reportCreateNestedManyWithoutReporter_userInput = {
    create?: XOR<reportCreateWithoutReporter_userInput, reportUncheckedCreateWithoutReporter_userInput> | reportCreateWithoutReporter_userInput[] | reportUncheckedCreateWithoutReporter_userInput[]
    connectOrCreate?: reportCreateOrConnectWithoutReporter_userInput | reportCreateOrConnectWithoutReporter_userInput[]
    createMany?: reportCreateManyReporter_userInputEnvelope
    connect?: reportWhereUniqueInput | reportWhereUniqueInput[]
  }

  export type user_noteCreateNestedManyWithoutAuthorInput = {
    create?: XOR<user_noteCreateWithoutAuthorInput, user_noteUncheckedCreateWithoutAuthorInput> | user_noteCreateWithoutAuthorInput[] | user_noteUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: user_noteCreateOrConnectWithoutAuthorInput | user_noteCreateOrConnectWithoutAuthorInput[]
    createMany?: user_noteCreateManyAuthorInputEnvelope
    connect?: user_noteWhereUniqueInput | user_noteWhereUniqueInput[]
  }

  export type sessionCreateNestedManyWithoutUserInput = {
    create?: XOR<sessionCreateWithoutUserInput, sessionUncheckedCreateWithoutUserInput> | sessionCreateWithoutUserInput[] | sessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: sessionCreateOrConnectWithoutUserInput | sessionCreateOrConnectWithoutUserInput[]
    createMany?: sessionCreateManyUserInputEnvelope
    connect?: sessionWhereUniqueInput | sessionWhereUniqueInput[]
  }

  export type profileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<profileCreateWithoutUserInput, profileUncheckedCreateWithoutUserInput>
    connectOrCreate?: profileCreateOrConnectWithoutUserInput
    connect?: profileWhereUniqueInput
  }

  export type support_ticketUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<support_ticketCreateWithoutUserInput, support_ticketUncheckedCreateWithoutUserInput> | support_ticketCreateWithoutUserInput[] | support_ticketUncheckedCreateWithoutUserInput[]
    connectOrCreate?: support_ticketCreateOrConnectWithoutUserInput | support_ticketCreateOrConnectWithoutUserInput[]
    createMany?: support_ticketCreateManyUserInputEnvelope
    connect?: support_ticketWhereUniqueInput | support_ticketWhereUniqueInput[]
  }

  export type support_ticketUncheckedCreateNestedManyWithoutAssigneeInput = {
    create?: XOR<support_ticketCreateWithoutAssigneeInput, support_ticketUncheckedCreateWithoutAssigneeInput> | support_ticketCreateWithoutAssigneeInput[] | support_ticketUncheckedCreateWithoutAssigneeInput[]
    connectOrCreate?: support_ticketCreateOrConnectWithoutAssigneeInput | support_ticketCreateOrConnectWithoutAssigneeInput[]
    createMany?: support_ticketCreateManyAssigneeInputEnvelope
    connect?: support_ticketWhereUniqueInput | support_ticketWhereUniqueInput[]
  }

  export type reportUncheckedCreateNestedManyWithoutReporter_userInput = {
    create?: XOR<reportCreateWithoutReporter_userInput, reportUncheckedCreateWithoutReporter_userInput> | reportCreateWithoutReporter_userInput[] | reportUncheckedCreateWithoutReporter_userInput[]
    connectOrCreate?: reportCreateOrConnectWithoutReporter_userInput | reportCreateOrConnectWithoutReporter_userInput[]
    createMany?: reportCreateManyReporter_userInputEnvelope
    connect?: reportWhereUniqueInput | reportWhereUniqueInput[]
  }

  export type user_noteUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<user_noteCreateWithoutAuthorInput, user_noteUncheckedCreateWithoutAuthorInput> | user_noteCreateWithoutAuthorInput[] | user_noteUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: user_noteCreateOrConnectWithoutAuthorInput | user_noteCreateOrConnectWithoutAuthorInput[]
    createMany?: user_noteCreateManyAuthorInputEnvelope
    connect?: user_noteWhereUniqueInput | user_noteWhereUniqueInput[]
  }

  export type sessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<sessionCreateWithoutUserInput, sessionUncheckedCreateWithoutUserInput> | sessionCreateWithoutUserInput[] | sessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: sessionCreateOrConnectWithoutUserInput | sessionCreateOrConnectWithoutUserInput[]
    createMany?: sessionCreateManyUserInputEnvelope
    connect?: sessionWhereUniqueInput | sessionWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type Enumuser_roleFieldUpdateOperationsInput = {
    set?: $Enums.user_role
  }

  export type Enumuser_statusFieldUpdateOperationsInput = {
    set?: $Enums.user_status
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
    unset?: boolean
  }

  export type profileUpdateOneWithoutUserNestedInput = {
    create?: XOR<profileCreateWithoutUserInput, profileUncheckedCreateWithoutUserInput>
    connectOrCreate?: profileCreateOrConnectWithoutUserInput
    upsert?: profileUpsertWithoutUserInput
    disconnect?: profileWhereInput | boolean
    delete?: profileWhereInput | boolean
    connect?: profileWhereUniqueInput
    update?: XOR<XOR<profileUpdateToOneWithWhereWithoutUserInput, profileUpdateWithoutUserInput>, profileUncheckedUpdateWithoutUserInput>
  }

  export type support_ticketUpdateManyWithoutUserNestedInput = {
    create?: XOR<support_ticketCreateWithoutUserInput, support_ticketUncheckedCreateWithoutUserInput> | support_ticketCreateWithoutUserInput[] | support_ticketUncheckedCreateWithoutUserInput[]
    connectOrCreate?: support_ticketCreateOrConnectWithoutUserInput | support_ticketCreateOrConnectWithoutUserInput[]
    upsert?: support_ticketUpsertWithWhereUniqueWithoutUserInput | support_ticketUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: support_ticketCreateManyUserInputEnvelope
    set?: support_ticketWhereUniqueInput | support_ticketWhereUniqueInput[]
    disconnect?: support_ticketWhereUniqueInput | support_ticketWhereUniqueInput[]
    delete?: support_ticketWhereUniqueInput | support_ticketWhereUniqueInput[]
    connect?: support_ticketWhereUniqueInput | support_ticketWhereUniqueInput[]
    update?: support_ticketUpdateWithWhereUniqueWithoutUserInput | support_ticketUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: support_ticketUpdateManyWithWhereWithoutUserInput | support_ticketUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: support_ticketScalarWhereInput | support_ticketScalarWhereInput[]
  }

  export type support_ticketUpdateManyWithoutAssigneeNestedInput = {
    create?: XOR<support_ticketCreateWithoutAssigneeInput, support_ticketUncheckedCreateWithoutAssigneeInput> | support_ticketCreateWithoutAssigneeInput[] | support_ticketUncheckedCreateWithoutAssigneeInput[]
    connectOrCreate?: support_ticketCreateOrConnectWithoutAssigneeInput | support_ticketCreateOrConnectWithoutAssigneeInput[]
    upsert?: support_ticketUpsertWithWhereUniqueWithoutAssigneeInput | support_ticketUpsertWithWhereUniqueWithoutAssigneeInput[]
    createMany?: support_ticketCreateManyAssigneeInputEnvelope
    set?: support_ticketWhereUniqueInput | support_ticketWhereUniqueInput[]
    disconnect?: support_ticketWhereUniqueInput | support_ticketWhereUniqueInput[]
    delete?: support_ticketWhereUniqueInput | support_ticketWhereUniqueInput[]
    connect?: support_ticketWhereUniqueInput | support_ticketWhereUniqueInput[]
    update?: support_ticketUpdateWithWhereUniqueWithoutAssigneeInput | support_ticketUpdateWithWhereUniqueWithoutAssigneeInput[]
    updateMany?: support_ticketUpdateManyWithWhereWithoutAssigneeInput | support_ticketUpdateManyWithWhereWithoutAssigneeInput[]
    deleteMany?: support_ticketScalarWhereInput | support_ticketScalarWhereInput[]
  }

  export type reportUpdateManyWithoutReporter_userNestedInput = {
    create?: XOR<reportCreateWithoutReporter_userInput, reportUncheckedCreateWithoutReporter_userInput> | reportCreateWithoutReporter_userInput[] | reportUncheckedCreateWithoutReporter_userInput[]
    connectOrCreate?: reportCreateOrConnectWithoutReporter_userInput | reportCreateOrConnectWithoutReporter_userInput[]
    upsert?: reportUpsertWithWhereUniqueWithoutReporter_userInput | reportUpsertWithWhereUniqueWithoutReporter_userInput[]
    createMany?: reportCreateManyReporter_userInputEnvelope
    set?: reportWhereUniqueInput | reportWhereUniqueInput[]
    disconnect?: reportWhereUniqueInput | reportWhereUniqueInput[]
    delete?: reportWhereUniqueInput | reportWhereUniqueInput[]
    connect?: reportWhereUniqueInput | reportWhereUniqueInput[]
    update?: reportUpdateWithWhereUniqueWithoutReporter_userInput | reportUpdateWithWhereUniqueWithoutReporter_userInput[]
    updateMany?: reportUpdateManyWithWhereWithoutReporter_userInput | reportUpdateManyWithWhereWithoutReporter_userInput[]
    deleteMany?: reportScalarWhereInput | reportScalarWhereInput[]
  }

  export type user_noteUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<user_noteCreateWithoutAuthorInput, user_noteUncheckedCreateWithoutAuthorInput> | user_noteCreateWithoutAuthorInput[] | user_noteUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: user_noteCreateOrConnectWithoutAuthorInput | user_noteCreateOrConnectWithoutAuthorInput[]
    upsert?: user_noteUpsertWithWhereUniqueWithoutAuthorInput | user_noteUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: user_noteCreateManyAuthorInputEnvelope
    set?: user_noteWhereUniqueInput | user_noteWhereUniqueInput[]
    disconnect?: user_noteWhereUniqueInput | user_noteWhereUniqueInput[]
    delete?: user_noteWhereUniqueInput | user_noteWhereUniqueInput[]
    connect?: user_noteWhereUniqueInput | user_noteWhereUniqueInput[]
    update?: user_noteUpdateWithWhereUniqueWithoutAuthorInput | user_noteUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: user_noteUpdateManyWithWhereWithoutAuthorInput | user_noteUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: user_noteScalarWhereInput | user_noteScalarWhereInput[]
  }

  export type sessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<sessionCreateWithoutUserInput, sessionUncheckedCreateWithoutUserInput> | sessionCreateWithoutUserInput[] | sessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: sessionCreateOrConnectWithoutUserInput | sessionCreateOrConnectWithoutUserInput[]
    upsert?: sessionUpsertWithWhereUniqueWithoutUserInput | sessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: sessionCreateManyUserInputEnvelope
    set?: sessionWhereUniqueInput | sessionWhereUniqueInput[]
    disconnect?: sessionWhereUniqueInput | sessionWhereUniqueInput[]
    delete?: sessionWhereUniqueInput | sessionWhereUniqueInput[]
    connect?: sessionWhereUniqueInput | sessionWhereUniqueInput[]
    update?: sessionUpdateWithWhereUniqueWithoutUserInput | sessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: sessionUpdateManyWithWhereWithoutUserInput | sessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: sessionScalarWhereInput | sessionScalarWhereInput[]
  }

  export type profileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<profileCreateWithoutUserInput, profileUncheckedCreateWithoutUserInput>
    connectOrCreate?: profileCreateOrConnectWithoutUserInput
    upsert?: profileUpsertWithoutUserInput
    disconnect?: profileWhereInput | boolean
    delete?: profileWhereInput | boolean
    connect?: profileWhereUniqueInput
    update?: XOR<XOR<profileUpdateToOneWithWhereWithoutUserInput, profileUpdateWithoutUserInput>, profileUncheckedUpdateWithoutUserInput>
  }

  export type support_ticketUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<support_ticketCreateWithoutUserInput, support_ticketUncheckedCreateWithoutUserInput> | support_ticketCreateWithoutUserInput[] | support_ticketUncheckedCreateWithoutUserInput[]
    connectOrCreate?: support_ticketCreateOrConnectWithoutUserInput | support_ticketCreateOrConnectWithoutUserInput[]
    upsert?: support_ticketUpsertWithWhereUniqueWithoutUserInput | support_ticketUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: support_ticketCreateManyUserInputEnvelope
    set?: support_ticketWhereUniqueInput | support_ticketWhereUniqueInput[]
    disconnect?: support_ticketWhereUniqueInput | support_ticketWhereUniqueInput[]
    delete?: support_ticketWhereUniqueInput | support_ticketWhereUniqueInput[]
    connect?: support_ticketWhereUniqueInput | support_ticketWhereUniqueInput[]
    update?: support_ticketUpdateWithWhereUniqueWithoutUserInput | support_ticketUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: support_ticketUpdateManyWithWhereWithoutUserInput | support_ticketUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: support_ticketScalarWhereInput | support_ticketScalarWhereInput[]
  }

  export type support_ticketUncheckedUpdateManyWithoutAssigneeNestedInput = {
    create?: XOR<support_ticketCreateWithoutAssigneeInput, support_ticketUncheckedCreateWithoutAssigneeInput> | support_ticketCreateWithoutAssigneeInput[] | support_ticketUncheckedCreateWithoutAssigneeInput[]
    connectOrCreate?: support_ticketCreateOrConnectWithoutAssigneeInput | support_ticketCreateOrConnectWithoutAssigneeInput[]
    upsert?: support_ticketUpsertWithWhereUniqueWithoutAssigneeInput | support_ticketUpsertWithWhereUniqueWithoutAssigneeInput[]
    createMany?: support_ticketCreateManyAssigneeInputEnvelope
    set?: support_ticketWhereUniqueInput | support_ticketWhereUniqueInput[]
    disconnect?: support_ticketWhereUniqueInput | support_ticketWhereUniqueInput[]
    delete?: support_ticketWhereUniqueInput | support_ticketWhereUniqueInput[]
    connect?: support_ticketWhereUniqueInput | support_ticketWhereUniqueInput[]
    update?: support_ticketUpdateWithWhereUniqueWithoutAssigneeInput | support_ticketUpdateWithWhereUniqueWithoutAssigneeInput[]
    updateMany?: support_ticketUpdateManyWithWhereWithoutAssigneeInput | support_ticketUpdateManyWithWhereWithoutAssigneeInput[]
    deleteMany?: support_ticketScalarWhereInput | support_ticketScalarWhereInput[]
  }

  export type reportUncheckedUpdateManyWithoutReporter_userNestedInput = {
    create?: XOR<reportCreateWithoutReporter_userInput, reportUncheckedCreateWithoutReporter_userInput> | reportCreateWithoutReporter_userInput[] | reportUncheckedCreateWithoutReporter_userInput[]
    connectOrCreate?: reportCreateOrConnectWithoutReporter_userInput | reportCreateOrConnectWithoutReporter_userInput[]
    upsert?: reportUpsertWithWhereUniqueWithoutReporter_userInput | reportUpsertWithWhereUniqueWithoutReporter_userInput[]
    createMany?: reportCreateManyReporter_userInputEnvelope
    set?: reportWhereUniqueInput | reportWhereUniqueInput[]
    disconnect?: reportWhereUniqueInput | reportWhereUniqueInput[]
    delete?: reportWhereUniqueInput | reportWhereUniqueInput[]
    connect?: reportWhereUniqueInput | reportWhereUniqueInput[]
    update?: reportUpdateWithWhereUniqueWithoutReporter_userInput | reportUpdateWithWhereUniqueWithoutReporter_userInput[]
    updateMany?: reportUpdateManyWithWhereWithoutReporter_userInput | reportUpdateManyWithWhereWithoutReporter_userInput[]
    deleteMany?: reportScalarWhereInput | reportScalarWhereInput[]
  }

  export type user_noteUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<user_noteCreateWithoutAuthorInput, user_noteUncheckedCreateWithoutAuthorInput> | user_noteCreateWithoutAuthorInput[] | user_noteUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: user_noteCreateOrConnectWithoutAuthorInput | user_noteCreateOrConnectWithoutAuthorInput[]
    upsert?: user_noteUpsertWithWhereUniqueWithoutAuthorInput | user_noteUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: user_noteCreateManyAuthorInputEnvelope
    set?: user_noteWhereUniqueInput | user_noteWhereUniqueInput[]
    disconnect?: user_noteWhereUniqueInput | user_noteWhereUniqueInput[]
    delete?: user_noteWhereUniqueInput | user_noteWhereUniqueInput[]
    connect?: user_noteWhereUniqueInput | user_noteWhereUniqueInput[]
    update?: user_noteUpdateWithWhereUniqueWithoutAuthorInput | user_noteUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: user_noteUpdateManyWithWhereWithoutAuthorInput | user_noteUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: user_noteScalarWhereInput | user_noteScalarWhereInput[]
  }

  export type sessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<sessionCreateWithoutUserInput, sessionUncheckedCreateWithoutUserInput> | sessionCreateWithoutUserInput[] | sessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: sessionCreateOrConnectWithoutUserInput | sessionCreateOrConnectWithoutUserInput[]
    upsert?: sessionUpsertWithWhereUniqueWithoutUserInput | sessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: sessionCreateManyUserInputEnvelope
    set?: sessionWhereUniqueInput | sessionWhereUniqueInput[]
    disconnect?: sessionWhereUniqueInput | sessionWhereUniqueInput[]
    delete?: sessionWhereUniqueInput | sessionWhereUniqueInput[]
    connect?: sessionWhereUniqueInput | sessionWhereUniqueInput[]
    update?: sessionUpdateWithWhereUniqueWithoutUserInput | sessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: sessionUpdateManyWithWhereWithoutUserInput | sessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: sessionScalarWhereInput | sessionScalarWhereInput[]
  }

  export type userCreateNestedOneWithoutProfileInput = {
    create?: XOR<userCreateWithoutProfileInput, userUncheckedCreateWithoutProfileInput>
    connectOrCreate?: userCreateOrConnectWithoutProfileInput
    connect?: userWhereUniqueInput
  }

  export type mediaCreateNestedManyWithoutPlayerInput = {
    create?: XOR<mediaCreateWithoutPlayerInput, mediaUncheckedCreateWithoutPlayerInput> | mediaCreateWithoutPlayerInput[] | mediaUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: mediaCreateOrConnectWithoutPlayerInput | mediaCreateOrConnectWithoutPlayerInput[]
    createMany?: mediaCreateManyPlayerInputEnvelope
    connect?: mediaWhereUniqueInput | mediaWhereUniqueInput[]
  }

  export type boostCreateNestedManyWithoutPlayerInput = {
    create?: XOR<boostCreateWithoutPlayerInput, boostUncheckedCreateWithoutPlayerInput> | boostCreateWithoutPlayerInput[] | boostUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: boostCreateOrConnectWithoutPlayerInput | boostCreateOrConnectWithoutPlayerInput[]
    createMany?: boostCreateManyPlayerInputEnvelope
    connect?: boostWhereUniqueInput | boostWhereUniqueInput[]
  }

  export type strikeCreateNestedManyWithoutPlayerInput = {
    create?: XOR<strikeCreateWithoutPlayerInput, strikeUncheckedCreateWithoutPlayerInput> | strikeCreateWithoutPlayerInput[] | strikeUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: strikeCreateOrConnectWithoutPlayerInput | strikeCreateOrConnectWithoutPlayerInput[]
    createMany?: strikeCreateManyPlayerInputEnvelope
    connect?: strikeWhereUniqueInput | strikeWhereUniqueInput[]
  }

  export type user_noteCreateNestedManyWithoutPlayerInput = {
    create?: XOR<user_noteCreateWithoutPlayerInput, user_noteUncheckedCreateWithoutPlayerInput> | user_noteCreateWithoutPlayerInput[] | user_noteUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: user_noteCreateOrConnectWithoutPlayerInput | user_noteCreateOrConnectWithoutPlayerInput[]
    createMany?: user_noteCreateManyPlayerInputEnvelope
    connect?: user_noteWhereUniqueInput | user_noteWhereUniqueInput[]
  }

  export type contact_eventCreateNestedManyWithoutPlayerInput = {
    create?: XOR<contact_eventCreateWithoutPlayerInput, contact_eventUncheckedCreateWithoutPlayerInput> | contact_eventCreateWithoutPlayerInput[] | contact_eventUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: contact_eventCreateOrConnectWithoutPlayerInput | contact_eventCreateOrConnectWithoutPlayerInput[]
    createMany?: contact_eventCreateManyPlayerInputEnvelope
    connect?: contact_eventWhereUniqueInput | contact_eventWhereUniqueInput[]
  }

  export type reportCreateNestedManyWithoutProfile_targetInput = {
    create?: XOR<reportCreateWithoutProfile_targetInput, reportUncheckedCreateWithoutProfile_targetInput> | reportCreateWithoutProfile_targetInput[] | reportUncheckedCreateWithoutProfile_targetInput[]
    connectOrCreate?: reportCreateOrConnectWithoutProfile_targetInput | reportCreateOrConnectWithoutProfile_targetInput[]
    createMany?: reportCreateManyProfile_targetInputEnvelope
    connect?: reportWhereUniqueInput | reportWhereUniqueInput[]
  }

  export type player_tagCreateNestedManyWithoutPlayerInput = {
    create?: XOR<player_tagCreateWithoutPlayerInput, player_tagUncheckedCreateWithoutPlayerInput> | player_tagCreateWithoutPlayerInput[] | player_tagUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: player_tagCreateOrConnectWithoutPlayerInput | player_tagCreateOrConnectWithoutPlayerInput[]
    createMany?: player_tagCreateManyPlayerInputEnvelope
    connect?: player_tagWhereUniqueInput | player_tagWhereUniqueInput[]
  }

  export type featured_assignmentCreateNestedManyWithoutPlayerInput = {
    create?: XOR<featured_assignmentCreateWithoutPlayerInput, featured_assignmentUncheckedCreateWithoutPlayerInput> | featured_assignmentCreateWithoutPlayerInput[] | featured_assignmentUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: featured_assignmentCreateOrConnectWithoutPlayerInput | featured_assignmentCreateOrConnectWithoutPlayerInput[]
    createMany?: featured_assignmentCreateManyPlayerInputEnvelope
    connect?: featured_assignmentWhereUniqueInput | featured_assignmentWhereUniqueInput[]
  }

  export type mediaUncheckedCreateNestedManyWithoutPlayerInput = {
    create?: XOR<mediaCreateWithoutPlayerInput, mediaUncheckedCreateWithoutPlayerInput> | mediaCreateWithoutPlayerInput[] | mediaUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: mediaCreateOrConnectWithoutPlayerInput | mediaCreateOrConnectWithoutPlayerInput[]
    createMany?: mediaCreateManyPlayerInputEnvelope
    connect?: mediaWhereUniqueInput | mediaWhereUniqueInput[]
  }

  export type boostUncheckedCreateNestedManyWithoutPlayerInput = {
    create?: XOR<boostCreateWithoutPlayerInput, boostUncheckedCreateWithoutPlayerInput> | boostCreateWithoutPlayerInput[] | boostUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: boostCreateOrConnectWithoutPlayerInput | boostCreateOrConnectWithoutPlayerInput[]
    createMany?: boostCreateManyPlayerInputEnvelope
    connect?: boostWhereUniqueInput | boostWhereUniqueInput[]
  }

  export type strikeUncheckedCreateNestedManyWithoutPlayerInput = {
    create?: XOR<strikeCreateWithoutPlayerInput, strikeUncheckedCreateWithoutPlayerInput> | strikeCreateWithoutPlayerInput[] | strikeUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: strikeCreateOrConnectWithoutPlayerInput | strikeCreateOrConnectWithoutPlayerInput[]
    createMany?: strikeCreateManyPlayerInputEnvelope
    connect?: strikeWhereUniqueInput | strikeWhereUniqueInput[]
  }

  export type user_noteUncheckedCreateNestedManyWithoutPlayerInput = {
    create?: XOR<user_noteCreateWithoutPlayerInput, user_noteUncheckedCreateWithoutPlayerInput> | user_noteCreateWithoutPlayerInput[] | user_noteUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: user_noteCreateOrConnectWithoutPlayerInput | user_noteCreateOrConnectWithoutPlayerInput[]
    createMany?: user_noteCreateManyPlayerInputEnvelope
    connect?: user_noteWhereUniqueInput | user_noteWhereUniqueInput[]
  }

  export type contact_eventUncheckedCreateNestedManyWithoutPlayerInput = {
    create?: XOR<contact_eventCreateWithoutPlayerInput, contact_eventUncheckedCreateWithoutPlayerInput> | contact_eventCreateWithoutPlayerInput[] | contact_eventUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: contact_eventCreateOrConnectWithoutPlayerInput | contact_eventCreateOrConnectWithoutPlayerInput[]
    createMany?: contact_eventCreateManyPlayerInputEnvelope
    connect?: contact_eventWhereUniqueInput | contact_eventWhereUniqueInput[]
  }

  export type reportUncheckedCreateNestedManyWithoutProfile_targetInput = {
    create?: XOR<reportCreateWithoutProfile_targetInput, reportUncheckedCreateWithoutProfile_targetInput> | reportCreateWithoutProfile_targetInput[] | reportUncheckedCreateWithoutProfile_targetInput[]
    connectOrCreate?: reportCreateOrConnectWithoutProfile_targetInput | reportCreateOrConnectWithoutProfile_targetInput[]
    createMany?: reportCreateManyProfile_targetInputEnvelope
    connect?: reportWhereUniqueInput | reportWhereUniqueInput[]
  }

  export type player_tagUncheckedCreateNestedManyWithoutPlayerInput = {
    create?: XOR<player_tagCreateWithoutPlayerInput, player_tagUncheckedCreateWithoutPlayerInput> | player_tagCreateWithoutPlayerInput[] | player_tagUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: player_tagCreateOrConnectWithoutPlayerInput | player_tagCreateOrConnectWithoutPlayerInput[]
    createMany?: player_tagCreateManyPlayerInputEnvelope
    connect?: player_tagWhereUniqueInput | player_tagWhereUniqueInput[]
  }

  export type featured_assignmentUncheckedCreateNestedManyWithoutPlayerInput = {
    create?: XOR<featured_assignmentCreateWithoutPlayerInput, featured_assignmentUncheckedCreateWithoutPlayerInput> | featured_assignmentCreateWithoutPlayerInput[] | featured_assignmentUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: featured_assignmentCreateOrConnectWithoutPlayerInput | featured_assignmentCreateOrConnectWithoutPlayerInput[]
    createMany?: featured_assignmentCreateManyPlayerInputEnvelope
    connect?: featured_assignmentWhereUniqueInput | featured_assignmentWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
    unset?: boolean
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
    unset?: boolean
  }

  export type Enumprofile_statusFieldUpdateOperationsInput = {
    set?: $Enums.profile_status
  }

  export type userUpdateOneRequiredWithoutProfileNestedInput = {
    create?: XOR<userCreateWithoutProfileInput, userUncheckedCreateWithoutProfileInput>
    connectOrCreate?: userCreateOrConnectWithoutProfileInput
    upsert?: userUpsertWithoutProfileInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutProfileInput, userUpdateWithoutProfileInput>, userUncheckedUpdateWithoutProfileInput>
  }

  export type mediaUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<mediaCreateWithoutPlayerInput, mediaUncheckedCreateWithoutPlayerInput> | mediaCreateWithoutPlayerInput[] | mediaUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: mediaCreateOrConnectWithoutPlayerInput | mediaCreateOrConnectWithoutPlayerInput[]
    upsert?: mediaUpsertWithWhereUniqueWithoutPlayerInput | mediaUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: mediaCreateManyPlayerInputEnvelope
    set?: mediaWhereUniqueInput | mediaWhereUniqueInput[]
    disconnect?: mediaWhereUniqueInput | mediaWhereUniqueInput[]
    delete?: mediaWhereUniqueInput | mediaWhereUniqueInput[]
    connect?: mediaWhereUniqueInput | mediaWhereUniqueInput[]
    update?: mediaUpdateWithWhereUniqueWithoutPlayerInput | mediaUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: mediaUpdateManyWithWhereWithoutPlayerInput | mediaUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: mediaScalarWhereInput | mediaScalarWhereInput[]
  }

  export type boostUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<boostCreateWithoutPlayerInput, boostUncheckedCreateWithoutPlayerInput> | boostCreateWithoutPlayerInput[] | boostUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: boostCreateOrConnectWithoutPlayerInput | boostCreateOrConnectWithoutPlayerInput[]
    upsert?: boostUpsertWithWhereUniqueWithoutPlayerInput | boostUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: boostCreateManyPlayerInputEnvelope
    set?: boostWhereUniqueInput | boostWhereUniqueInput[]
    disconnect?: boostWhereUniqueInput | boostWhereUniqueInput[]
    delete?: boostWhereUniqueInput | boostWhereUniqueInput[]
    connect?: boostWhereUniqueInput | boostWhereUniqueInput[]
    update?: boostUpdateWithWhereUniqueWithoutPlayerInput | boostUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: boostUpdateManyWithWhereWithoutPlayerInput | boostUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: boostScalarWhereInput | boostScalarWhereInput[]
  }

  export type strikeUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<strikeCreateWithoutPlayerInput, strikeUncheckedCreateWithoutPlayerInput> | strikeCreateWithoutPlayerInput[] | strikeUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: strikeCreateOrConnectWithoutPlayerInput | strikeCreateOrConnectWithoutPlayerInput[]
    upsert?: strikeUpsertWithWhereUniqueWithoutPlayerInput | strikeUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: strikeCreateManyPlayerInputEnvelope
    set?: strikeWhereUniqueInput | strikeWhereUniqueInput[]
    disconnect?: strikeWhereUniqueInput | strikeWhereUniqueInput[]
    delete?: strikeWhereUniqueInput | strikeWhereUniqueInput[]
    connect?: strikeWhereUniqueInput | strikeWhereUniqueInput[]
    update?: strikeUpdateWithWhereUniqueWithoutPlayerInput | strikeUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: strikeUpdateManyWithWhereWithoutPlayerInput | strikeUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: strikeScalarWhereInput | strikeScalarWhereInput[]
  }

  export type user_noteUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<user_noteCreateWithoutPlayerInput, user_noteUncheckedCreateWithoutPlayerInput> | user_noteCreateWithoutPlayerInput[] | user_noteUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: user_noteCreateOrConnectWithoutPlayerInput | user_noteCreateOrConnectWithoutPlayerInput[]
    upsert?: user_noteUpsertWithWhereUniqueWithoutPlayerInput | user_noteUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: user_noteCreateManyPlayerInputEnvelope
    set?: user_noteWhereUniqueInput | user_noteWhereUniqueInput[]
    disconnect?: user_noteWhereUniqueInput | user_noteWhereUniqueInput[]
    delete?: user_noteWhereUniqueInput | user_noteWhereUniqueInput[]
    connect?: user_noteWhereUniqueInput | user_noteWhereUniqueInput[]
    update?: user_noteUpdateWithWhereUniqueWithoutPlayerInput | user_noteUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: user_noteUpdateManyWithWhereWithoutPlayerInput | user_noteUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: user_noteScalarWhereInput | user_noteScalarWhereInput[]
  }

  export type contact_eventUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<contact_eventCreateWithoutPlayerInput, contact_eventUncheckedCreateWithoutPlayerInput> | contact_eventCreateWithoutPlayerInput[] | contact_eventUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: contact_eventCreateOrConnectWithoutPlayerInput | contact_eventCreateOrConnectWithoutPlayerInput[]
    upsert?: contact_eventUpsertWithWhereUniqueWithoutPlayerInput | contact_eventUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: contact_eventCreateManyPlayerInputEnvelope
    set?: contact_eventWhereUniqueInput | contact_eventWhereUniqueInput[]
    disconnect?: contact_eventWhereUniqueInput | contact_eventWhereUniqueInput[]
    delete?: contact_eventWhereUniqueInput | contact_eventWhereUniqueInput[]
    connect?: contact_eventWhereUniqueInput | contact_eventWhereUniqueInput[]
    update?: contact_eventUpdateWithWhereUniqueWithoutPlayerInput | contact_eventUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: contact_eventUpdateManyWithWhereWithoutPlayerInput | contact_eventUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: contact_eventScalarWhereInput | contact_eventScalarWhereInput[]
  }

  export type reportUpdateManyWithoutProfile_targetNestedInput = {
    create?: XOR<reportCreateWithoutProfile_targetInput, reportUncheckedCreateWithoutProfile_targetInput> | reportCreateWithoutProfile_targetInput[] | reportUncheckedCreateWithoutProfile_targetInput[]
    connectOrCreate?: reportCreateOrConnectWithoutProfile_targetInput | reportCreateOrConnectWithoutProfile_targetInput[]
    upsert?: reportUpsertWithWhereUniqueWithoutProfile_targetInput | reportUpsertWithWhereUniqueWithoutProfile_targetInput[]
    createMany?: reportCreateManyProfile_targetInputEnvelope
    set?: reportWhereUniqueInput | reportWhereUniqueInput[]
    disconnect?: reportWhereUniqueInput | reportWhereUniqueInput[]
    delete?: reportWhereUniqueInput | reportWhereUniqueInput[]
    connect?: reportWhereUniqueInput | reportWhereUniqueInput[]
    update?: reportUpdateWithWhereUniqueWithoutProfile_targetInput | reportUpdateWithWhereUniqueWithoutProfile_targetInput[]
    updateMany?: reportUpdateManyWithWhereWithoutProfile_targetInput | reportUpdateManyWithWhereWithoutProfile_targetInput[]
    deleteMany?: reportScalarWhereInput | reportScalarWhereInput[]
  }

  export type player_tagUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<player_tagCreateWithoutPlayerInput, player_tagUncheckedCreateWithoutPlayerInput> | player_tagCreateWithoutPlayerInput[] | player_tagUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: player_tagCreateOrConnectWithoutPlayerInput | player_tagCreateOrConnectWithoutPlayerInput[]
    upsert?: player_tagUpsertWithWhereUniqueWithoutPlayerInput | player_tagUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: player_tagCreateManyPlayerInputEnvelope
    set?: player_tagWhereUniqueInput | player_tagWhereUniqueInput[]
    disconnect?: player_tagWhereUniqueInput | player_tagWhereUniqueInput[]
    delete?: player_tagWhereUniqueInput | player_tagWhereUniqueInput[]
    connect?: player_tagWhereUniqueInput | player_tagWhereUniqueInput[]
    update?: player_tagUpdateWithWhereUniqueWithoutPlayerInput | player_tagUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: player_tagUpdateManyWithWhereWithoutPlayerInput | player_tagUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: player_tagScalarWhereInput | player_tagScalarWhereInput[]
  }

  export type featured_assignmentUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<featured_assignmentCreateWithoutPlayerInput, featured_assignmentUncheckedCreateWithoutPlayerInput> | featured_assignmentCreateWithoutPlayerInput[] | featured_assignmentUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: featured_assignmentCreateOrConnectWithoutPlayerInput | featured_assignmentCreateOrConnectWithoutPlayerInput[]
    upsert?: featured_assignmentUpsertWithWhereUniqueWithoutPlayerInput | featured_assignmentUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: featured_assignmentCreateManyPlayerInputEnvelope
    set?: featured_assignmentWhereUniqueInput | featured_assignmentWhereUniqueInput[]
    disconnect?: featured_assignmentWhereUniqueInput | featured_assignmentWhereUniqueInput[]
    delete?: featured_assignmentWhereUniqueInput | featured_assignmentWhereUniqueInput[]
    connect?: featured_assignmentWhereUniqueInput | featured_assignmentWhereUniqueInput[]
    update?: featured_assignmentUpdateWithWhereUniqueWithoutPlayerInput | featured_assignmentUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: featured_assignmentUpdateManyWithWhereWithoutPlayerInput | featured_assignmentUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: featured_assignmentScalarWhereInput | featured_assignmentScalarWhereInput[]
  }

  export type mediaUncheckedUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<mediaCreateWithoutPlayerInput, mediaUncheckedCreateWithoutPlayerInput> | mediaCreateWithoutPlayerInput[] | mediaUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: mediaCreateOrConnectWithoutPlayerInput | mediaCreateOrConnectWithoutPlayerInput[]
    upsert?: mediaUpsertWithWhereUniqueWithoutPlayerInput | mediaUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: mediaCreateManyPlayerInputEnvelope
    set?: mediaWhereUniqueInput | mediaWhereUniqueInput[]
    disconnect?: mediaWhereUniqueInput | mediaWhereUniqueInput[]
    delete?: mediaWhereUniqueInput | mediaWhereUniqueInput[]
    connect?: mediaWhereUniqueInput | mediaWhereUniqueInput[]
    update?: mediaUpdateWithWhereUniqueWithoutPlayerInput | mediaUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: mediaUpdateManyWithWhereWithoutPlayerInput | mediaUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: mediaScalarWhereInput | mediaScalarWhereInput[]
  }

  export type boostUncheckedUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<boostCreateWithoutPlayerInput, boostUncheckedCreateWithoutPlayerInput> | boostCreateWithoutPlayerInput[] | boostUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: boostCreateOrConnectWithoutPlayerInput | boostCreateOrConnectWithoutPlayerInput[]
    upsert?: boostUpsertWithWhereUniqueWithoutPlayerInput | boostUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: boostCreateManyPlayerInputEnvelope
    set?: boostWhereUniqueInput | boostWhereUniqueInput[]
    disconnect?: boostWhereUniqueInput | boostWhereUniqueInput[]
    delete?: boostWhereUniqueInput | boostWhereUniqueInput[]
    connect?: boostWhereUniqueInput | boostWhereUniqueInput[]
    update?: boostUpdateWithWhereUniqueWithoutPlayerInput | boostUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: boostUpdateManyWithWhereWithoutPlayerInput | boostUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: boostScalarWhereInput | boostScalarWhereInput[]
  }

  export type strikeUncheckedUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<strikeCreateWithoutPlayerInput, strikeUncheckedCreateWithoutPlayerInput> | strikeCreateWithoutPlayerInput[] | strikeUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: strikeCreateOrConnectWithoutPlayerInput | strikeCreateOrConnectWithoutPlayerInput[]
    upsert?: strikeUpsertWithWhereUniqueWithoutPlayerInput | strikeUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: strikeCreateManyPlayerInputEnvelope
    set?: strikeWhereUniqueInput | strikeWhereUniqueInput[]
    disconnect?: strikeWhereUniqueInput | strikeWhereUniqueInput[]
    delete?: strikeWhereUniqueInput | strikeWhereUniqueInput[]
    connect?: strikeWhereUniqueInput | strikeWhereUniqueInput[]
    update?: strikeUpdateWithWhereUniqueWithoutPlayerInput | strikeUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: strikeUpdateManyWithWhereWithoutPlayerInput | strikeUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: strikeScalarWhereInput | strikeScalarWhereInput[]
  }

  export type user_noteUncheckedUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<user_noteCreateWithoutPlayerInput, user_noteUncheckedCreateWithoutPlayerInput> | user_noteCreateWithoutPlayerInput[] | user_noteUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: user_noteCreateOrConnectWithoutPlayerInput | user_noteCreateOrConnectWithoutPlayerInput[]
    upsert?: user_noteUpsertWithWhereUniqueWithoutPlayerInput | user_noteUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: user_noteCreateManyPlayerInputEnvelope
    set?: user_noteWhereUniqueInput | user_noteWhereUniqueInput[]
    disconnect?: user_noteWhereUniqueInput | user_noteWhereUniqueInput[]
    delete?: user_noteWhereUniqueInput | user_noteWhereUniqueInput[]
    connect?: user_noteWhereUniqueInput | user_noteWhereUniqueInput[]
    update?: user_noteUpdateWithWhereUniqueWithoutPlayerInput | user_noteUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: user_noteUpdateManyWithWhereWithoutPlayerInput | user_noteUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: user_noteScalarWhereInput | user_noteScalarWhereInput[]
  }

  export type contact_eventUncheckedUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<contact_eventCreateWithoutPlayerInput, contact_eventUncheckedCreateWithoutPlayerInput> | contact_eventCreateWithoutPlayerInput[] | contact_eventUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: contact_eventCreateOrConnectWithoutPlayerInput | contact_eventCreateOrConnectWithoutPlayerInput[]
    upsert?: contact_eventUpsertWithWhereUniqueWithoutPlayerInput | contact_eventUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: contact_eventCreateManyPlayerInputEnvelope
    set?: contact_eventWhereUniqueInput | contact_eventWhereUniqueInput[]
    disconnect?: contact_eventWhereUniqueInput | contact_eventWhereUniqueInput[]
    delete?: contact_eventWhereUniqueInput | contact_eventWhereUniqueInput[]
    connect?: contact_eventWhereUniqueInput | contact_eventWhereUniqueInput[]
    update?: contact_eventUpdateWithWhereUniqueWithoutPlayerInput | contact_eventUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: contact_eventUpdateManyWithWhereWithoutPlayerInput | contact_eventUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: contact_eventScalarWhereInput | contact_eventScalarWhereInput[]
  }

  export type reportUncheckedUpdateManyWithoutProfile_targetNestedInput = {
    create?: XOR<reportCreateWithoutProfile_targetInput, reportUncheckedCreateWithoutProfile_targetInput> | reportCreateWithoutProfile_targetInput[] | reportUncheckedCreateWithoutProfile_targetInput[]
    connectOrCreate?: reportCreateOrConnectWithoutProfile_targetInput | reportCreateOrConnectWithoutProfile_targetInput[]
    upsert?: reportUpsertWithWhereUniqueWithoutProfile_targetInput | reportUpsertWithWhereUniqueWithoutProfile_targetInput[]
    createMany?: reportCreateManyProfile_targetInputEnvelope
    set?: reportWhereUniqueInput | reportWhereUniqueInput[]
    disconnect?: reportWhereUniqueInput | reportWhereUniqueInput[]
    delete?: reportWhereUniqueInput | reportWhereUniqueInput[]
    connect?: reportWhereUniqueInput | reportWhereUniqueInput[]
    update?: reportUpdateWithWhereUniqueWithoutProfile_targetInput | reportUpdateWithWhereUniqueWithoutProfile_targetInput[]
    updateMany?: reportUpdateManyWithWhereWithoutProfile_targetInput | reportUpdateManyWithWhereWithoutProfile_targetInput[]
    deleteMany?: reportScalarWhereInput | reportScalarWhereInput[]
  }

  export type player_tagUncheckedUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<player_tagCreateWithoutPlayerInput, player_tagUncheckedCreateWithoutPlayerInput> | player_tagCreateWithoutPlayerInput[] | player_tagUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: player_tagCreateOrConnectWithoutPlayerInput | player_tagCreateOrConnectWithoutPlayerInput[]
    upsert?: player_tagUpsertWithWhereUniqueWithoutPlayerInput | player_tagUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: player_tagCreateManyPlayerInputEnvelope
    set?: player_tagWhereUniqueInput | player_tagWhereUniqueInput[]
    disconnect?: player_tagWhereUniqueInput | player_tagWhereUniqueInput[]
    delete?: player_tagWhereUniqueInput | player_tagWhereUniqueInput[]
    connect?: player_tagWhereUniqueInput | player_tagWhereUniqueInput[]
    update?: player_tagUpdateWithWhereUniqueWithoutPlayerInput | player_tagUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: player_tagUpdateManyWithWhereWithoutPlayerInput | player_tagUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: player_tagScalarWhereInput | player_tagScalarWhereInput[]
  }

  export type featured_assignmentUncheckedUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<featured_assignmentCreateWithoutPlayerInput, featured_assignmentUncheckedCreateWithoutPlayerInput> | featured_assignmentCreateWithoutPlayerInput[] | featured_assignmentUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: featured_assignmentCreateOrConnectWithoutPlayerInput | featured_assignmentCreateOrConnectWithoutPlayerInput[]
    upsert?: featured_assignmentUpsertWithWhereUniqueWithoutPlayerInput | featured_assignmentUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: featured_assignmentCreateManyPlayerInputEnvelope
    set?: featured_assignmentWhereUniqueInput | featured_assignmentWhereUniqueInput[]
    disconnect?: featured_assignmentWhereUniqueInput | featured_assignmentWhereUniqueInput[]
    delete?: featured_assignmentWhereUniqueInput | featured_assignmentWhereUniqueInput[]
    connect?: featured_assignmentWhereUniqueInput | featured_assignmentWhereUniqueInput[]
    update?: featured_assignmentUpdateWithWhereUniqueWithoutPlayerInput | featured_assignmentUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: featured_assignmentUpdateManyWithWhereWithoutPlayerInput | featured_assignmentUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: featured_assignmentScalarWhereInput | featured_assignmentScalarWhereInput[]
  }

  export type mediaCreatetags_cacheInput = {
    set: string[]
  }

  export type profileCreateNestedOneWithoutMediaInput = {
    create?: XOR<profileCreateWithoutMediaInput, profileUncheckedCreateWithoutMediaInput>
    connectOrCreate?: profileCreateOrConnectWithoutMediaInput
    connect?: profileWhereUniqueInput
  }

  export type reportCreateNestedManyWithoutMedia_targetInput = {
    create?: XOR<reportCreateWithoutMedia_targetInput, reportUncheckedCreateWithoutMedia_targetInput> | reportCreateWithoutMedia_targetInput[] | reportUncheckedCreateWithoutMedia_targetInput[]
    connectOrCreate?: reportCreateOrConnectWithoutMedia_targetInput | reportCreateOrConnectWithoutMedia_targetInput[]
    createMany?: reportCreateManyMedia_targetInputEnvelope
    connect?: reportWhereUniqueInput | reportWhereUniqueInput[]
  }

  export type featured_assignmentCreateNestedManyWithoutMedia_refInput = {
    create?: XOR<featured_assignmentCreateWithoutMedia_refInput, featured_assignmentUncheckedCreateWithoutMedia_refInput> | featured_assignmentCreateWithoutMedia_refInput[] | featured_assignmentUncheckedCreateWithoutMedia_refInput[]
    connectOrCreate?: featured_assignmentCreateOrConnectWithoutMedia_refInput | featured_assignmentCreateOrConnectWithoutMedia_refInput[]
    createMany?: featured_assignmentCreateManyMedia_refInputEnvelope
    connect?: featured_assignmentWhereUniqueInput | featured_assignmentWhereUniqueInput[]
  }

  export type reportUncheckedCreateNestedManyWithoutMedia_targetInput = {
    create?: XOR<reportCreateWithoutMedia_targetInput, reportUncheckedCreateWithoutMedia_targetInput> | reportCreateWithoutMedia_targetInput[] | reportUncheckedCreateWithoutMedia_targetInput[]
    connectOrCreate?: reportCreateOrConnectWithoutMedia_targetInput | reportCreateOrConnectWithoutMedia_targetInput[]
    createMany?: reportCreateManyMedia_targetInputEnvelope
    connect?: reportWhereUniqueInput | reportWhereUniqueInput[]
  }

  export type featured_assignmentUncheckedCreateNestedManyWithoutMedia_refInput = {
    create?: XOR<featured_assignmentCreateWithoutMedia_refInput, featured_assignmentUncheckedCreateWithoutMedia_refInput> | featured_assignmentCreateWithoutMedia_refInput[] | featured_assignmentUncheckedCreateWithoutMedia_refInput[]
    connectOrCreate?: featured_assignmentCreateOrConnectWithoutMedia_refInput | featured_assignmentCreateOrConnectWithoutMedia_refInput[]
    createMany?: featured_assignmentCreateManyMedia_refInputEnvelope
    connect?: featured_assignmentWhereUniqueInput | featured_assignmentWhereUniqueInput[]
  }

  export type Enummedia_typeFieldUpdateOperationsInput = {
    set?: $Enums.media_type
  }

  export type Enummedia_sourceFieldUpdateOperationsInput = {
    set?: $Enums.media_source
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
    unset?: boolean
  }

  export type mediaUpdatetags_cacheInput = {
    set?: string[]
    push?: string | string[]
  }

  export type Enummedia_statusFieldUpdateOperationsInput = {
    set?: $Enums.media_status
  }

  export type profileUpdateOneRequiredWithoutMediaNestedInput = {
    create?: XOR<profileCreateWithoutMediaInput, profileUncheckedCreateWithoutMediaInput>
    connectOrCreate?: profileCreateOrConnectWithoutMediaInput
    upsert?: profileUpsertWithoutMediaInput
    connect?: profileWhereUniqueInput
    update?: XOR<XOR<profileUpdateToOneWithWhereWithoutMediaInput, profileUpdateWithoutMediaInput>, profileUncheckedUpdateWithoutMediaInput>
  }

  export type reportUpdateManyWithoutMedia_targetNestedInput = {
    create?: XOR<reportCreateWithoutMedia_targetInput, reportUncheckedCreateWithoutMedia_targetInput> | reportCreateWithoutMedia_targetInput[] | reportUncheckedCreateWithoutMedia_targetInput[]
    connectOrCreate?: reportCreateOrConnectWithoutMedia_targetInput | reportCreateOrConnectWithoutMedia_targetInput[]
    upsert?: reportUpsertWithWhereUniqueWithoutMedia_targetInput | reportUpsertWithWhereUniqueWithoutMedia_targetInput[]
    createMany?: reportCreateManyMedia_targetInputEnvelope
    set?: reportWhereUniqueInput | reportWhereUniqueInput[]
    disconnect?: reportWhereUniqueInput | reportWhereUniqueInput[]
    delete?: reportWhereUniqueInput | reportWhereUniqueInput[]
    connect?: reportWhereUniqueInput | reportWhereUniqueInput[]
    update?: reportUpdateWithWhereUniqueWithoutMedia_targetInput | reportUpdateWithWhereUniqueWithoutMedia_targetInput[]
    updateMany?: reportUpdateManyWithWhereWithoutMedia_targetInput | reportUpdateManyWithWhereWithoutMedia_targetInput[]
    deleteMany?: reportScalarWhereInput | reportScalarWhereInput[]
  }

  export type featured_assignmentUpdateManyWithoutMedia_refNestedInput = {
    create?: XOR<featured_assignmentCreateWithoutMedia_refInput, featured_assignmentUncheckedCreateWithoutMedia_refInput> | featured_assignmentCreateWithoutMedia_refInput[] | featured_assignmentUncheckedCreateWithoutMedia_refInput[]
    connectOrCreate?: featured_assignmentCreateOrConnectWithoutMedia_refInput | featured_assignmentCreateOrConnectWithoutMedia_refInput[]
    upsert?: featured_assignmentUpsertWithWhereUniqueWithoutMedia_refInput | featured_assignmentUpsertWithWhereUniqueWithoutMedia_refInput[]
    createMany?: featured_assignmentCreateManyMedia_refInputEnvelope
    set?: featured_assignmentWhereUniqueInput | featured_assignmentWhereUniqueInput[]
    disconnect?: featured_assignmentWhereUniqueInput | featured_assignmentWhereUniqueInput[]
    delete?: featured_assignmentWhereUniqueInput | featured_assignmentWhereUniqueInput[]
    connect?: featured_assignmentWhereUniqueInput | featured_assignmentWhereUniqueInput[]
    update?: featured_assignmentUpdateWithWhereUniqueWithoutMedia_refInput | featured_assignmentUpdateWithWhereUniqueWithoutMedia_refInput[]
    updateMany?: featured_assignmentUpdateManyWithWhereWithoutMedia_refInput | featured_assignmentUpdateManyWithWhereWithoutMedia_refInput[]
    deleteMany?: featured_assignmentScalarWhereInput | featured_assignmentScalarWhereInput[]
  }

  export type reportUncheckedUpdateManyWithoutMedia_targetNestedInput = {
    create?: XOR<reportCreateWithoutMedia_targetInput, reportUncheckedCreateWithoutMedia_targetInput> | reportCreateWithoutMedia_targetInput[] | reportUncheckedCreateWithoutMedia_targetInput[]
    connectOrCreate?: reportCreateOrConnectWithoutMedia_targetInput | reportCreateOrConnectWithoutMedia_targetInput[]
    upsert?: reportUpsertWithWhereUniqueWithoutMedia_targetInput | reportUpsertWithWhereUniqueWithoutMedia_targetInput[]
    createMany?: reportCreateManyMedia_targetInputEnvelope
    set?: reportWhereUniqueInput | reportWhereUniqueInput[]
    disconnect?: reportWhereUniqueInput | reportWhereUniqueInput[]
    delete?: reportWhereUniqueInput | reportWhereUniqueInput[]
    connect?: reportWhereUniqueInput | reportWhereUniqueInput[]
    update?: reportUpdateWithWhereUniqueWithoutMedia_targetInput | reportUpdateWithWhereUniqueWithoutMedia_targetInput[]
    updateMany?: reportUpdateManyWithWhereWithoutMedia_targetInput | reportUpdateManyWithWhereWithoutMedia_targetInput[]
    deleteMany?: reportScalarWhereInput | reportScalarWhereInput[]
  }

  export type featured_assignmentUncheckedUpdateManyWithoutMedia_refNestedInput = {
    create?: XOR<featured_assignmentCreateWithoutMedia_refInput, featured_assignmentUncheckedCreateWithoutMedia_refInput> | featured_assignmentCreateWithoutMedia_refInput[] | featured_assignmentUncheckedCreateWithoutMedia_refInput[]
    connectOrCreate?: featured_assignmentCreateOrConnectWithoutMedia_refInput | featured_assignmentCreateOrConnectWithoutMedia_refInput[]
    upsert?: featured_assignmentUpsertWithWhereUniqueWithoutMedia_refInput | featured_assignmentUpsertWithWhereUniqueWithoutMedia_refInput[]
    createMany?: featured_assignmentCreateManyMedia_refInputEnvelope
    set?: featured_assignmentWhereUniqueInput | featured_assignmentWhereUniqueInput[]
    disconnect?: featured_assignmentWhereUniqueInput | featured_assignmentWhereUniqueInput[]
    delete?: featured_assignmentWhereUniqueInput | featured_assignmentWhereUniqueInput[]
    connect?: featured_assignmentWhereUniqueInput | featured_assignmentWhereUniqueInput[]
    update?: featured_assignmentUpdateWithWhereUniqueWithoutMedia_refInput | featured_assignmentUpdateWithWhereUniqueWithoutMedia_refInput[]
    updateMany?: featured_assignmentUpdateManyWithWhereWithoutMedia_refInput | featured_assignmentUpdateManyWithWhereWithoutMedia_refInput[]
    deleteMany?: featured_assignmentScalarWhereInput | featured_assignmentScalarWhereInput[]
  }

  export type tagCreatealiasesInput = {
    set: string[]
  }

  export type player_tagCreateNestedManyWithoutTag_refInput = {
    create?: XOR<player_tagCreateWithoutTag_refInput, player_tagUncheckedCreateWithoutTag_refInput> | player_tagCreateWithoutTag_refInput[] | player_tagUncheckedCreateWithoutTag_refInput[]
    connectOrCreate?: player_tagCreateOrConnectWithoutTag_refInput | player_tagCreateOrConnectWithoutTag_refInput[]
    createMany?: player_tagCreateManyTag_refInputEnvelope
    connect?: player_tagWhereUniqueInput | player_tagWhereUniqueInput[]
  }

  export type player_tagUncheckedCreateNestedManyWithoutTag_refInput = {
    create?: XOR<player_tagCreateWithoutTag_refInput, player_tagUncheckedCreateWithoutTag_refInput> | player_tagCreateWithoutTag_refInput[] | player_tagUncheckedCreateWithoutTag_refInput[]
    connectOrCreate?: player_tagCreateOrConnectWithoutTag_refInput | player_tagCreateOrConnectWithoutTag_refInput[]
    createMany?: player_tagCreateManyTag_refInputEnvelope
    connect?: player_tagWhereUniqueInput | player_tagWhereUniqueInput[]
  }

  export type tagUpdatealiasesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type Enumsetting_statusFieldUpdateOperationsInput = {
    set?: $Enums.setting_status
  }

  export type player_tagUpdateManyWithoutTag_refNestedInput = {
    create?: XOR<player_tagCreateWithoutTag_refInput, player_tagUncheckedCreateWithoutTag_refInput> | player_tagCreateWithoutTag_refInput[] | player_tagUncheckedCreateWithoutTag_refInput[]
    connectOrCreate?: player_tagCreateOrConnectWithoutTag_refInput | player_tagCreateOrConnectWithoutTag_refInput[]
    upsert?: player_tagUpsertWithWhereUniqueWithoutTag_refInput | player_tagUpsertWithWhereUniqueWithoutTag_refInput[]
    createMany?: player_tagCreateManyTag_refInputEnvelope
    set?: player_tagWhereUniqueInput | player_tagWhereUniqueInput[]
    disconnect?: player_tagWhereUniqueInput | player_tagWhereUniqueInput[]
    delete?: player_tagWhereUniqueInput | player_tagWhereUniqueInput[]
    connect?: player_tagWhereUniqueInput | player_tagWhereUniqueInput[]
    update?: player_tagUpdateWithWhereUniqueWithoutTag_refInput | player_tagUpdateWithWhereUniqueWithoutTag_refInput[]
    updateMany?: player_tagUpdateManyWithWhereWithoutTag_refInput | player_tagUpdateManyWithWhereWithoutTag_refInput[]
    deleteMany?: player_tagScalarWhereInput | player_tagScalarWhereInput[]
  }

  export type player_tagUncheckedUpdateManyWithoutTag_refNestedInput = {
    create?: XOR<player_tagCreateWithoutTag_refInput, player_tagUncheckedCreateWithoutTag_refInput> | player_tagCreateWithoutTag_refInput[] | player_tagUncheckedCreateWithoutTag_refInput[]
    connectOrCreate?: player_tagCreateOrConnectWithoutTag_refInput | player_tagCreateOrConnectWithoutTag_refInput[]
    upsert?: player_tagUpsertWithWhereUniqueWithoutTag_refInput | player_tagUpsertWithWhereUniqueWithoutTag_refInput[]
    createMany?: player_tagCreateManyTag_refInputEnvelope
    set?: player_tagWhereUniqueInput | player_tagWhereUniqueInput[]
    disconnect?: player_tagWhereUniqueInput | player_tagWhereUniqueInput[]
    delete?: player_tagWhereUniqueInput | player_tagWhereUniqueInput[]
    connect?: player_tagWhereUniqueInput | player_tagWhereUniqueInput[]
    update?: player_tagUpdateWithWhereUniqueWithoutTag_refInput | player_tagUpdateWithWhereUniqueWithoutTag_refInput[]
    updateMany?: player_tagUpdateManyWithWhereWithoutTag_refInput | player_tagUpdateManyWithWhereWithoutTag_refInput[]
    deleteMany?: player_tagScalarWhereInput | player_tagScalarWhereInput[]
  }

  export type profileCreateNestedOneWithoutPlayer_tagsInput = {
    create?: XOR<profileCreateWithoutPlayer_tagsInput, profileUncheckedCreateWithoutPlayer_tagsInput>
    connectOrCreate?: profileCreateOrConnectWithoutPlayer_tagsInput
    connect?: profileWhereUniqueInput
  }

  export type tagCreateNestedOneWithoutPlayer_tagsInput = {
    create?: XOR<tagCreateWithoutPlayer_tagsInput, tagUncheckedCreateWithoutPlayer_tagsInput>
    connectOrCreate?: tagCreateOrConnectWithoutPlayer_tagsInput
    connect?: tagWhereUniqueInput
  }

  export type profileUpdateOneRequiredWithoutPlayer_tagsNestedInput = {
    create?: XOR<profileCreateWithoutPlayer_tagsInput, profileUncheckedCreateWithoutPlayer_tagsInput>
    connectOrCreate?: profileCreateOrConnectWithoutPlayer_tagsInput
    upsert?: profileUpsertWithoutPlayer_tagsInput
    connect?: profileWhereUniqueInput
    update?: XOR<XOR<profileUpdateToOneWithWhereWithoutPlayer_tagsInput, profileUpdateWithoutPlayer_tagsInput>, profileUncheckedUpdateWithoutPlayer_tagsInput>
  }

  export type tagUpdateOneRequiredWithoutPlayer_tagsNestedInput = {
    create?: XOR<tagCreateWithoutPlayer_tagsInput, tagUncheckedCreateWithoutPlayer_tagsInput>
    connectOrCreate?: tagCreateOrConnectWithoutPlayer_tagsInput
    upsert?: tagUpsertWithoutPlayer_tagsInput
    connect?: tagWhereUniqueInput
    update?: XOR<XOR<tagUpdateToOneWithWhereWithoutPlayer_tagsInput, tagUpdateWithoutPlayer_tagsInput>, tagUncheckedUpdateWithoutPlayer_tagsInput>
  }

  export type profileCreateNestedOneWithoutBoostsInput = {
    create?: XOR<profileCreateWithoutBoostsInput, profileUncheckedCreateWithoutBoostsInput>
    connectOrCreate?: profileCreateOrConnectWithoutBoostsInput
    connect?: profileWhereUniqueInput
  }

  export type Enumboost_statusFieldUpdateOperationsInput = {
    set?: $Enums.boost_status
  }

  export type Enumprovider_kindFieldUpdateOperationsInput = {
    set?: $Enums.provider_kind
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type profileUpdateOneRequiredWithoutBoostsNestedInput = {
    create?: XOR<profileCreateWithoutBoostsInput, profileUncheckedCreateWithoutBoostsInput>
    connectOrCreate?: profileCreateOrConnectWithoutBoostsInput
    upsert?: profileUpsertWithoutBoostsInput
    connect?: profileWhereUniqueInput
    update?: XOR<XOR<profileUpdateToOneWithWhereWithoutBoostsInput, profileUpdateWithoutBoostsInput>, profileUncheckedUpdateWithoutBoostsInput>
  }

  export type mediaCreateNestedOneWithoutReports_againstInput = {
    create?: XOR<mediaCreateWithoutReports_againstInput, mediaUncheckedCreateWithoutReports_againstInput>
    connectOrCreate?: mediaCreateOrConnectWithoutReports_againstInput
    connect?: mediaWhereUniqueInput
  }

  export type profileCreateNestedOneWithoutReports_againstInput = {
    create?: XOR<profileCreateWithoutReports_againstInput, profileUncheckedCreateWithoutReports_againstInput>
    connectOrCreate?: profileCreateOrConnectWithoutReports_againstInput
    connect?: profileWhereUniqueInput
  }

  export type userCreateNestedOneWithoutReports_madeInput = {
    create?: XOR<userCreateWithoutReports_madeInput, userUncheckedCreateWithoutReports_madeInput>
    connectOrCreate?: userCreateOrConnectWithoutReports_madeInput
    connect?: userWhereUniqueInput
  }

  export type Enumreport_reasonFieldUpdateOperationsInput = {
    set?: $Enums.report_reason
  }

  export type Enumseverity_levelFieldUpdateOperationsInput = {
    set?: $Enums.severity_level
  }

  export type Enumreport_statusFieldUpdateOperationsInput = {
    set?: $Enums.report_status
  }

  export type mediaUpdateOneWithoutReports_againstNestedInput = {
    create?: XOR<mediaCreateWithoutReports_againstInput, mediaUncheckedCreateWithoutReports_againstInput>
    connectOrCreate?: mediaCreateOrConnectWithoutReports_againstInput
    upsert?: mediaUpsertWithoutReports_againstInput
    disconnect?: boolean
    delete?: mediaWhereInput | boolean
    connect?: mediaWhereUniqueInput
    update?: XOR<XOR<mediaUpdateToOneWithWhereWithoutReports_againstInput, mediaUpdateWithoutReports_againstInput>, mediaUncheckedUpdateWithoutReports_againstInput>
  }

  export type profileUpdateOneWithoutReports_againstNestedInput = {
    create?: XOR<profileCreateWithoutReports_againstInput, profileUncheckedCreateWithoutReports_againstInput>
    connectOrCreate?: profileCreateOrConnectWithoutReports_againstInput
    upsert?: profileUpsertWithoutReports_againstInput
    disconnect?: boolean
    delete?: profileWhereInput | boolean
    connect?: profileWhereUniqueInput
    update?: XOR<XOR<profileUpdateToOneWithWhereWithoutReports_againstInput, profileUpdateWithoutReports_againstInput>, profileUncheckedUpdateWithoutReports_againstInput>
  }

  export type userUpdateOneWithoutReports_madeNestedInput = {
    create?: XOR<userCreateWithoutReports_madeInput, userUncheckedCreateWithoutReports_madeInput>
    connectOrCreate?: userCreateOrConnectWithoutReports_madeInput
    upsert?: userUpsertWithoutReports_madeInput
    disconnect?: boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutReports_madeInput, userUpdateWithoutReports_madeInput>, userUncheckedUpdateWithoutReports_madeInput>
  }

  export type profileCreateNestedOneWithoutStrikesInput = {
    create?: XOR<profileCreateWithoutStrikesInput, profileUncheckedCreateWithoutStrikesInput>
    connectOrCreate?: profileCreateOrConnectWithoutStrikesInput
    connect?: profileWhereUniqueInput
  }

  export type profileUpdateOneRequiredWithoutStrikesNestedInput = {
    create?: XOR<profileCreateWithoutStrikesInput, profileUncheckedCreateWithoutStrikesInput>
    connectOrCreate?: profileCreateOrConnectWithoutStrikesInput
    upsert?: profileUpsertWithoutStrikesInput
    connect?: profileWhereUniqueInput
    update?: XOR<XOR<profileUpdateToOneWithWhereWithoutStrikesInput, profileUpdateWithoutStrikesInput>, profileUncheckedUpdateWithoutStrikesInput>
  }

  export type profileCreateNestedOneWithoutNotesInput = {
    create?: XOR<profileCreateWithoutNotesInput, profileUncheckedCreateWithoutNotesInput>
    connectOrCreate?: profileCreateOrConnectWithoutNotesInput
    connect?: profileWhereUniqueInput
  }

  export type userCreateNestedOneWithoutNotes_authoredInput = {
    create?: XOR<userCreateWithoutNotes_authoredInput, userUncheckedCreateWithoutNotes_authoredInput>
    connectOrCreate?: userCreateOrConnectWithoutNotes_authoredInput
    connect?: userWhereUniqueInput
  }

  export type profileUpdateOneRequiredWithoutNotesNestedInput = {
    create?: XOR<profileCreateWithoutNotesInput, profileUncheckedCreateWithoutNotesInput>
    connectOrCreate?: profileCreateOrConnectWithoutNotesInput
    upsert?: profileUpsertWithoutNotesInput
    connect?: profileWhereUniqueInput
    update?: XOR<XOR<profileUpdateToOneWithWhereWithoutNotesInput, profileUpdateWithoutNotesInput>, profileUncheckedUpdateWithoutNotesInput>
  }

  export type userUpdateOneRequiredWithoutNotes_authoredNestedInput = {
    create?: XOR<userCreateWithoutNotes_authoredInput, userUncheckedCreateWithoutNotes_authoredInput>
    connectOrCreate?: userCreateOrConnectWithoutNotes_authoredInput
    upsert?: userUpsertWithoutNotes_authoredInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutNotes_authoredInput, userUpdateWithoutNotes_authoredInput>, userUncheckedUpdateWithoutNotes_authoredInput>
  }

  export type announcementCreatesegment_tagsInput = {
    set: string[]
  }

  export type announcementCreatesegment_statesInput = {
    set: string[]
  }

  export type announcementCreatesegment_devicesInput = {
    set: string[]
  }

  export type Enumannouncement_statusFieldUpdateOperationsInput = {
    set?: $Enums.announcement_status
  }

  export type announcementUpdatesegment_tagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type announcementUpdatesegment_statesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type announcementUpdatesegment_devicesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type Enumfeature_slot_keyFieldUpdateOperationsInput = {
    set?: $Enums.feature_slot_key
  }

  export type profileCreateNestedOneWithoutFeatured_assignmentsInput = {
    create?: XOR<profileCreateWithoutFeatured_assignmentsInput, profileUncheckedCreateWithoutFeatured_assignmentsInput>
    connectOrCreate?: profileCreateOrConnectWithoutFeatured_assignmentsInput
    connect?: profileWhereUniqueInput
  }

  export type mediaCreateNestedOneWithoutFeatured_assignmentsInput = {
    create?: XOR<mediaCreateWithoutFeatured_assignmentsInput, mediaUncheckedCreateWithoutFeatured_assignmentsInput>
    connectOrCreate?: mediaCreateOrConnectWithoutFeatured_assignmentsInput
    connect?: mediaWhereUniqueInput
  }

  export type profileUpdateOneRequiredWithoutFeatured_assignmentsNestedInput = {
    create?: XOR<profileCreateWithoutFeatured_assignmentsInput, profileUncheckedCreateWithoutFeatured_assignmentsInput>
    connectOrCreate?: profileCreateOrConnectWithoutFeatured_assignmentsInput
    upsert?: profileUpsertWithoutFeatured_assignmentsInput
    connect?: profileWhereUniqueInput
    update?: XOR<XOR<profileUpdateToOneWithWhereWithoutFeatured_assignmentsInput, profileUpdateWithoutFeatured_assignmentsInput>, profileUncheckedUpdateWithoutFeatured_assignmentsInput>
  }

  export type mediaUpdateOneWithoutFeatured_assignmentsNestedInput = {
    create?: XOR<mediaCreateWithoutFeatured_assignmentsInput, mediaUncheckedCreateWithoutFeatured_assignmentsInput>
    connectOrCreate?: mediaCreateOrConnectWithoutFeatured_assignmentsInput
    upsert?: mediaUpsertWithoutFeatured_assignmentsInput
    disconnect?: boolean
    delete?: mediaWhereInput | boolean
    connect?: mediaWhereUniqueInput
    update?: XOR<XOR<mediaUpdateToOneWithWhereWithoutFeatured_assignmentsInput, mediaUpdateWithoutFeatured_assignmentsInput>, mediaUncheckedUpdateWithoutFeatured_assignmentsInput>
  }

  export type userCreateNestedOneWithoutTicketsInput = {
    create?: XOR<userCreateWithoutTicketsInput, userUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: userCreateOrConnectWithoutTicketsInput
    connect?: userWhereUniqueInput
  }

  export type userCreateNestedOneWithoutAssigned_ticketsInput = {
    create?: XOR<userCreateWithoutAssigned_ticketsInput, userUncheckedCreateWithoutAssigned_ticketsInput>
    connectOrCreate?: userCreateOrConnectWithoutAssigned_ticketsInput
    connect?: userWhereUniqueInput
  }

  export type Enumticket_priorityFieldUpdateOperationsInput = {
    set?: $Enums.ticket_priority
  }

  export type Enumticket_statusFieldUpdateOperationsInput = {
    set?: $Enums.ticket_status
  }

  export type userUpdateOneWithoutTicketsNestedInput = {
    create?: XOR<userCreateWithoutTicketsInput, userUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: userCreateOrConnectWithoutTicketsInput
    upsert?: userUpsertWithoutTicketsInput
    disconnect?: boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutTicketsInput, userUpdateWithoutTicketsInput>, userUncheckedUpdateWithoutTicketsInput>
  }

  export type userUpdateOneWithoutAssigned_ticketsNestedInput = {
    create?: XOR<userCreateWithoutAssigned_ticketsInput, userUncheckedCreateWithoutAssigned_ticketsInput>
    connectOrCreate?: userCreateOrConnectWithoutAssigned_ticketsInput
    upsert?: userUpsertWithoutAssigned_ticketsInput
    disconnect?: boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutAssigned_ticketsInput, userUpdateWithoutAssigned_ticketsInput>, userUncheckedUpdateWithoutAssigned_ticketsInput>
  }

  export type profileCreateNestedOneWithoutContact_eventsInput = {
    create?: XOR<profileCreateWithoutContact_eventsInput, profileUncheckedCreateWithoutContact_eventsInput>
    connectOrCreate?: profileCreateOrConnectWithoutContact_eventsInput
    connect?: profileWhereUniqueInput
  }

  export type Enumcontact_channelFieldUpdateOperationsInput = {
    set?: $Enums.contact_channel
  }

  export type profileUpdateOneRequiredWithoutContact_eventsNestedInput = {
    create?: XOR<profileCreateWithoutContact_eventsInput, profileUncheckedCreateWithoutContact_eventsInput>
    connectOrCreate?: profileCreateOrConnectWithoutContact_eventsInput
    upsert?: profileUpsertWithoutContact_eventsInput
    connect?: profileWhereUniqueInput
    update?: XOR<XOR<profileUpdateToOneWithWhereWithoutContact_eventsInput, profileUpdateWithoutContact_eventsInput>, profileUncheckedUpdateWithoutContact_eventsInput>
  }

  export type NullableEnumuser_roleFieldUpdateOperationsInput = {
    set?: $Enums.user_role | null
    unset?: boolean
  }

  export type Enumaudit_statusFieldUpdateOperationsInput = {
    set?: $Enums.audit_status
  }

  export type Enumwebhook_statusFieldUpdateOperationsInput = {
    set?: $Enums.webhook_status
  }

  export type userCreateNestedOneWithoutSessionsInput = {
    create?: XOR<userCreateWithoutSessionsInput, userUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: userCreateOrConnectWithoutSessionsInput
    connect?: userWhereUniqueInput
  }

  export type userUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<userCreateWithoutSessionsInput, userUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: userCreateOrConnectWithoutSessionsInput
    upsert?: userUpsertWithoutSessionsInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutSessionsInput, userUpdateWithoutSessionsInput>, userUncheckedUpdateWithoutSessionsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumuser_roleFilter<$PrismaModel = never> = {
    equals?: $Enums.user_role | Enumuser_roleFieldRefInput<$PrismaModel>
    in?: $Enums.user_role[] | ListEnumuser_roleFieldRefInput<$PrismaModel>
    notIn?: $Enums.user_role[] | ListEnumuser_roleFieldRefInput<$PrismaModel>
    not?: NestedEnumuser_roleFilter<$PrismaModel> | $Enums.user_role
  }

  export type NestedEnumuser_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.user_status | Enumuser_statusFieldRefInput<$PrismaModel>
    in?: $Enums.user_status[] | ListEnumuser_statusFieldRefInput<$PrismaModel>
    notIn?: $Enums.user_status[] | ListEnumuser_statusFieldRefInput<$PrismaModel>
    not?: NestedEnumuser_statusFilter<$PrismaModel> | $Enums.user_status
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
    isSet?: boolean
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumuser_roleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.user_role | Enumuser_roleFieldRefInput<$PrismaModel>
    in?: $Enums.user_role[] | ListEnumuser_roleFieldRefInput<$PrismaModel>
    notIn?: $Enums.user_role[] | ListEnumuser_roleFieldRefInput<$PrismaModel>
    not?: NestedEnumuser_roleWithAggregatesFilter<$PrismaModel> | $Enums.user_role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumuser_roleFilter<$PrismaModel>
    _max?: NestedEnumuser_roleFilter<$PrismaModel>
  }

  export type NestedEnumuser_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.user_status | Enumuser_statusFieldRefInput<$PrismaModel>
    in?: $Enums.user_status[] | ListEnumuser_statusFieldRefInput<$PrismaModel>
    notIn?: $Enums.user_status[] | ListEnumuser_statusFieldRefInput<$PrismaModel>
    not?: NestedEnumuser_statusWithAggregatesFilter<$PrismaModel> | $Enums.user_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumuser_statusFilter<$PrismaModel>
    _max?: NestedEnumuser_statusFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
    isSet?: boolean
  }

  export type NestedEnumprofile_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.profile_status | Enumprofile_statusFieldRefInput<$PrismaModel>
    in?: $Enums.profile_status[] | ListEnumprofile_statusFieldRefInput<$PrismaModel>
    notIn?: $Enums.profile_status[] | ListEnumprofile_statusFieldRefInput<$PrismaModel>
    not?: NestedEnumprofile_statusFilter<$PrismaModel> | $Enums.profile_status
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type NestedEnumprofile_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.profile_status | Enumprofile_statusFieldRefInput<$PrismaModel>
    in?: $Enums.profile_status[] | ListEnumprofile_statusFieldRefInput<$PrismaModel>
    notIn?: $Enums.profile_status[] | ListEnumprofile_statusFieldRefInput<$PrismaModel>
    not?: NestedEnumprofile_statusWithAggregatesFilter<$PrismaModel> | $Enums.profile_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumprofile_statusFilter<$PrismaModel>
    _max?: NestedEnumprofile_statusFilter<$PrismaModel>
  }

  export type NestedEnummedia_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.media_type | Enummedia_typeFieldRefInput<$PrismaModel>
    in?: $Enums.media_type[] | ListEnummedia_typeFieldRefInput<$PrismaModel>
    notIn?: $Enums.media_type[] | ListEnummedia_typeFieldRefInput<$PrismaModel>
    not?: NestedEnummedia_typeFilter<$PrismaModel> | $Enums.media_type
  }

  export type NestedEnummedia_sourceFilter<$PrismaModel = never> = {
    equals?: $Enums.media_source | Enummedia_sourceFieldRefInput<$PrismaModel>
    in?: $Enums.media_source[] | ListEnummedia_sourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.media_source[] | ListEnummedia_sourceFieldRefInput<$PrismaModel>
    not?: NestedEnummedia_sourceFilter<$PrismaModel> | $Enums.media_source
  }

  export type NestedEnummedia_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.media_status | Enummedia_statusFieldRefInput<$PrismaModel>
    in?: $Enums.media_status[] | ListEnummedia_statusFieldRefInput<$PrismaModel>
    notIn?: $Enums.media_status[] | ListEnummedia_statusFieldRefInput<$PrismaModel>
    not?: NestedEnummedia_statusFilter<$PrismaModel> | $Enums.media_status
  }

  export type NestedEnummedia_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.media_type | Enummedia_typeFieldRefInput<$PrismaModel>
    in?: $Enums.media_type[] | ListEnummedia_typeFieldRefInput<$PrismaModel>
    notIn?: $Enums.media_type[] | ListEnummedia_typeFieldRefInput<$PrismaModel>
    not?: NestedEnummedia_typeWithAggregatesFilter<$PrismaModel> | $Enums.media_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnummedia_typeFilter<$PrismaModel>
    _max?: NestedEnummedia_typeFilter<$PrismaModel>
  }

  export type NestedEnummedia_sourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.media_source | Enummedia_sourceFieldRefInput<$PrismaModel>
    in?: $Enums.media_source[] | ListEnummedia_sourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.media_source[] | ListEnummedia_sourceFieldRefInput<$PrismaModel>
    not?: NestedEnummedia_sourceWithAggregatesFilter<$PrismaModel> | $Enums.media_source
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnummedia_sourceFilter<$PrismaModel>
    _max?: NestedEnummedia_sourceFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    isSet?: boolean
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedEnummedia_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.media_status | Enummedia_statusFieldRefInput<$PrismaModel>
    in?: $Enums.media_status[] | ListEnummedia_statusFieldRefInput<$PrismaModel>
    notIn?: $Enums.media_status[] | ListEnummedia_statusFieldRefInput<$PrismaModel>
    not?: NestedEnummedia_statusWithAggregatesFilter<$PrismaModel> | $Enums.media_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnummedia_statusFilter<$PrismaModel>
    _max?: NestedEnummedia_statusFilter<$PrismaModel>
  }

  export type NestedEnumsetting_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.setting_status | Enumsetting_statusFieldRefInput<$PrismaModel>
    in?: $Enums.setting_status[] | ListEnumsetting_statusFieldRefInput<$PrismaModel>
    notIn?: $Enums.setting_status[] | ListEnumsetting_statusFieldRefInput<$PrismaModel>
    not?: NestedEnumsetting_statusFilter<$PrismaModel> | $Enums.setting_status
  }

  export type NestedEnumsetting_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.setting_status | Enumsetting_statusFieldRefInput<$PrismaModel>
    in?: $Enums.setting_status[] | ListEnumsetting_statusFieldRefInput<$PrismaModel>
    notIn?: $Enums.setting_status[] | ListEnumsetting_statusFieldRefInput<$PrismaModel>
    not?: NestedEnumsetting_statusWithAggregatesFilter<$PrismaModel> | $Enums.setting_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumsetting_statusFilter<$PrismaModel>
    _max?: NestedEnumsetting_statusFilter<$PrismaModel>
  }

  export type NestedEnumboost_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.boost_status | Enumboost_statusFieldRefInput<$PrismaModel>
    in?: $Enums.boost_status[] | ListEnumboost_statusFieldRefInput<$PrismaModel>
    notIn?: $Enums.boost_status[] | ListEnumboost_statusFieldRefInput<$PrismaModel>
    not?: NestedEnumboost_statusFilter<$PrismaModel> | $Enums.boost_status
  }

  export type NestedEnumprovider_kindFilter<$PrismaModel = never> = {
    equals?: $Enums.provider_kind | Enumprovider_kindFieldRefInput<$PrismaModel>
    in?: $Enums.provider_kind[] | ListEnumprovider_kindFieldRefInput<$PrismaModel>
    notIn?: $Enums.provider_kind[] | ListEnumprovider_kindFieldRefInput<$PrismaModel>
    not?: NestedEnumprovider_kindFilter<$PrismaModel> | $Enums.provider_kind
  }

  export type NestedEnumboost_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.boost_status | Enumboost_statusFieldRefInput<$PrismaModel>
    in?: $Enums.boost_status[] | ListEnumboost_statusFieldRefInput<$PrismaModel>
    notIn?: $Enums.boost_status[] | ListEnumboost_statusFieldRefInput<$PrismaModel>
    not?: NestedEnumboost_statusWithAggregatesFilter<$PrismaModel> | $Enums.boost_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumboost_statusFilter<$PrismaModel>
    _max?: NestedEnumboost_statusFilter<$PrismaModel>
  }

  export type NestedEnumprovider_kindWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.provider_kind | Enumprovider_kindFieldRefInput<$PrismaModel>
    in?: $Enums.provider_kind[] | ListEnumprovider_kindFieldRefInput<$PrismaModel>
    notIn?: $Enums.provider_kind[] | ListEnumprovider_kindFieldRefInput<$PrismaModel>
    not?: NestedEnumprovider_kindWithAggregatesFilter<$PrismaModel> | $Enums.provider_kind
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumprovider_kindFilter<$PrismaModel>
    _max?: NestedEnumprovider_kindFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumreport_reasonFilter<$PrismaModel = never> = {
    equals?: $Enums.report_reason | Enumreport_reasonFieldRefInput<$PrismaModel>
    in?: $Enums.report_reason[] | ListEnumreport_reasonFieldRefInput<$PrismaModel>
    notIn?: $Enums.report_reason[] | ListEnumreport_reasonFieldRefInput<$PrismaModel>
    not?: NestedEnumreport_reasonFilter<$PrismaModel> | $Enums.report_reason
  }

  export type NestedEnumseverity_levelFilter<$PrismaModel = never> = {
    equals?: $Enums.severity_level | Enumseverity_levelFieldRefInput<$PrismaModel>
    in?: $Enums.severity_level[] | ListEnumseverity_levelFieldRefInput<$PrismaModel>
    notIn?: $Enums.severity_level[] | ListEnumseverity_levelFieldRefInput<$PrismaModel>
    not?: NestedEnumseverity_levelFilter<$PrismaModel> | $Enums.severity_level
  }

  export type NestedEnumreport_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.report_status | Enumreport_statusFieldRefInput<$PrismaModel>
    in?: $Enums.report_status[] | ListEnumreport_statusFieldRefInput<$PrismaModel>
    notIn?: $Enums.report_status[] | ListEnumreport_statusFieldRefInput<$PrismaModel>
    not?: NestedEnumreport_statusFilter<$PrismaModel> | $Enums.report_status
  }

  export type NestedEnumreport_reasonWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.report_reason | Enumreport_reasonFieldRefInput<$PrismaModel>
    in?: $Enums.report_reason[] | ListEnumreport_reasonFieldRefInput<$PrismaModel>
    notIn?: $Enums.report_reason[] | ListEnumreport_reasonFieldRefInput<$PrismaModel>
    not?: NestedEnumreport_reasonWithAggregatesFilter<$PrismaModel> | $Enums.report_reason
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumreport_reasonFilter<$PrismaModel>
    _max?: NestedEnumreport_reasonFilter<$PrismaModel>
  }

  export type NestedEnumseverity_levelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.severity_level | Enumseverity_levelFieldRefInput<$PrismaModel>
    in?: $Enums.severity_level[] | ListEnumseverity_levelFieldRefInput<$PrismaModel>
    notIn?: $Enums.severity_level[] | ListEnumseverity_levelFieldRefInput<$PrismaModel>
    not?: NestedEnumseverity_levelWithAggregatesFilter<$PrismaModel> | $Enums.severity_level
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumseverity_levelFilter<$PrismaModel>
    _max?: NestedEnumseverity_levelFilter<$PrismaModel>
  }

  export type NestedEnumreport_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.report_status | Enumreport_statusFieldRefInput<$PrismaModel>
    in?: $Enums.report_status[] | ListEnumreport_statusFieldRefInput<$PrismaModel>
    notIn?: $Enums.report_status[] | ListEnumreport_statusFieldRefInput<$PrismaModel>
    not?: NestedEnumreport_statusWithAggregatesFilter<$PrismaModel> | $Enums.report_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumreport_statusFilter<$PrismaModel>
    _max?: NestedEnumreport_statusFilter<$PrismaModel>
  }

  export type NestedEnumannouncement_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.announcement_status | Enumannouncement_statusFieldRefInput<$PrismaModel>
    in?: $Enums.announcement_status[] | ListEnumannouncement_statusFieldRefInput<$PrismaModel>
    notIn?: $Enums.announcement_status[] | ListEnumannouncement_statusFieldRefInput<$PrismaModel>
    not?: NestedEnumannouncement_statusFilter<$PrismaModel> | $Enums.announcement_status
  }

  export type NestedEnumannouncement_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.announcement_status | Enumannouncement_statusFieldRefInput<$PrismaModel>
    in?: $Enums.announcement_status[] | ListEnumannouncement_statusFieldRefInput<$PrismaModel>
    notIn?: $Enums.announcement_status[] | ListEnumannouncement_statusFieldRefInput<$PrismaModel>
    not?: NestedEnumannouncement_statusWithAggregatesFilter<$PrismaModel> | $Enums.announcement_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumannouncement_statusFilter<$PrismaModel>
    _max?: NestedEnumannouncement_statusFilter<$PrismaModel>
  }

  export type NestedEnumfeature_slot_keyFilter<$PrismaModel = never> = {
    equals?: $Enums.feature_slot_key | Enumfeature_slot_keyFieldRefInput<$PrismaModel>
    in?: $Enums.feature_slot_key[] | ListEnumfeature_slot_keyFieldRefInput<$PrismaModel>
    notIn?: $Enums.feature_slot_key[] | ListEnumfeature_slot_keyFieldRefInput<$PrismaModel>
    not?: NestedEnumfeature_slot_keyFilter<$PrismaModel> | $Enums.feature_slot_key
  }

  export type NestedEnumfeature_slot_keyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.feature_slot_key | Enumfeature_slot_keyFieldRefInput<$PrismaModel>
    in?: $Enums.feature_slot_key[] | ListEnumfeature_slot_keyFieldRefInput<$PrismaModel>
    notIn?: $Enums.feature_slot_key[] | ListEnumfeature_slot_keyFieldRefInput<$PrismaModel>
    not?: NestedEnumfeature_slot_keyWithAggregatesFilter<$PrismaModel> | $Enums.feature_slot_key
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumfeature_slot_keyFilter<$PrismaModel>
    _max?: NestedEnumfeature_slot_keyFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
  }

  export type NestedEnumticket_priorityFilter<$PrismaModel = never> = {
    equals?: $Enums.ticket_priority | Enumticket_priorityFieldRefInput<$PrismaModel>
    in?: $Enums.ticket_priority[] | ListEnumticket_priorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.ticket_priority[] | ListEnumticket_priorityFieldRefInput<$PrismaModel>
    not?: NestedEnumticket_priorityFilter<$PrismaModel> | $Enums.ticket_priority
  }

  export type NestedEnumticket_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.ticket_status | Enumticket_statusFieldRefInput<$PrismaModel>
    in?: $Enums.ticket_status[] | ListEnumticket_statusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ticket_status[] | ListEnumticket_statusFieldRefInput<$PrismaModel>
    not?: NestedEnumticket_statusFilter<$PrismaModel> | $Enums.ticket_status
  }

  export type NestedEnumticket_priorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ticket_priority | Enumticket_priorityFieldRefInput<$PrismaModel>
    in?: $Enums.ticket_priority[] | ListEnumticket_priorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.ticket_priority[] | ListEnumticket_priorityFieldRefInput<$PrismaModel>
    not?: NestedEnumticket_priorityWithAggregatesFilter<$PrismaModel> | $Enums.ticket_priority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumticket_priorityFilter<$PrismaModel>
    _max?: NestedEnumticket_priorityFilter<$PrismaModel>
  }

  export type NestedEnumticket_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ticket_status | Enumticket_statusFieldRefInput<$PrismaModel>
    in?: $Enums.ticket_status[] | ListEnumticket_statusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ticket_status[] | ListEnumticket_statusFieldRefInput<$PrismaModel>
    not?: NestedEnumticket_statusWithAggregatesFilter<$PrismaModel> | $Enums.ticket_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumticket_statusFilter<$PrismaModel>
    _max?: NestedEnumticket_statusFilter<$PrismaModel>
  }

  export type NestedEnumcontact_channelFilter<$PrismaModel = never> = {
    equals?: $Enums.contact_channel | Enumcontact_channelFieldRefInput<$PrismaModel>
    in?: $Enums.contact_channel[] | ListEnumcontact_channelFieldRefInput<$PrismaModel>
    notIn?: $Enums.contact_channel[] | ListEnumcontact_channelFieldRefInput<$PrismaModel>
    not?: NestedEnumcontact_channelFilter<$PrismaModel> | $Enums.contact_channel
  }

  export type NestedEnumcontact_channelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.contact_channel | Enumcontact_channelFieldRefInput<$PrismaModel>
    in?: $Enums.contact_channel[] | ListEnumcontact_channelFieldRefInput<$PrismaModel>
    notIn?: $Enums.contact_channel[] | ListEnumcontact_channelFieldRefInput<$PrismaModel>
    not?: NestedEnumcontact_channelWithAggregatesFilter<$PrismaModel> | $Enums.contact_channel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumcontact_channelFilter<$PrismaModel>
    _max?: NestedEnumcontact_channelFilter<$PrismaModel>
  }

  export type NestedEnumuser_roleNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.user_role | Enumuser_roleFieldRefInput<$PrismaModel> | null
    in?: $Enums.user_role[] | ListEnumuser_roleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.user_role[] | ListEnumuser_roleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumuser_roleNullableFilter<$PrismaModel> | $Enums.user_role | null
    isSet?: boolean
  }

  export type NestedEnumaudit_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.audit_status | Enumaudit_statusFieldRefInput<$PrismaModel>
    in?: $Enums.audit_status[] | ListEnumaudit_statusFieldRefInput<$PrismaModel>
    notIn?: $Enums.audit_status[] | ListEnumaudit_statusFieldRefInput<$PrismaModel>
    not?: NestedEnumaudit_statusFilter<$PrismaModel> | $Enums.audit_status
  }

  export type NestedEnumuser_roleNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.user_role | Enumuser_roleFieldRefInput<$PrismaModel> | null
    in?: $Enums.user_role[] | ListEnumuser_roleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.user_role[] | ListEnumuser_roleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumuser_roleNullableWithAggregatesFilter<$PrismaModel> | $Enums.user_role | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumuser_roleNullableFilter<$PrismaModel>
    _max?: NestedEnumuser_roleNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedEnumaudit_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.audit_status | Enumaudit_statusFieldRefInput<$PrismaModel>
    in?: $Enums.audit_status[] | ListEnumaudit_statusFieldRefInput<$PrismaModel>
    notIn?: $Enums.audit_status[] | ListEnumaudit_statusFieldRefInput<$PrismaModel>
    not?: NestedEnumaudit_statusWithAggregatesFilter<$PrismaModel> | $Enums.audit_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumaudit_statusFilter<$PrismaModel>
    _max?: NestedEnumaudit_statusFilter<$PrismaModel>
  }

  export type NestedEnumwebhook_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.webhook_status | Enumwebhook_statusFieldRefInput<$PrismaModel>
    in?: $Enums.webhook_status[] | ListEnumwebhook_statusFieldRefInput<$PrismaModel>
    notIn?: $Enums.webhook_status[] | ListEnumwebhook_statusFieldRefInput<$PrismaModel>
    not?: NestedEnumwebhook_statusFilter<$PrismaModel> | $Enums.webhook_status
  }

  export type NestedEnumwebhook_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.webhook_status | Enumwebhook_statusFieldRefInput<$PrismaModel>
    in?: $Enums.webhook_status[] | ListEnumwebhook_statusFieldRefInput<$PrismaModel>
    notIn?: $Enums.webhook_status[] | ListEnumwebhook_statusFieldRefInput<$PrismaModel>
    not?: NestedEnumwebhook_statusWithAggregatesFilter<$PrismaModel> | $Enums.webhook_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumwebhook_statusFilter<$PrismaModel>
    _max?: NestedEnumwebhook_statusFilter<$PrismaModel>
  }

  export type profileCreateWithoutUserInput = {
    id?: string
    username: string
    display_name: string
    bio?: string | null
    avatar_url?: string | null
    state: string
    city: string
    city_slug?: string | null
    contact_email?: string | null
    whatsapp?: string | null
    twitch?: string | null
    youtube?: string | null
    instagram?: string | null
    featured_media_id?: string | null
    tags_count?: number | null
    status?: $Enums.profile_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    media?: mediaCreateNestedManyWithoutPlayerInput
    boosts?: boostCreateNestedManyWithoutPlayerInput
    strikes?: strikeCreateNestedManyWithoutPlayerInput
    notes?: user_noteCreateNestedManyWithoutPlayerInput
    contact_events?: contact_eventCreateNestedManyWithoutPlayerInput
    reports_against?: reportCreateNestedManyWithoutProfile_targetInput
    player_tags?: player_tagCreateNestedManyWithoutPlayerInput
    featured_assignments?: featured_assignmentCreateNestedManyWithoutPlayerInput
  }

  export type profileUncheckedCreateWithoutUserInput = {
    id?: string
    username: string
    display_name: string
    bio?: string | null
    avatar_url?: string | null
    state: string
    city: string
    city_slug?: string | null
    contact_email?: string | null
    whatsapp?: string | null
    twitch?: string | null
    youtube?: string | null
    instagram?: string | null
    featured_media_id?: string | null
    tags_count?: number | null
    status?: $Enums.profile_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    media?: mediaUncheckedCreateNestedManyWithoutPlayerInput
    boosts?: boostUncheckedCreateNestedManyWithoutPlayerInput
    strikes?: strikeUncheckedCreateNestedManyWithoutPlayerInput
    notes?: user_noteUncheckedCreateNestedManyWithoutPlayerInput
    contact_events?: contact_eventUncheckedCreateNestedManyWithoutPlayerInput
    reports_against?: reportUncheckedCreateNestedManyWithoutProfile_targetInput
    player_tags?: player_tagUncheckedCreateNestedManyWithoutPlayerInput
    featured_assignments?: featured_assignmentUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type profileCreateOrConnectWithoutUserInput = {
    where: profileWhereUniqueInput
    create: XOR<profileCreateWithoutUserInput, profileUncheckedCreateWithoutUserInput>
  }

  export type support_ticketCreateWithoutUserInput = {
    id?: string
    email?: string | null
    subject: string
    message: string
    priority?: $Enums.ticket_priority
    status?: $Enums.ticket_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    assignee?: userCreateNestedOneWithoutAssigned_ticketsInput
  }

  export type support_ticketUncheckedCreateWithoutUserInput = {
    id?: string
    email?: string | null
    subject: string
    message: string
    priority?: $Enums.ticket_priority
    status?: $Enums.ticket_status
    assigned_to?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type support_ticketCreateOrConnectWithoutUserInput = {
    where: support_ticketWhereUniqueInput
    create: XOR<support_ticketCreateWithoutUserInput, support_ticketUncheckedCreateWithoutUserInput>
  }

  export type support_ticketCreateManyUserInputEnvelope = {
    data: support_ticketCreateManyUserInput | support_ticketCreateManyUserInput[]
  }

  export type support_ticketCreateWithoutAssigneeInput = {
    id?: string
    email?: string | null
    subject: string
    message: string
    priority?: $Enums.ticket_priority
    status?: $Enums.ticket_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    user?: userCreateNestedOneWithoutTicketsInput
  }

  export type support_ticketUncheckedCreateWithoutAssigneeInput = {
    id?: string
    user_id?: string | null
    email?: string | null
    subject: string
    message: string
    priority?: $Enums.ticket_priority
    status?: $Enums.ticket_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type support_ticketCreateOrConnectWithoutAssigneeInput = {
    where: support_ticketWhereUniqueInput
    create: XOR<support_ticketCreateWithoutAssigneeInput, support_ticketUncheckedCreateWithoutAssigneeInput>
  }

  export type support_ticketCreateManyAssigneeInputEnvelope = {
    data: support_ticketCreateManyAssigneeInput | support_ticketCreateManyAssigneeInput[]
  }

  export type reportCreateWithoutReporter_userInput = {
    id?: string
    target_type: string
    reason: $Enums.report_reason
    details?: string | null
    severity?: $Enums.severity_level
    status?: $Enums.report_status
    resolution_note?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    media_target?: mediaCreateNestedOneWithoutReports_againstInput
    profile_target?: profileCreateNestedOneWithoutReports_againstInput
  }

  export type reportUncheckedCreateWithoutReporter_userInput = {
    id?: string
    target_type: string
    target_id: string
    reason: $Enums.report_reason
    details?: string | null
    severity?: $Enums.severity_level
    status?: $Enums.report_status
    resolution_note?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type reportCreateOrConnectWithoutReporter_userInput = {
    where: reportWhereUniqueInput
    create: XOR<reportCreateWithoutReporter_userInput, reportUncheckedCreateWithoutReporter_userInput>
  }

  export type reportCreateManyReporter_userInputEnvelope = {
    data: reportCreateManyReporter_userInput | reportCreateManyReporter_userInput[]
  }

  export type user_noteCreateWithoutAuthorInput = {
    id?: string
    note: string
    status?: $Enums.setting_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    player: profileCreateNestedOneWithoutNotesInput
  }

  export type user_noteUncheckedCreateWithoutAuthorInput = {
    id?: string
    player_id: string
    note: string
    status?: $Enums.setting_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type user_noteCreateOrConnectWithoutAuthorInput = {
    where: user_noteWhereUniqueInput
    create: XOR<user_noteCreateWithoutAuthorInput, user_noteUncheckedCreateWithoutAuthorInput>
  }

  export type user_noteCreateManyAuthorInputEnvelope = {
    data: user_noteCreateManyAuthorInput | user_noteCreateManyAuthorInput[]
  }

  export type sessionCreateWithoutUserInput = {
    id?: string
    session_token: string
    ip?: string | null
    user_agent?: string | null
    expires_at: Date | string
    status?: $Enums.setting_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type sessionUncheckedCreateWithoutUserInput = {
    id?: string
    session_token: string
    ip?: string | null
    user_agent?: string | null
    expires_at: Date | string
    status?: $Enums.setting_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type sessionCreateOrConnectWithoutUserInput = {
    where: sessionWhereUniqueInput
    create: XOR<sessionCreateWithoutUserInput, sessionUncheckedCreateWithoutUserInput>
  }

  export type sessionCreateManyUserInputEnvelope = {
    data: sessionCreateManyUserInput | sessionCreateManyUserInput[]
  }

  export type profileUpsertWithoutUserInput = {
    update: XOR<profileUpdateWithoutUserInput, profileUncheckedUpdateWithoutUserInput>
    create: XOR<profileCreateWithoutUserInput, profileUncheckedCreateWithoutUserInput>
    where?: profileWhereInput
  }

  export type profileUpdateToOneWithWhereWithoutUserInput = {
    where?: profileWhereInput
    data: XOR<profileUpdateWithoutUserInput, profileUncheckedUpdateWithoutUserInput>
  }

  export type profileUpdateWithoutUserInput = {
    username?: StringFieldUpdateOperationsInput | string
    display_name?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    city_slug?: NullableStringFieldUpdateOperationsInput | string | null
    contact_email?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    twitch?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    featured_media_id?: NullableStringFieldUpdateOperationsInput | string | null
    tags_count?: NullableIntFieldUpdateOperationsInput | number | null
    status?: Enumprofile_statusFieldUpdateOperationsInput | $Enums.profile_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    media?: mediaUpdateManyWithoutPlayerNestedInput
    boosts?: boostUpdateManyWithoutPlayerNestedInput
    strikes?: strikeUpdateManyWithoutPlayerNestedInput
    notes?: user_noteUpdateManyWithoutPlayerNestedInput
    contact_events?: contact_eventUpdateManyWithoutPlayerNestedInput
    reports_against?: reportUpdateManyWithoutProfile_targetNestedInput
    player_tags?: player_tagUpdateManyWithoutPlayerNestedInput
    featured_assignments?: featured_assignmentUpdateManyWithoutPlayerNestedInput
  }

  export type profileUncheckedUpdateWithoutUserInput = {
    username?: StringFieldUpdateOperationsInput | string
    display_name?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    city_slug?: NullableStringFieldUpdateOperationsInput | string | null
    contact_email?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    twitch?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    featured_media_id?: NullableStringFieldUpdateOperationsInput | string | null
    tags_count?: NullableIntFieldUpdateOperationsInput | number | null
    status?: Enumprofile_statusFieldUpdateOperationsInput | $Enums.profile_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    media?: mediaUncheckedUpdateManyWithoutPlayerNestedInput
    boosts?: boostUncheckedUpdateManyWithoutPlayerNestedInput
    strikes?: strikeUncheckedUpdateManyWithoutPlayerNestedInput
    notes?: user_noteUncheckedUpdateManyWithoutPlayerNestedInput
    contact_events?: contact_eventUncheckedUpdateManyWithoutPlayerNestedInput
    reports_against?: reportUncheckedUpdateManyWithoutProfile_targetNestedInput
    player_tags?: player_tagUncheckedUpdateManyWithoutPlayerNestedInput
    featured_assignments?: featured_assignmentUncheckedUpdateManyWithoutPlayerNestedInput
  }

  export type support_ticketUpsertWithWhereUniqueWithoutUserInput = {
    where: support_ticketWhereUniqueInput
    update: XOR<support_ticketUpdateWithoutUserInput, support_ticketUncheckedUpdateWithoutUserInput>
    create: XOR<support_ticketCreateWithoutUserInput, support_ticketUncheckedCreateWithoutUserInput>
  }

  export type support_ticketUpdateWithWhereUniqueWithoutUserInput = {
    where: support_ticketWhereUniqueInput
    data: XOR<support_ticketUpdateWithoutUserInput, support_ticketUncheckedUpdateWithoutUserInput>
  }

  export type support_ticketUpdateManyWithWhereWithoutUserInput = {
    where: support_ticketScalarWhereInput
    data: XOR<support_ticketUpdateManyMutationInput, support_ticketUncheckedUpdateManyWithoutUserInput>
  }

  export type support_ticketScalarWhereInput = {
    AND?: support_ticketScalarWhereInput | support_ticketScalarWhereInput[]
    OR?: support_ticketScalarWhereInput[]
    NOT?: support_ticketScalarWhereInput | support_ticketScalarWhereInput[]
    id?: StringFilter<"support_ticket"> | string
    user_id?: StringNullableFilter<"support_ticket"> | string | null
    email?: StringNullableFilter<"support_ticket"> | string | null
    subject?: StringFilter<"support_ticket"> | string
    message?: StringFilter<"support_ticket"> | string
    priority?: Enumticket_priorityFilter<"support_ticket"> | $Enums.ticket_priority
    status?: Enumticket_statusFilter<"support_ticket"> | $Enums.ticket_status
    assigned_to?: StringNullableFilter<"support_ticket"> | string | null
    created_at?: DateTimeFilter<"support_ticket"> | Date | string
    updated_at?: DateTimeFilter<"support_ticket"> | Date | string
    deleted_at?: DateTimeNullableFilter<"support_ticket"> | Date | string | null
  }

  export type support_ticketUpsertWithWhereUniqueWithoutAssigneeInput = {
    where: support_ticketWhereUniqueInput
    update: XOR<support_ticketUpdateWithoutAssigneeInput, support_ticketUncheckedUpdateWithoutAssigneeInput>
    create: XOR<support_ticketCreateWithoutAssigneeInput, support_ticketUncheckedCreateWithoutAssigneeInput>
  }

  export type support_ticketUpdateWithWhereUniqueWithoutAssigneeInput = {
    where: support_ticketWhereUniqueInput
    data: XOR<support_ticketUpdateWithoutAssigneeInput, support_ticketUncheckedUpdateWithoutAssigneeInput>
  }

  export type support_ticketUpdateManyWithWhereWithoutAssigneeInput = {
    where: support_ticketScalarWhereInput
    data: XOR<support_ticketUpdateManyMutationInput, support_ticketUncheckedUpdateManyWithoutAssigneeInput>
  }

  export type reportUpsertWithWhereUniqueWithoutReporter_userInput = {
    where: reportWhereUniqueInput
    update: XOR<reportUpdateWithoutReporter_userInput, reportUncheckedUpdateWithoutReporter_userInput>
    create: XOR<reportCreateWithoutReporter_userInput, reportUncheckedCreateWithoutReporter_userInput>
  }

  export type reportUpdateWithWhereUniqueWithoutReporter_userInput = {
    where: reportWhereUniqueInput
    data: XOR<reportUpdateWithoutReporter_userInput, reportUncheckedUpdateWithoutReporter_userInput>
  }

  export type reportUpdateManyWithWhereWithoutReporter_userInput = {
    where: reportScalarWhereInput
    data: XOR<reportUpdateManyMutationInput, reportUncheckedUpdateManyWithoutReporter_userInput>
  }

  export type reportScalarWhereInput = {
    AND?: reportScalarWhereInput | reportScalarWhereInput[]
    OR?: reportScalarWhereInput[]
    NOT?: reportScalarWhereInput | reportScalarWhereInput[]
    id?: StringFilter<"report"> | string
    reporter_user_id?: StringNullableFilter<"report"> | string | null
    target_type?: StringFilter<"report"> | string
    target_id?: StringFilter<"report"> | string
    reason?: Enumreport_reasonFilter<"report"> | $Enums.report_reason
    details?: StringNullableFilter<"report"> | string | null
    severity?: Enumseverity_levelFilter<"report"> | $Enums.severity_level
    status?: Enumreport_statusFilter<"report"> | $Enums.report_status
    resolution_note?: StringNullableFilter<"report"> | string | null
    created_at?: DateTimeFilter<"report"> | Date | string
    updated_at?: DateTimeFilter<"report"> | Date | string
    deleted_at?: DateTimeNullableFilter<"report"> | Date | string | null
  }

  export type user_noteUpsertWithWhereUniqueWithoutAuthorInput = {
    where: user_noteWhereUniqueInput
    update: XOR<user_noteUpdateWithoutAuthorInput, user_noteUncheckedUpdateWithoutAuthorInput>
    create: XOR<user_noteCreateWithoutAuthorInput, user_noteUncheckedCreateWithoutAuthorInput>
  }

  export type user_noteUpdateWithWhereUniqueWithoutAuthorInput = {
    where: user_noteWhereUniqueInput
    data: XOR<user_noteUpdateWithoutAuthorInput, user_noteUncheckedUpdateWithoutAuthorInput>
  }

  export type user_noteUpdateManyWithWhereWithoutAuthorInput = {
    where: user_noteScalarWhereInput
    data: XOR<user_noteUpdateManyMutationInput, user_noteUncheckedUpdateManyWithoutAuthorInput>
  }

  export type user_noteScalarWhereInput = {
    AND?: user_noteScalarWhereInput | user_noteScalarWhereInput[]
    OR?: user_noteScalarWhereInput[]
    NOT?: user_noteScalarWhereInput | user_noteScalarWhereInput[]
    id?: StringFilter<"user_note"> | string
    player_id?: StringFilter<"user_note"> | string
    author_id?: StringFilter<"user_note"> | string
    note?: StringFilter<"user_note"> | string
    status?: Enumsetting_statusFilter<"user_note"> | $Enums.setting_status
    created_at?: DateTimeFilter<"user_note"> | Date | string
    updated_at?: DateTimeFilter<"user_note"> | Date | string
    deleted_at?: DateTimeNullableFilter<"user_note"> | Date | string | null
  }

  export type sessionUpsertWithWhereUniqueWithoutUserInput = {
    where: sessionWhereUniqueInput
    update: XOR<sessionUpdateWithoutUserInput, sessionUncheckedUpdateWithoutUserInput>
    create: XOR<sessionCreateWithoutUserInput, sessionUncheckedCreateWithoutUserInput>
  }

  export type sessionUpdateWithWhereUniqueWithoutUserInput = {
    where: sessionWhereUniqueInput
    data: XOR<sessionUpdateWithoutUserInput, sessionUncheckedUpdateWithoutUserInput>
  }

  export type sessionUpdateManyWithWhereWithoutUserInput = {
    where: sessionScalarWhereInput
    data: XOR<sessionUpdateManyMutationInput, sessionUncheckedUpdateManyWithoutUserInput>
  }

  export type sessionScalarWhereInput = {
    AND?: sessionScalarWhereInput | sessionScalarWhereInput[]
    OR?: sessionScalarWhereInput[]
    NOT?: sessionScalarWhereInput | sessionScalarWhereInput[]
    id?: StringFilter<"session"> | string
    user_id?: StringFilter<"session"> | string
    session_token?: StringFilter<"session"> | string
    ip?: StringNullableFilter<"session"> | string | null
    user_agent?: StringNullableFilter<"session"> | string | null
    expires_at?: DateTimeFilter<"session"> | Date | string
    status?: Enumsetting_statusFilter<"session"> | $Enums.setting_status
    created_at?: DateTimeFilter<"session"> | Date | string
    updated_at?: DateTimeFilter<"session"> | Date | string
    deleted_at?: DateTimeNullableFilter<"session"> | Date | string | null
  }

  export type userCreateWithoutProfileInput = {
    id?: string
    email: string
    password_hash: string
    role?: $Enums.user_role
    status?: $Enums.user_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    tickets?: support_ticketCreateNestedManyWithoutUserInput
    assigned_tickets?: support_ticketCreateNestedManyWithoutAssigneeInput
    reports_made?: reportCreateNestedManyWithoutReporter_userInput
    notes_authored?: user_noteCreateNestedManyWithoutAuthorInput
    sessions?: sessionCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutProfileInput = {
    id?: string
    email: string
    password_hash: string
    role?: $Enums.user_role
    status?: $Enums.user_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    tickets?: support_ticketUncheckedCreateNestedManyWithoutUserInput
    assigned_tickets?: support_ticketUncheckedCreateNestedManyWithoutAssigneeInput
    reports_made?: reportUncheckedCreateNestedManyWithoutReporter_userInput
    notes_authored?: user_noteUncheckedCreateNestedManyWithoutAuthorInput
    sessions?: sessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutProfileInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutProfileInput, userUncheckedCreateWithoutProfileInput>
  }

  export type mediaCreateWithoutPlayerInput = {
    id?: string
    type: $Enums.media_type
    source?: $Enums.media_source
    url: string
    poster_url?: string | null
    blur_data_url?: string | null
    width?: number | null
    height?: number | null
    duration_sec?: number | null
    focal_point_x?: number | null
    focal_point_y?: number | null
    variants?: InputJsonValue | null
    hls_url?: string | null
    nsfw_score?: number | null
    nsfw_labels?: InputJsonValue | null
    title?: string | null
    tags_cache?: mediaCreatetags_cacheInput | string[]
    status?: $Enums.media_status
    moderation_history?: InputJsonValue | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    reports_against?: reportCreateNestedManyWithoutMedia_targetInput
    featured_assignments?: featured_assignmentCreateNestedManyWithoutMedia_refInput
  }

  export type mediaUncheckedCreateWithoutPlayerInput = {
    id?: string
    type: $Enums.media_type
    source?: $Enums.media_source
    url: string
    poster_url?: string | null
    blur_data_url?: string | null
    width?: number | null
    height?: number | null
    duration_sec?: number | null
    focal_point_x?: number | null
    focal_point_y?: number | null
    variants?: InputJsonValue | null
    hls_url?: string | null
    nsfw_score?: number | null
    nsfw_labels?: InputJsonValue | null
    title?: string | null
    tags_cache?: mediaCreatetags_cacheInput | string[]
    status?: $Enums.media_status
    moderation_history?: InputJsonValue | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    reports_against?: reportUncheckedCreateNestedManyWithoutMedia_targetInput
    featured_assignments?: featured_assignmentUncheckedCreateNestedManyWithoutMedia_refInput
  }

  export type mediaCreateOrConnectWithoutPlayerInput = {
    where: mediaWhereUniqueInput
    create: XOR<mediaCreateWithoutPlayerInput, mediaUncheckedCreateWithoutPlayerInput>
  }

  export type mediaCreateManyPlayerInputEnvelope = {
    data: mediaCreateManyPlayerInput | mediaCreateManyPlayerInput[]
  }

  export type boostCreateWithoutPlayerInput = {
    id?: string
    status?: $Enums.boost_status
    starts_at: Date | string
    ends_at: Date | string
    provider?: $Enums.provider_kind
    external_id?: string | null
    amount_cents: number
    currency?: string
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type boostUncheckedCreateWithoutPlayerInput = {
    id?: string
    status?: $Enums.boost_status
    starts_at: Date | string
    ends_at: Date | string
    provider?: $Enums.provider_kind
    external_id?: string | null
    amount_cents: number
    currency?: string
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type boostCreateOrConnectWithoutPlayerInput = {
    where: boostWhereUniqueInput
    create: XOR<boostCreateWithoutPlayerInput, boostUncheckedCreateWithoutPlayerInput>
  }

  export type boostCreateManyPlayerInputEnvelope = {
    data: boostCreateManyPlayerInput | boostCreateManyPlayerInput[]
  }

  export type strikeCreateWithoutPlayerInput = {
    id?: string
    reason: string
    severity?: $Enums.severity_level
    expires_at?: Date | string | null
    status?: $Enums.setting_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type strikeUncheckedCreateWithoutPlayerInput = {
    id?: string
    reason: string
    severity?: $Enums.severity_level
    expires_at?: Date | string | null
    status?: $Enums.setting_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type strikeCreateOrConnectWithoutPlayerInput = {
    where: strikeWhereUniqueInput
    create: XOR<strikeCreateWithoutPlayerInput, strikeUncheckedCreateWithoutPlayerInput>
  }

  export type strikeCreateManyPlayerInputEnvelope = {
    data: strikeCreateManyPlayerInput | strikeCreateManyPlayerInput[]
  }

  export type user_noteCreateWithoutPlayerInput = {
    id?: string
    note: string
    status?: $Enums.setting_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    author: userCreateNestedOneWithoutNotes_authoredInput
  }

  export type user_noteUncheckedCreateWithoutPlayerInput = {
    id?: string
    author_id: string
    note: string
    status?: $Enums.setting_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type user_noteCreateOrConnectWithoutPlayerInput = {
    where: user_noteWhereUniqueInput
    create: XOR<user_noteCreateWithoutPlayerInput, user_noteUncheckedCreateWithoutPlayerInput>
  }

  export type user_noteCreateManyPlayerInputEnvelope = {
    data: user_noteCreateManyPlayerInput | user_noteCreateManyPlayerInput[]
  }

  export type contact_eventCreateWithoutPlayerInput = {
    id?: string
    channel: $Enums.contact_channel
    requester_ip?: string | null
    user_agent?: string | null
    referrer?: string | null
    message?: string | null
    status?: $Enums.setting_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type contact_eventUncheckedCreateWithoutPlayerInput = {
    id?: string
    channel: $Enums.contact_channel
    requester_ip?: string | null
    user_agent?: string | null
    referrer?: string | null
    message?: string | null
    status?: $Enums.setting_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type contact_eventCreateOrConnectWithoutPlayerInput = {
    where: contact_eventWhereUniqueInput
    create: XOR<contact_eventCreateWithoutPlayerInput, contact_eventUncheckedCreateWithoutPlayerInput>
  }

  export type contact_eventCreateManyPlayerInputEnvelope = {
    data: contact_eventCreateManyPlayerInput | contact_eventCreateManyPlayerInput[]
  }

  export type reportCreateWithoutProfile_targetInput = {
    id?: string
    target_type: string
    reason: $Enums.report_reason
    details?: string | null
    severity?: $Enums.severity_level
    status?: $Enums.report_status
    resolution_note?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    media_target?: mediaCreateNestedOneWithoutReports_againstInput
    reporter_user?: userCreateNestedOneWithoutReports_madeInput
  }

  export type reportUncheckedCreateWithoutProfile_targetInput = {
    id?: string
    reporter_user_id?: string | null
    target_type: string
    reason: $Enums.report_reason
    details?: string | null
    severity?: $Enums.severity_level
    status?: $Enums.report_status
    resolution_note?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type reportCreateOrConnectWithoutProfile_targetInput = {
    where: reportWhereUniqueInput
    create: XOR<reportCreateWithoutProfile_targetInput, reportUncheckedCreateWithoutProfile_targetInput>
  }

  export type reportCreateManyProfile_targetInputEnvelope = {
    data: reportCreateManyProfile_targetInput | reportCreateManyProfile_targetInput[]
  }

  export type player_tagCreateWithoutPlayerInput = {
    id?: string
    status?: $Enums.setting_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    tag_ref: tagCreateNestedOneWithoutPlayer_tagsInput
  }

  export type player_tagUncheckedCreateWithoutPlayerInput = {
    id?: string
    tag_id: string
    status?: $Enums.setting_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type player_tagCreateOrConnectWithoutPlayerInput = {
    where: player_tagWhereUniqueInput
    create: XOR<player_tagCreateWithoutPlayerInput, player_tagUncheckedCreateWithoutPlayerInput>
  }

  export type player_tagCreateManyPlayerInputEnvelope = {
    data: player_tagCreateManyPlayerInput | player_tagCreateManyPlayerInput[]
  }

  export type featured_assignmentCreateWithoutPlayerInput = {
    id?: string
    slot_key: $Enums.feature_slot_key
    starts_at: Date | string
    ends_at: Date | string
    priority?: number
    status?: $Enums.setting_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    media_ref?: mediaCreateNestedOneWithoutFeatured_assignmentsInput
  }

  export type featured_assignmentUncheckedCreateWithoutPlayerInput = {
    id?: string
    slot_key: $Enums.feature_slot_key
    media_id?: string | null
    starts_at: Date | string
    ends_at: Date | string
    priority?: number
    status?: $Enums.setting_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type featured_assignmentCreateOrConnectWithoutPlayerInput = {
    where: featured_assignmentWhereUniqueInput
    create: XOR<featured_assignmentCreateWithoutPlayerInput, featured_assignmentUncheckedCreateWithoutPlayerInput>
  }

  export type featured_assignmentCreateManyPlayerInputEnvelope = {
    data: featured_assignmentCreateManyPlayerInput | featured_assignmentCreateManyPlayerInput[]
  }

  export type userUpsertWithoutProfileInput = {
    update: XOR<userUpdateWithoutProfileInput, userUncheckedUpdateWithoutProfileInput>
    create: XOR<userCreateWithoutProfileInput, userUncheckedCreateWithoutProfileInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutProfileInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutProfileInput, userUncheckedUpdateWithoutProfileInput>
  }

  export type userUpdateWithoutProfileInput = {
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: Enumuser_roleFieldUpdateOperationsInput | $Enums.user_role
    status?: Enumuser_statusFieldUpdateOperationsInput | $Enums.user_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tickets?: support_ticketUpdateManyWithoutUserNestedInput
    assigned_tickets?: support_ticketUpdateManyWithoutAssigneeNestedInput
    reports_made?: reportUpdateManyWithoutReporter_userNestedInput
    notes_authored?: user_noteUpdateManyWithoutAuthorNestedInput
    sessions?: sessionUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutProfileInput = {
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: Enumuser_roleFieldUpdateOperationsInput | $Enums.user_role
    status?: Enumuser_statusFieldUpdateOperationsInput | $Enums.user_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tickets?: support_ticketUncheckedUpdateManyWithoutUserNestedInput
    assigned_tickets?: support_ticketUncheckedUpdateManyWithoutAssigneeNestedInput
    reports_made?: reportUncheckedUpdateManyWithoutReporter_userNestedInput
    notes_authored?: user_noteUncheckedUpdateManyWithoutAuthorNestedInput
    sessions?: sessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type mediaUpsertWithWhereUniqueWithoutPlayerInput = {
    where: mediaWhereUniqueInput
    update: XOR<mediaUpdateWithoutPlayerInput, mediaUncheckedUpdateWithoutPlayerInput>
    create: XOR<mediaCreateWithoutPlayerInput, mediaUncheckedCreateWithoutPlayerInput>
  }

  export type mediaUpdateWithWhereUniqueWithoutPlayerInput = {
    where: mediaWhereUniqueInput
    data: XOR<mediaUpdateWithoutPlayerInput, mediaUncheckedUpdateWithoutPlayerInput>
  }

  export type mediaUpdateManyWithWhereWithoutPlayerInput = {
    where: mediaScalarWhereInput
    data: XOR<mediaUpdateManyMutationInput, mediaUncheckedUpdateManyWithoutPlayerInput>
  }

  export type mediaScalarWhereInput = {
    AND?: mediaScalarWhereInput | mediaScalarWhereInput[]
    OR?: mediaScalarWhereInput[]
    NOT?: mediaScalarWhereInput | mediaScalarWhereInput[]
    id?: StringFilter<"media"> | string
    player_id?: StringFilter<"media"> | string
    type?: Enummedia_typeFilter<"media"> | $Enums.media_type
    source?: Enummedia_sourceFilter<"media"> | $Enums.media_source
    url?: StringFilter<"media"> | string
    poster_url?: StringNullableFilter<"media"> | string | null
    blur_data_url?: StringNullableFilter<"media"> | string | null
    width?: IntNullableFilter<"media"> | number | null
    height?: IntNullableFilter<"media"> | number | null
    duration_sec?: IntNullableFilter<"media"> | number | null
    focal_point_x?: IntNullableFilter<"media"> | number | null
    focal_point_y?: IntNullableFilter<"media"> | number | null
    variants?: JsonNullableFilter<"media">
    hls_url?: StringNullableFilter<"media"> | string | null
    nsfw_score?: FloatNullableFilter<"media"> | number | null
    nsfw_labels?: JsonNullableFilter<"media">
    title?: StringNullableFilter<"media"> | string | null
    tags_cache?: StringNullableListFilter<"media">
    status?: Enummedia_statusFilter<"media"> | $Enums.media_status
    moderation_history?: JsonNullableFilter<"media">
    created_at?: DateTimeFilter<"media"> | Date | string
    updated_at?: DateTimeFilter<"media"> | Date | string
    deleted_at?: DateTimeNullableFilter<"media"> | Date | string | null
  }

  export type boostUpsertWithWhereUniqueWithoutPlayerInput = {
    where: boostWhereUniqueInput
    update: XOR<boostUpdateWithoutPlayerInput, boostUncheckedUpdateWithoutPlayerInput>
    create: XOR<boostCreateWithoutPlayerInput, boostUncheckedCreateWithoutPlayerInput>
  }

  export type boostUpdateWithWhereUniqueWithoutPlayerInput = {
    where: boostWhereUniqueInput
    data: XOR<boostUpdateWithoutPlayerInput, boostUncheckedUpdateWithoutPlayerInput>
  }

  export type boostUpdateManyWithWhereWithoutPlayerInput = {
    where: boostScalarWhereInput
    data: XOR<boostUpdateManyMutationInput, boostUncheckedUpdateManyWithoutPlayerInput>
  }

  export type boostScalarWhereInput = {
    AND?: boostScalarWhereInput | boostScalarWhereInput[]
    OR?: boostScalarWhereInput[]
    NOT?: boostScalarWhereInput | boostScalarWhereInput[]
    id?: StringFilter<"boost"> | string
    player_id?: StringFilter<"boost"> | string
    status?: Enumboost_statusFilter<"boost"> | $Enums.boost_status
    starts_at?: DateTimeFilter<"boost"> | Date | string
    ends_at?: DateTimeFilter<"boost"> | Date | string
    provider?: Enumprovider_kindFilter<"boost"> | $Enums.provider_kind
    external_id?: StringNullableFilter<"boost"> | string | null
    amount_cents?: IntFilter<"boost"> | number
    currency?: StringFilter<"boost"> | string
    created_at?: DateTimeFilter<"boost"> | Date | string
    updated_at?: DateTimeFilter<"boost"> | Date | string
    deleted_at?: DateTimeNullableFilter<"boost"> | Date | string | null
  }

  export type strikeUpsertWithWhereUniqueWithoutPlayerInput = {
    where: strikeWhereUniqueInput
    update: XOR<strikeUpdateWithoutPlayerInput, strikeUncheckedUpdateWithoutPlayerInput>
    create: XOR<strikeCreateWithoutPlayerInput, strikeUncheckedCreateWithoutPlayerInput>
  }

  export type strikeUpdateWithWhereUniqueWithoutPlayerInput = {
    where: strikeWhereUniqueInput
    data: XOR<strikeUpdateWithoutPlayerInput, strikeUncheckedUpdateWithoutPlayerInput>
  }

  export type strikeUpdateManyWithWhereWithoutPlayerInput = {
    where: strikeScalarWhereInput
    data: XOR<strikeUpdateManyMutationInput, strikeUncheckedUpdateManyWithoutPlayerInput>
  }

  export type strikeScalarWhereInput = {
    AND?: strikeScalarWhereInput | strikeScalarWhereInput[]
    OR?: strikeScalarWhereInput[]
    NOT?: strikeScalarWhereInput | strikeScalarWhereInput[]
    id?: StringFilter<"strike"> | string
    player_id?: StringFilter<"strike"> | string
    reason?: StringFilter<"strike"> | string
    severity?: Enumseverity_levelFilter<"strike"> | $Enums.severity_level
    expires_at?: DateTimeNullableFilter<"strike"> | Date | string | null
    status?: Enumsetting_statusFilter<"strike"> | $Enums.setting_status
    created_at?: DateTimeFilter<"strike"> | Date | string
    updated_at?: DateTimeFilter<"strike"> | Date | string
    deleted_at?: DateTimeNullableFilter<"strike"> | Date | string | null
  }

  export type user_noteUpsertWithWhereUniqueWithoutPlayerInput = {
    where: user_noteWhereUniqueInput
    update: XOR<user_noteUpdateWithoutPlayerInput, user_noteUncheckedUpdateWithoutPlayerInput>
    create: XOR<user_noteCreateWithoutPlayerInput, user_noteUncheckedCreateWithoutPlayerInput>
  }

  export type user_noteUpdateWithWhereUniqueWithoutPlayerInput = {
    where: user_noteWhereUniqueInput
    data: XOR<user_noteUpdateWithoutPlayerInput, user_noteUncheckedUpdateWithoutPlayerInput>
  }

  export type user_noteUpdateManyWithWhereWithoutPlayerInput = {
    where: user_noteScalarWhereInput
    data: XOR<user_noteUpdateManyMutationInput, user_noteUncheckedUpdateManyWithoutPlayerInput>
  }

  export type contact_eventUpsertWithWhereUniqueWithoutPlayerInput = {
    where: contact_eventWhereUniqueInput
    update: XOR<contact_eventUpdateWithoutPlayerInput, contact_eventUncheckedUpdateWithoutPlayerInput>
    create: XOR<contact_eventCreateWithoutPlayerInput, contact_eventUncheckedCreateWithoutPlayerInput>
  }

  export type contact_eventUpdateWithWhereUniqueWithoutPlayerInput = {
    where: contact_eventWhereUniqueInput
    data: XOR<contact_eventUpdateWithoutPlayerInput, contact_eventUncheckedUpdateWithoutPlayerInput>
  }

  export type contact_eventUpdateManyWithWhereWithoutPlayerInput = {
    where: contact_eventScalarWhereInput
    data: XOR<contact_eventUpdateManyMutationInput, contact_eventUncheckedUpdateManyWithoutPlayerInput>
  }

  export type contact_eventScalarWhereInput = {
    AND?: contact_eventScalarWhereInput | contact_eventScalarWhereInput[]
    OR?: contact_eventScalarWhereInput[]
    NOT?: contact_eventScalarWhereInput | contact_eventScalarWhereInput[]
    id?: StringFilter<"contact_event"> | string
    player_id?: StringFilter<"contact_event"> | string
    channel?: Enumcontact_channelFilter<"contact_event"> | $Enums.contact_channel
    requester_ip?: StringNullableFilter<"contact_event"> | string | null
    user_agent?: StringNullableFilter<"contact_event"> | string | null
    referrer?: StringNullableFilter<"contact_event"> | string | null
    message?: StringNullableFilter<"contact_event"> | string | null
    status?: Enumsetting_statusFilter<"contact_event"> | $Enums.setting_status
    created_at?: DateTimeFilter<"contact_event"> | Date | string
    updated_at?: DateTimeFilter<"contact_event"> | Date | string
    deleted_at?: DateTimeNullableFilter<"contact_event"> | Date | string | null
  }

  export type reportUpsertWithWhereUniqueWithoutProfile_targetInput = {
    where: reportWhereUniqueInput
    update: XOR<reportUpdateWithoutProfile_targetInput, reportUncheckedUpdateWithoutProfile_targetInput>
    create: XOR<reportCreateWithoutProfile_targetInput, reportUncheckedCreateWithoutProfile_targetInput>
  }

  export type reportUpdateWithWhereUniqueWithoutProfile_targetInput = {
    where: reportWhereUniqueInput
    data: XOR<reportUpdateWithoutProfile_targetInput, reportUncheckedUpdateWithoutProfile_targetInput>
  }

  export type reportUpdateManyWithWhereWithoutProfile_targetInput = {
    where: reportScalarWhereInput
    data: XOR<reportUpdateManyMutationInput, reportUncheckedUpdateManyWithoutProfile_targetInput>
  }

  export type player_tagUpsertWithWhereUniqueWithoutPlayerInput = {
    where: player_tagWhereUniqueInput
    update: XOR<player_tagUpdateWithoutPlayerInput, player_tagUncheckedUpdateWithoutPlayerInput>
    create: XOR<player_tagCreateWithoutPlayerInput, player_tagUncheckedCreateWithoutPlayerInput>
  }

  export type player_tagUpdateWithWhereUniqueWithoutPlayerInput = {
    where: player_tagWhereUniqueInput
    data: XOR<player_tagUpdateWithoutPlayerInput, player_tagUncheckedUpdateWithoutPlayerInput>
  }

  export type player_tagUpdateManyWithWhereWithoutPlayerInput = {
    where: player_tagScalarWhereInput
    data: XOR<player_tagUpdateManyMutationInput, player_tagUncheckedUpdateManyWithoutPlayerInput>
  }

  export type player_tagScalarWhereInput = {
    AND?: player_tagScalarWhereInput | player_tagScalarWhereInput[]
    OR?: player_tagScalarWhereInput[]
    NOT?: player_tagScalarWhereInput | player_tagScalarWhereInput[]
    id?: StringFilter<"player_tag"> | string
    player_id?: StringFilter<"player_tag"> | string
    tag_id?: StringFilter<"player_tag"> | string
    status?: Enumsetting_statusFilter<"player_tag"> | $Enums.setting_status
    created_at?: DateTimeFilter<"player_tag"> | Date | string
    updated_at?: DateTimeFilter<"player_tag"> | Date | string
    deleted_at?: DateTimeNullableFilter<"player_tag"> | Date | string | null
  }

  export type featured_assignmentUpsertWithWhereUniqueWithoutPlayerInput = {
    where: featured_assignmentWhereUniqueInput
    update: XOR<featured_assignmentUpdateWithoutPlayerInput, featured_assignmentUncheckedUpdateWithoutPlayerInput>
    create: XOR<featured_assignmentCreateWithoutPlayerInput, featured_assignmentUncheckedCreateWithoutPlayerInput>
  }

  export type featured_assignmentUpdateWithWhereUniqueWithoutPlayerInput = {
    where: featured_assignmentWhereUniqueInput
    data: XOR<featured_assignmentUpdateWithoutPlayerInput, featured_assignmentUncheckedUpdateWithoutPlayerInput>
  }

  export type featured_assignmentUpdateManyWithWhereWithoutPlayerInput = {
    where: featured_assignmentScalarWhereInput
    data: XOR<featured_assignmentUpdateManyMutationInput, featured_assignmentUncheckedUpdateManyWithoutPlayerInput>
  }

  export type featured_assignmentScalarWhereInput = {
    AND?: featured_assignmentScalarWhereInput | featured_assignmentScalarWhereInput[]
    OR?: featured_assignmentScalarWhereInput[]
    NOT?: featured_assignmentScalarWhereInput | featured_assignmentScalarWhereInput[]
    id?: StringFilter<"featured_assignment"> | string
    slot_key?: Enumfeature_slot_keyFilter<"featured_assignment"> | $Enums.feature_slot_key
    player_id?: StringFilter<"featured_assignment"> | string
    media_id?: StringNullableFilter<"featured_assignment"> | string | null
    starts_at?: DateTimeFilter<"featured_assignment"> | Date | string
    ends_at?: DateTimeFilter<"featured_assignment"> | Date | string
    priority?: IntFilter<"featured_assignment"> | number
    status?: Enumsetting_statusFilter<"featured_assignment"> | $Enums.setting_status
    created_at?: DateTimeFilter<"featured_assignment"> | Date | string
    updated_at?: DateTimeFilter<"featured_assignment"> | Date | string
    deleted_at?: DateTimeNullableFilter<"featured_assignment"> | Date | string | null
  }

  export type profileCreateWithoutMediaInput = {
    id?: string
    username: string
    display_name: string
    bio?: string | null
    avatar_url?: string | null
    state: string
    city: string
    city_slug?: string | null
    contact_email?: string | null
    whatsapp?: string | null
    twitch?: string | null
    youtube?: string | null
    instagram?: string | null
    featured_media_id?: string | null
    tags_count?: number | null
    status?: $Enums.profile_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    user: userCreateNestedOneWithoutProfileInput
    boosts?: boostCreateNestedManyWithoutPlayerInput
    strikes?: strikeCreateNestedManyWithoutPlayerInput
    notes?: user_noteCreateNestedManyWithoutPlayerInput
    contact_events?: contact_eventCreateNestedManyWithoutPlayerInput
    reports_against?: reportCreateNestedManyWithoutProfile_targetInput
    player_tags?: player_tagCreateNestedManyWithoutPlayerInput
    featured_assignments?: featured_assignmentCreateNestedManyWithoutPlayerInput
  }

  export type profileUncheckedCreateWithoutMediaInput = {
    id?: string
    user_id: string
    username: string
    display_name: string
    bio?: string | null
    avatar_url?: string | null
    state: string
    city: string
    city_slug?: string | null
    contact_email?: string | null
    whatsapp?: string | null
    twitch?: string | null
    youtube?: string | null
    instagram?: string | null
    featured_media_id?: string | null
    tags_count?: number | null
    status?: $Enums.profile_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    boosts?: boostUncheckedCreateNestedManyWithoutPlayerInput
    strikes?: strikeUncheckedCreateNestedManyWithoutPlayerInput
    notes?: user_noteUncheckedCreateNestedManyWithoutPlayerInput
    contact_events?: contact_eventUncheckedCreateNestedManyWithoutPlayerInput
    reports_against?: reportUncheckedCreateNestedManyWithoutProfile_targetInput
    player_tags?: player_tagUncheckedCreateNestedManyWithoutPlayerInput
    featured_assignments?: featured_assignmentUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type profileCreateOrConnectWithoutMediaInput = {
    where: profileWhereUniqueInput
    create: XOR<profileCreateWithoutMediaInput, profileUncheckedCreateWithoutMediaInput>
  }

  export type reportCreateWithoutMedia_targetInput = {
    id?: string
    target_type: string
    reason: $Enums.report_reason
    details?: string | null
    severity?: $Enums.severity_level
    status?: $Enums.report_status
    resolution_note?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    profile_target?: profileCreateNestedOneWithoutReports_againstInput
    reporter_user?: userCreateNestedOneWithoutReports_madeInput
  }

  export type reportUncheckedCreateWithoutMedia_targetInput = {
    id?: string
    reporter_user_id?: string | null
    target_type: string
    reason: $Enums.report_reason
    details?: string | null
    severity?: $Enums.severity_level
    status?: $Enums.report_status
    resolution_note?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type reportCreateOrConnectWithoutMedia_targetInput = {
    where: reportWhereUniqueInput
    create: XOR<reportCreateWithoutMedia_targetInput, reportUncheckedCreateWithoutMedia_targetInput>
  }

  export type reportCreateManyMedia_targetInputEnvelope = {
    data: reportCreateManyMedia_targetInput | reportCreateManyMedia_targetInput[]
  }

  export type featured_assignmentCreateWithoutMedia_refInput = {
    id?: string
    slot_key: $Enums.feature_slot_key
    starts_at: Date | string
    ends_at: Date | string
    priority?: number
    status?: $Enums.setting_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    player: profileCreateNestedOneWithoutFeatured_assignmentsInput
  }

  export type featured_assignmentUncheckedCreateWithoutMedia_refInput = {
    id?: string
    slot_key: $Enums.feature_slot_key
    player_id: string
    starts_at: Date | string
    ends_at: Date | string
    priority?: number
    status?: $Enums.setting_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type featured_assignmentCreateOrConnectWithoutMedia_refInput = {
    where: featured_assignmentWhereUniqueInput
    create: XOR<featured_assignmentCreateWithoutMedia_refInput, featured_assignmentUncheckedCreateWithoutMedia_refInput>
  }

  export type featured_assignmentCreateManyMedia_refInputEnvelope = {
    data: featured_assignmentCreateManyMedia_refInput | featured_assignmentCreateManyMedia_refInput[]
  }

  export type profileUpsertWithoutMediaInput = {
    update: XOR<profileUpdateWithoutMediaInput, profileUncheckedUpdateWithoutMediaInput>
    create: XOR<profileCreateWithoutMediaInput, profileUncheckedCreateWithoutMediaInput>
    where?: profileWhereInput
  }

  export type profileUpdateToOneWithWhereWithoutMediaInput = {
    where?: profileWhereInput
    data: XOR<profileUpdateWithoutMediaInput, profileUncheckedUpdateWithoutMediaInput>
  }

  export type profileUpdateWithoutMediaInput = {
    username?: StringFieldUpdateOperationsInput | string
    display_name?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    city_slug?: NullableStringFieldUpdateOperationsInput | string | null
    contact_email?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    twitch?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    featured_media_id?: NullableStringFieldUpdateOperationsInput | string | null
    tags_count?: NullableIntFieldUpdateOperationsInput | number | null
    status?: Enumprofile_statusFieldUpdateOperationsInput | $Enums.profile_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneRequiredWithoutProfileNestedInput
    boosts?: boostUpdateManyWithoutPlayerNestedInput
    strikes?: strikeUpdateManyWithoutPlayerNestedInput
    notes?: user_noteUpdateManyWithoutPlayerNestedInput
    contact_events?: contact_eventUpdateManyWithoutPlayerNestedInput
    reports_against?: reportUpdateManyWithoutProfile_targetNestedInput
    player_tags?: player_tagUpdateManyWithoutPlayerNestedInput
    featured_assignments?: featured_assignmentUpdateManyWithoutPlayerNestedInput
  }

  export type profileUncheckedUpdateWithoutMediaInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    display_name?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    city_slug?: NullableStringFieldUpdateOperationsInput | string | null
    contact_email?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    twitch?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    featured_media_id?: NullableStringFieldUpdateOperationsInput | string | null
    tags_count?: NullableIntFieldUpdateOperationsInput | number | null
    status?: Enumprofile_statusFieldUpdateOperationsInput | $Enums.profile_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    boosts?: boostUncheckedUpdateManyWithoutPlayerNestedInput
    strikes?: strikeUncheckedUpdateManyWithoutPlayerNestedInput
    notes?: user_noteUncheckedUpdateManyWithoutPlayerNestedInput
    contact_events?: contact_eventUncheckedUpdateManyWithoutPlayerNestedInput
    reports_against?: reportUncheckedUpdateManyWithoutProfile_targetNestedInput
    player_tags?: player_tagUncheckedUpdateManyWithoutPlayerNestedInput
    featured_assignments?: featured_assignmentUncheckedUpdateManyWithoutPlayerNestedInput
  }

  export type reportUpsertWithWhereUniqueWithoutMedia_targetInput = {
    where: reportWhereUniqueInput
    update: XOR<reportUpdateWithoutMedia_targetInput, reportUncheckedUpdateWithoutMedia_targetInput>
    create: XOR<reportCreateWithoutMedia_targetInput, reportUncheckedCreateWithoutMedia_targetInput>
  }

  export type reportUpdateWithWhereUniqueWithoutMedia_targetInput = {
    where: reportWhereUniqueInput
    data: XOR<reportUpdateWithoutMedia_targetInput, reportUncheckedUpdateWithoutMedia_targetInput>
  }

  export type reportUpdateManyWithWhereWithoutMedia_targetInput = {
    where: reportScalarWhereInput
    data: XOR<reportUpdateManyMutationInput, reportUncheckedUpdateManyWithoutMedia_targetInput>
  }

  export type featured_assignmentUpsertWithWhereUniqueWithoutMedia_refInput = {
    where: featured_assignmentWhereUniqueInput
    update: XOR<featured_assignmentUpdateWithoutMedia_refInput, featured_assignmentUncheckedUpdateWithoutMedia_refInput>
    create: XOR<featured_assignmentCreateWithoutMedia_refInput, featured_assignmentUncheckedCreateWithoutMedia_refInput>
  }

  export type featured_assignmentUpdateWithWhereUniqueWithoutMedia_refInput = {
    where: featured_assignmentWhereUniqueInput
    data: XOR<featured_assignmentUpdateWithoutMedia_refInput, featured_assignmentUncheckedUpdateWithoutMedia_refInput>
  }

  export type featured_assignmentUpdateManyWithWhereWithoutMedia_refInput = {
    where: featured_assignmentScalarWhereInput
    data: XOR<featured_assignmentUpdateManyMutationInput, featured_assignmentUncheckedUpdateManyWithoutMedia_refInput>
  }

  export type player_tagCreateWithoutTag_refInput = {
    id?: string
    status?: $Enums.setting_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    player: profileCreateNestedOneWithoutPlayer_tagsInput
  }

  export type player_tagUncheckedCreateWithoutTag_refInput = {
    id?: string
    player_id: string
    status?: $Enums.setting_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type player_tagCreateOrConnectWithoutTag_refInput = {
    where: player_tagWhereUniqueInput
    create: XOR<player_tagCreateWithoutTag_refInput, player_tagUncheckedCreateWithoutTag_refInput>
  }

  export type player_tagCreateManyTag_refInputEnvelope = {
    data: player_tagCreateManyTag_refInput | player_tagCreateManyTag_refInput[]
  }

  export type player_tagUpsertWithWhereUniqueWithoutTag_refInput = {
    where: player_tagWhereUniqueInput
    update: XOR<player_tagUpdateWithoutTag_refInput, player_tagUncheckedUpdateWithoutTag_refInput>
    create: XOR<player_tagCreateWithoutTag_refInput, player_tagUncheckedCreateWithoutTag_refInput>
  }

  export type player_tagUpdateWithWhereUniqueWithoutTag_refInput = {
    where: player_tagWhereUniqueInput
    data: XOR<player_tagUpdateWithoutTag_refInput, player_tagUncheckedUpdateWithoutTag_refInput>
  }

  export type player_tagUpdateManyWithWhereWithoutTag_refInput = {
    where: player_tagScalarWhereInput
    data: XOR<player_tagUpdateManyMutationInput, player_tagUncheckedUpdateManyWithoutTag_refInput>
  }

  export type profileCreateWithoutPlayer_tagsInput = {
    id?: string
    username: string
    display_name: string
    bio?: string | null
    avatar_url?: string | null
    state: string
    city: string
    city_slug?: string | null
    contact_email?: string | null
    whatsapp?: string | null
    twitch?: string | null
    youtube?: string | null
    instagram?: string | null
    featured_media_id?: string | null
    tags_count?: number | null
    status?: $Enums.profile_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    user: userCreateNestedOneWithoutProfileInput
    media?: mediaCreateNestedManyWithoutPlayerInput
    boosts?: boostCreateNestedManyWithoutPlayerInput
    strikes?: strikeCreateNestedManyWithoutPlayerInput
    notes?: user_noteCreateNestedManyWithoutPlayerInput
    contact_events?: contact_eventCreateNestedManyWithoutPlayerInput
    reports_against?: reportCreateNestedManyWithoutProfile_targetInput
    featured_assignments?: featured_assignmentCreateNestedManyWithoutPlayerInput
  }

  export type profileUncheckedCreateWithoutPlayer_tagsInput = {
    id?: string
    user_id: string
    username: string
    display_name: string
    bio?: string | null
    avatar_url?: string | null
    state: string
    city: string
    city_slug?: string | null
    contact_email?: string | null
    whatsapp?: string | null
    twitch?: string | null
    youtube?: string | null
    instagram?: string | null
    featured_media_id?: string | null
    tags_count?: number | null
    status?: $Enums.profile_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    media?: mediaUncheckedCreateNestedManyWithoutPlayerInput
    boosts?: boostUncheckedCreateNestedManyWithoutPlayerInput
    strikes?: strikeUncheckedCreateNestedManyWithoutPlayerInput
    notes?: user_noteUncheckedCreateNestedManyWithoutPlayerInput
    contact_events?: contact_eventUncheckedCreateNestedManyWithoutPlayerInput
    reports_against?: reportUncheckedCreateNestedManyWithoutProfile_targetInput
    featured_assignments?: featured_assignmentUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type profileCreateOrConnectWithoutPlayer_tagsInput = {
    where: profileWhereUniqueInput
    create: XOR<profileCreateWithoutPlayer_tagsInput, profileUncheckedCreateWithoutPlayer_tagsInput>
  }

  export type tagCreateWithoutPlayer_tagsInput = {
    id?: string
    slug: string
    label: string
    aliases?: tagCreatealiasesInput | string[]
    status?: $Enums.setting_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type tagUncheckedCreateWithoutPlayer_tagsInput = {
    id?: string
    slug: string
    label: string
    aliases?: tagCreatealiasesInput | string[]
    status?: $Enums.setting_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type tagCreateOrConnectWithoutPlayer_tagsInput = {
    where: tagWhereUniqueInput
    create: XOR<tagCreateWithoutPlayer_tagsInput, tagUncheckedCreateWithoutPlayer_tagsInput>
  }

  export type profileUpsertWithoutPlayer_tagsInput = {
    update: XOR<profileUpdateWithoutPlayer_tagsInput, profileUncheckedUpdateWithoutPlayer_tagsInput>
    create: XOR<profileCreateWithoutPlayer_tagsInput, profileUncheckedCreateWithoutPlayer_tagsInput>
    where?: profileWhereInput
  }

  export type profileUpdateToOneWithWhereWithoutPlayer_tagsInput = {
    where?: profileWhereInput
    data: XOR<profileUpdateWithoutPlayer_tagsInput, profileUncheckedUpdateWithoutPlayer_tagsInput>
  }

  export type profileUpdateWithoutPlayer_tagsInput = {
    username?: StringFieldUpdateOperationsInput | string
    display_name?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    city_slug?: NullableStringFieldUpdateOperationsInput | string | null
    contact_email?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    twitch?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    featured_media_id?: NullableStringFieldUpdateOperationsInput | string | null
    tags_count?: NullableIntFieldUpdateOperationsInput | number | null
    status?: Enumprofile_statusFieldUpdateOperationsInput | $Enums.profile_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneRequiredWithoutProfileNestedInput
    media?: mediaUpdateManyWithoutPlayerNestedInput
    boosts?: boostUpdateManyWithoutPlayerNestedInput
    strikes?: strikeUpdateManyWithoutPlayerNestedInput
    notes?: user_noteUpdateManyWithoutPlayerNestedInput
    contact_events?: contact_eventUpdateManyWithoutPlayerNestedInput
    reports_against?: reportUpdateManyWithoutProfile_targetNestedInput
    featured_assignments?: featured_assignmentUpdateManyWithoutPlayerNestedInput
  }

  export type profileUncheckedUpdateWithoutPlayer_tagsInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    display_name?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    city_slug?: NullableStringFieldUpdateOperationsInput | string | null
    contact_email?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    twitch?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    featured_media_id?: NullableStringFieldUpdateOperationsInput | string | null
    tags_count?: NullableIntFieldUpdateOperationsInput | number | null
    status?: Enumprofile_statusFieldUpdateOperationsInput | $Enums.profile_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    media?: mediaUncheckedUpdateManyWithoutPlayerNestedInput
    boosts?: boostUncheckedUpdateManyWithoutPlayerNestedInput
    strikes?: strikeUncheckedUpdateManyWithoutPlayerNestedInput
    notes?: user_noteUncheckedUpdateManyWithoutPlayerNestedInput
    contact_events?: contact_eventUncheckedUpdateManyWithoutPlayerNestedInput
    reports_against?: reportUncheckedUpdateManyWithoutProfile_targetNestedInput
    featured_assignments?: featured_assignmentUncheckedUpdateManyWithoutPlayerNestedInput
  }

  export type tagUpsertWithoutPlayer_tagsInput = {
    update: XOR<tagUpdateWithoutPlayer_tagsInput, tagUncheckedUpdateWithoutPlayer_tagsInput>
    create: XOR<tagCreateWithoutPlayer_tagsInput, tagUncheckedCreateWithoutPlayer_tagsInput>
    where?: tagWhereInput
  }

  export type tagUpdateToOneWithWhereWithoutPlayer_tagsInput = {
    where?: tagWhereInput
    data: XOR<tagUpdateWithoutPlayer_tagsInput, tagUncheckedUpdateWithoutPlayer_tagsInput>
  }

  export type tagUpdateWithoutPlayer_tagsInput = {
    slug?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    aliases?: tagUpdatealiasesInput | string[]
    status?: Enumsetting_statusFieldUpdateOperationsInput | $Enums.setting_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type tagUncheckedUpdateWithoutPlayer_tagsInput = {
    slug?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    aliases?: tagUpdatealiasesInput | string[]
    status?: Enumsetting_statusFieldUpdateOperationsInput | $Enums.setting_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type profileCreateWithoutBoostsInput = {
    id?: string
    username: string
    display_name: string
    bio?: string | null
    avatar_url?: string | null
    state: string
    city: string
    city_slug?: string | null
    contact_email?: string | null
    whatsapp?: string | null
    twitch?: string | null
    youtube?: string | null
    instagram?: string | null
    featured_media_id?: string | null
    tags_count?: number | null
    status?: $Enums.profile_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    user: userCreateNestedOneWithoutProfileInput
    media?: mediaCreateNestedManyWithoutPlayerInput
    strikes?: strikeCreateNestedManyWithoutPlayerInput
    notes?: user_noteCreateNestedManyWithoutPlayerInput
    contact_events?: contact_eventCreateNestedManyWithoutPlayerInput
    reports_against?: reportCreateNestedManyWithoutProfile_targetInput
    player_tags?: player_tagCreateNestedManyWithoutPlayerInput
    featured_assignments?: featured_assignmentCreateNestedManyWithoutPlayerInput
  }

  export type profileUncheckedCreateWithoutBoostsInput = {
    id?: string
    user_id: string
    username: string
    display_name: string
    bio?: string | null
    avatar_url?: string | null
    state: string
    city: string
    city_slug?: string | null
    contact_email?: string | null
    whatsapp?: string | null
    twitch?: string | null
    youtube?: string | null
    instagram?: string | null
    featured_media_id?: string | null
    tags_count?: number | null
    status?: $Enums.profile_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    media?: mediaUncheckedCreateNestedManyWithoutPlayerInput
    strikes?: strikeUncheckedCreateNestedManyWithoutPlayerInput
    notes?: user_noteUncheckedCreateNestedManyWithoutPlayerInput
    contact_events?: contact_eventUncheckedCreateNestedManyWithoutPlayerInput
    reports_against?: reportUncheckedCreateNestedManyWithoutProfile_targetInput
    player_tags?: player_tagUncheckedCreateNestedManyWithoutPlayerInput
    featured_assignments?: featured_assignmentUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type profileCreateOrConnectWithoutBoostsInput = {
    where: profileWhereUniqueInput
    create: XOR<profileCreateWithoutBoostsInput, profileUncheckedCreateWithoutBoostsInput>
  }

  export type profileUpsertWithoutBoostsInput = {
    update: XOR<profileUpdateWithoutBoostsInput, profileUncheckedUpdateWithoutBoostsInput>
    create: XOR<profileCreateWithoutBoostsInput, profileUncheckedCreateWithoutBoostsInput>
    where?: profileWhereInput
  }

  export type profileUpdateToOneWithWhereWithoutBoostsInput = {
    where?: profileWhereInput
    data: XOR<profileUpdateWithoutBoostsInput, profileUncheckedUpdateWithoutBoostsInput>
  }

  export type profileUpdateWithoutBoostsInput = {
    username?: StringFieldUpdateOperationsInput | string
    display_name?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    city_slug?: NullableStringFieldUpdateOperationsInput | string | null
    contact_email?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    twitch?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    featured_media_id?: NullableStringFieldUpdateOperationsInput | string | null
    tags_count?: NullableIntFieldUpdateOperationsInput | number | null
    status?: Enumprofile_statusFieldUpdateOperationsInput | $Enums.profile_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneRequiredWithoutProfileNestedInput
    media?: mediaUpdateManyWithoutPlayerNestedInput
    strikes?: strikeUpdateManyWithoutPlayerNestedInput
    notes?: user_noteUpdateManyWithoutPlayerNestedInput
    contact_events?: contact_eventUpdateManyWithoutPlayerNestedInput
    reports_against?: reportUpdateManyWithoutProfile_targetNestedInput
    player_tags?: player_tagUpdateManyWithoutPlayerNestedInput
    featured_assignments?: featured_assignmentUpdateManyWithoutPlayerNestedInput
  }

  export type profileUncheckedUpdateWithoutBoostsInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    display_name?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    city_slug?: NullableStringFieldUpdateOperationsInput | string | null
    contact_email?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    twitch?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    featured_media_id?: NullableStringFieldUpdateOperationsInput | string | null
    tags_count?: NullableIntFieldUpdateOperationsInput | number | null
    status?: Enumprofile_statusFieldUpdateOperationsInput | $Enums.profile_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    media?: mediaUncheckedUpdateManyWithoutPlayerNestedInput
    strikes?: strikeUncheckedUpdateManyWithoutPlayerNestedInput
    notes?: user_noteUncheckedUpdateManyWithoutPlayerNestedInput
    contact_events?: contact_eventUncheckedUpdateManyWithoutPlayerNestedInput
    reports_against?: reportUncheckedUpdateManyWithoutProfile_targetNestedInput
    player_tags?: player_tagUncheckedUpdateManyWithoutPlayerNestedInput
    featured_assignments?: featured_assignmentUncheckedUpdateManyWithoutPlayerNestedInput
  }

  export type mediaCreateWithoutReports_againstInput = {
    id?: string
    type: $Enums.media_type
    source?: $Enums.media_source
    url: string
    poster_url?: string | null
    blur_data_url?: string | null
    width?: number | null
    height?: number | null
    duration_sec?: number | null
    focal_point_x?: number | null
    focal_point_y?: number | null
    variants?: InputJsonValue | null
    hls_url?: string | null
    nsfw_score?: number | null
    nsfw_labels?: InputJsonValue | null
    title?: string | null
    tags_cache?: mediaCreatetags_cacheInput | string[]
    status?: $Enums.media_status
    moderation_history?: InputJsonValue | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    player: profileCreateNestedOneWithoutMediaInput
    featured_assignments?: featured_assignmentCreateNestedManyWithoutMedia_refInput
  }

  export type mediaUncheckedCreateWithoutReports_againstInput = {
    id?: string
    player_id: string
    type: $Enums.media_type
    source?: $Enums.media_source
    url: string
    poster_url?: string | null
    blur_data_url?: string | null
    width?: number | null
    height?: number | null
    duration_sec?: number | null
    focal_point_x?: number | null
    focal_point_y?: number | null
    variants?: InputJsonValue | null
    hls_url?: string | null
    nsfw_score?: number | null
    nsfw_labels?: InputJsonValue | null
    title?: string | null
    tags_cache?: mediaCreatetags_cacheInput | string[]
    status?: $Enums.media_status
    moderation_history?: InputJsonValue | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    featured_assignments?: featured_assignmentUncheckedCreateNestedManyWithoutMedia_refInput
  }

  export type mediaCreateOrConnectWithoutReports_againstInput = {
    where: mediaWhereUniqueInput
    create: XOR<mediaCreateWithoutReports_againstInput, mediaUncheckedCreateWithoutReports_againstInput>
  }

  export type profileCreateWithoutReports_againstInput = {
    id?: string
    username: string
    display_name: string
    bio?: string | null
    avatar_url?: string | null
    state: string
    city: string
    city_slug?: string | null
    contact_email?: string | null
    whatsapp?: string | null
    twitch?: string | null
    youtube?: string | null
    instagram?: string | null
    featured_media_id?: string | null
    tags_count?: number | null
    status?: $Enums.profile_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    user: userCreateNestedOneWithoutProfileInput
    media?: mediaCreateNestedManyWithoutPlayerInput
    boosts?: boostCreateNestedManyWithoutPlayerInput
    strikes?: strikeCreateNestedManyWithoutPlayerInput
    notes?: user_noteCreateNestedManyWithoutPlayerInput
    contact_events?: contact_eventCreateNestedManyWithoutPlayerInput
    player_tags?: player_tagCreateNestedManyWithoutPlayerInput
    featured_assignments?: featured_assignmentCreateNestedManyWithoutPlayerInput
  }

  export type profileUncheckedCreateWithoutReports_againstInput = {
    id?: string
    user_id: string
    username: string
    display_name: string
    bio?: string | null
    avatar_url?: string | null
    state: string
    city: string
    city_slug?: string | null
    contact_email?: string | null
    whatsapp?: string | null
    twitch?: string | null
    youtube?: string | null
    instagram?: string | null
    featured_media_id?: string | null
    tags_count?: number | null
    status?: $Enums.profile_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    media?: mediaUncheckedCreateNestedManyWithoutPlayerInput
    boosts?: boostUncheckedCreateNestedManyWithoutPlayerInput
    strikes?: strikeUncheckedCreateNestedManyWithoutPlayerInput
    notes?: user_noteUncheckedCreateNestedManyWithoutPlayerInput
    contact_events?: contact_eventUncheckedCreateNestedManyWithoutPlayerInput
    player_tags?: player_tagUncheckedCreateNestedManyWithoutPlayerInput
    featured_assignments?: featured_assignmentUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type profileCreateOrConnectWithoutReports_againstInput = {
    where: profileWhereUniqueInput
    create: XOR<profileCreateWithoutReports_againstInput, profileUncheckedCreateWithoutReports_againstInput>
  }

  export type userCreateWithoutReports_madeInput = {
    id?: string
    email: string
    password_hash: string
    role?: $Enums.user_role
    status?: $Enums.user_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    profile?: profileCreateNestedOneWithoutUserInput
    tickets?: support_ticketCreateNestedManyWithoutUserInput
    assigned_tickets?: support_ticketCreateNestedManyWithoutAssigneeInput
    notes_authored?: user_noteCreateNestedManyWithoutAuthorInput
    sessions?: sessionCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutReports_madeInput = {
    id?: string
    email: string
    password_hash: string
    role?: $Enums.user_role
    status?: $Enums.user_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    profile?: profileUncheckedCreateNestedOneWithoutUserInput
    tickets?: support_ticketUncheckedCreateNestedManyWithoutUserInput
    assigned_tickets?: support_ticketUncheckedCreateNestedManyWithoutAssigneeInput
    notes_authored?: user_noteUncheckedCreateNestedManyWithoutAuthorInput
    sessions?: sessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutReports_madeInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutReports_madeInput, userUncheckedCreateWithoutReports_madeInput>
  }

  export type mediaUpsertWithoutReports_againstInput = {
    update: XOR<mediaUpdateWithoutReports_againstInput, mediaUncheckedUpdateWithoutReports_againstInput>
    create: XOR<mediaCreateWithoutReports_againstInput, mediaUncheckedCreateWithoutReports_againstInput>
    where?: mediaWhereInput
  }

  export type mediaUpdateToOneWithWhereWithoutReports_againstInput = {
    where?: mediaWhereInput
    data: XOR<mediaUpdateWithoutReports_againstInput, mediaUncheckedUpdateWithoutReports_againstInput>
  }

  export type mediaUpdateWithoutReports_againstInput = {
    type?: Enummedia_typeFieldUpdateOperationsInput | $Enums.media_type
    source?: Enummedia_sourceFieldUpdateOperationsInput | $Enums.media_source
    url?: StringFieldUpdateOperationsInput | string
    poster_url?: NullableStringFieldUpdateOperationsInput | string | null
    blur_data_url?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    duration_sec?: NullableIntFieldUpdateOperationsInput | number | null
    focal_point_x?: NullableIntFieldUpdateOperationsInput | number | null
    focal_point_y?: NullableIntFieldUpdateOperationsInput | number | null
    variants?: InputJsonValue | InputJsonValue | null
    hls_url?: NullableStringFieldUpdateOperationsInput | string | null
    nsfw_score?: NullableFloatFieldUpdateOperationsInput | number | null
    nsfw_labels?: InputJsonValue | InputJsonValue | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    tags_cache?: mediaUpdatetags_cacheInput | string[]
    status?: Enummedia_statusFieldUpdateOperationsInput | $Enums.media_status
    moderation_history?: InputJsonValue | InputJsonValue | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    player?: profileUpdateOneRequiredWithoutMediaNestedInput
    featured_assignments?: featured_assignmentUpdateManyWithoutMedia_refNestedInput
  }

  export type mediaUncheckedUpdateWithoutReports_againstInput = {
    player_id?: StringFieldUpdateOperationsInput | string
    type?: Enummedia_typeFieldUpdateOperationsInput | $Enums.media_type
    source?: Enummedia_sourceFieldUpdateOperationsInput | $Enums.media_source
    url?: StringFieldUpdateOperationsInput | string
    poster_url?: NullableStringFieldUpdateOperationsInput | string | null
    blur_data_url?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    duration_sec?: NullableIntFieldUpdateOperationsInput | number | null
    focal_point_x?: NullableIntFieldUpdateOperationsInput | number | null
    focal_point_y?: NullableIntFieldUpdateOperationsInput | number | null
    variants?: InputJsonValue | InputJsonValue | null
    hls_url?: NullableStringFieldUpdateOperationsInput | string | null
    nsfw_score?: NullableFloatFieldUpdateOperationsInput | number | null
    nsfw_labels?: InputJsonValue | InputJsonValue | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    tags_cache?: mediaUpdatetags_cacheInput | string[]
    status?: Enummedia_statusFieldUpdateOperationsInput | $Enums.media_status
    moderation_history?: InputJsonValue | InputJsonValue | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    featured_assignments?: featured_assignmentUncheckedUpdateManyWithoutMedia_refNestedInput
  }

  export type profileUpsertWithoutReports_againstInput = {
    update: XOR<profileUpdateWithoutReports_againstInput, profileUncheckedUpdateWithoutReports_againstInput>
    create: XOR<profileCreateWithoutReports_againstInput, profileUncheckedCreateWithoutReports_againstInput>
    where?: profileWhereInput
  }

  export type profileUpdateToOneWithWhereWithoutReports_againstInput = {
    where?: profileWhereInput
    data: XOR<profileUpdateWithoutReports_againstInput, profileUncheckedUpdateWithoutReports_againstInput>
  }

  export type profileUpdateWithoutReports_againstInput = {
    username?: StringFieldUpdateOperationsInput | string
    display_name?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    city_slug?: NullableStringFieldUpdateOperationsInput | string | null
    contact_email?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    twitch?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    featured_media_id?: NullableStringFieldUpdateOperationsInput | string | null
    tags_count?: NullableIntFieldUpdateOperationsInput | number | null
    status?: Enumprofile_statusFieldUpdateOperationsInput | $Enums.profile_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneRequiredWithoutProfileNestedInput
    media?: mediaUpdateManyWithoutPlayerNestedInput
    boosts?: boostUpdateManyWithoutPlayerNestedInput
    strikes?: strikeUpdateManyWithoutPlayerNestedInput
    notes?: user_noteUpdateManyWithoutPlayerNestedInput
    contact_events?: contact_eventUpdateManyWithoutPlayerNestedInput
    player_tags?: player_tagUpdateManyWithoutPlayerNestedInput
    featured_assignments?: featured_assignmentUpdateManyWithoutPlayerNestedInput
  }

  export type profileUncheckedUpdateWithoutReports_againstInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    display_name?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    city_slug?: NullableStringFieldUpdateOperationsInput | string | null
    contact_email?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    twitch?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    featured_media_id?: NullableStringFieldUpdateOperationsInput | string | null
    tags_count?: NullableIntFieldUpdateOperationsInput | number | null
    status?: Enumprofile_statusFieldUpdateOperationsInput | $Enums.profile_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    media?: mediaUncheckedUpdateManyWithoutPlayerNestedInput
    boosts?: boostUncheckedUpdateManyWithoutPlayerNestedInput
    strikes?: strikeUncheckedUpdateManyWithoutPlayerNestedInput
    notes?: user_noteUncheckedUpdateManyWithoutPlayerNestedInput
    contact_events?: contact_eventUncheckedUpdateManyWithoutPlayerNestedInput
    player_tags?: player_tagUncheckedUpdateManyWithoutPlayerNestedInput
    featured_assignments?: featured_assignmentUncheckedUpdateManyWithoutPlayerNestedInput
  }

  export type userUpsertWithoutReports_madeInput = {
    update: XOR<userUpdateWithoutReports_madeInput, userUncheckedUpdateWithoutReports_madeInput>
    create: XOR<userCreateWithoutReports_madeInput, userUncheckedCreateWithoutReports_madeInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutReports_madeInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutReports_madeInput, userUncheckedUpdateWithoutReports_madeInput>
  }

  export type userUpdateWithoutReports_madeInput = {
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: Enumuser_roleFieldUpdateOperationsInput | $Enums.user_role
    status?: Enumuser_statusFieldUpdateOperationsInput | $Enums.user_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: profileUpdateOneWithoutUserNestedInput
    tickets?: support_ticketUpdateManyWithoutUserNestedInput
    assigned_tickets?: support_ticketUpdateManyWithoutAssigneeNestedInput
    notes_authored?: user_noteUpdateManyWithoutAuthorNestedInput
    sessions?: sessionUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutReports_madeInput = {
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: Enumuser_roleFieldUpdateOperationsInput | $Enums.user_role
    status?: Enumuser_statusFieldUpdateOperationsInput | $Enums.user_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: profileUncheckedUpdateOneWithoutUserNestedInput
    tickets?: support_ticketUncheckedUpdateManyWithoutUserNestedInput
    assigned_tickets?: support_ticketUncheckedUpdateManyWithoutAssigneeNestedInput
    notes_authored?: user_noteUncheckedUpdateManyWithoutAuthorNestedInput
    sessions?: sessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type profileCreateWithoutStrikesInput = {
    id?: string
    username: string
    display_name: string
    bio?: string | null
    avatar_url?: string | null
    state: string
    city: string
    city_slug?: string | null
    contact_email?: string | null
    whatsapp?: string | null
    twitch?: string | null
    youtube?: string | null
    instagram?: string | null
    featured_media_id?: string | null
    tags_count?: number | null
    status?: $Enums.profile_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    user: userCreateNestedOneWithoutProfileInput
    media?: mediaCreateNestedManyWithoutPlayerInput
    boosts?: boostCreateNestedManyWithoutPlayerInput
    notes?: user_noteCreateNestedManyWithoutPlayerInput
    contact_events?: contact_eventCreateNestedManyWithoutPlayerInput
    reports_against?: reportCreateNestedManyWithoutProfile_targetInput
    player_tags?: player_tagCreateNestedManyWithoutPlayerInput
    featured_assignments?: featured_assignmentCreateNestedManyWithoutPlayerInput
  }

  export type profileUncheckedCreateWithoutStrikesInput = {
    id?: string
    user_id: string
    username: string
    display_name: string
    bio?: string | null
    avatar_url?: string | null
    state: string
    city: string
    city_slug?: string | null
    contact_email?: string | null
    whatsapp?: string | null
    twitch?: string | null
    youtube?: string | null
    instagram?: string | null
    featured_media_id?: string | null
    tags_count?: number | null
    status?: $Enums.profile_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    media?: mediaUncheckedCreateNestedManyWithoutPlayerInput
    boosts?: boostUncheckedCreateNestedManyWithoutPlayerInput
    notes?: user_noteUncheckedCreateNestedManyWithoutPlayerInput
    contact_events?: contact_eventUncheckedCreateNestedManyWithoutPlayerInput
    reports_against?: reportUncheckedCreateNestedManyWithoutProfile_targetInput
    player_tags?: player_tagUncheckedCreateNestedManyWithoutPlayerInput
    featured_assignments?: featured_assignmentUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type profileCreateOrConnectWithoutStrikesInput = {
    where: profileWhereUniqueInput
    create: XOR<profileCreateWithoutStrikesInput, profileUncheckedCreateWithoutStrikesInput>
  }

  export type profileUpsertWithoutStrikesInput = {
    update: XOR<profileUpdateWithoutStrikesInput, profileUncheckedUpdateWithoutStrikesInput>
    create: XOR<profileCreateWithoutStrikesInput, profileUncheckedCreateWithoutStrikesInput>
    where?: profileWhereInput
  }

  export type profileUpdateToOneWithWhereWithoutStrikesInput = {
    where?: profileWhereInput
    data: XOR<profileUpdateWithoutStrikesInput, profileUncheckedUpdateWithoutStrikesInput>
  }

  export type profileUpdateWithoutStrikesInput = {
    username?: StringFieldUpdateOperationsInput | string
    display_name?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    city_slug?: NullableStringFieldUpdateOperationsInput | string | null
    contact_email?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    twitch?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    featured_media_id?: NullableStringFieldUpdateOperationsInput | string | null
    tags_count?: NullableIntFieldUpdateOperationsInput | number | null
    status?: Enumprofile_statusFieldUpdateOperationsInput | $Enums.profile_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneRequiredWithoutProfileNestedInput
    media?: mediaUpdateManyWithoutPlayerNestedInput
    boosts?: boostUpdateManyWithoutPlayerNestedInput
    notes?: user_noteUpdateManyWithoutPlayerNestedInput
    contact_events?: contact_eventUpdateManyWithoutPlayerNestedInput
    reports_against?: reportUpdateManyWithoutProfile_targetNestedInput
    player_tags?: player_tagUpdateManyWithoutPlayerNestedInput
    featured_assignments?: featured_assignmentUpdateManyWithoutPlayerNestedInput
  }

  export type profileUncheckedUpdateWithoutStrikesInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    display_name?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    city_slug?: NullableStringFieldUpdateOperationsInput | string | null
    contact_email?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    twitch?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    featured_media_id?: NullableStringFieldUpdateOperationsInput | string | null
    tags_count?: NullableIntFieldUpdateOperationsInput | number | null
    status?: Enumprofile_statusFieldUpdateOperationsInput | $Enums.profile_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    media?: mediaUncheckedUpdateManyWithoutPlayerNestedInput
    boosts?: boostUncheckedUpdateManyWithoutPlayerNestedInput
    notes?: user_noteUncheckedUpdateManyWithoutPlayerNestedInput
    contact_events?: contact_eventUncheckedUpdateManyWithoutPlayerNestedInput
    reports_against?: reportUncheckedUpdateManyWithoutProfile_targetNestedInput
    player_tags?: player_tagUncheckedUpdateManyWithoutPlayerNestedInput
    featured_assignments?: featured_assignmentUncheckedUpdateManyWithoutPlayerNestedInput
  }

  export type profileCreateWithoutNotesInput = {
    id?: string
    username: string
    display_name: string
    bio?: string | null
    avatar_url?: string | null
    state: string
    city: string
    city_slug?: string | null
    contact_email?: string | null
    whatsapp?: string | null
    twitch?: string | null
    youtube?: string | null
    instagram?: string | null
    featured_media_id?: string | null
    tags_count?: number | null
    status?: $Enums.profile_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    user: userCreateNestedOneWithoutProfileInput
    media?: mediaCreateNestedManyWithoutPlayerInput
    boosts?: boostCreateNestedManyWithoutPlayerInput
    strikes?: strikeCreateNestedManyWithoutPlayerInput
    contact_events?: contact_eventCreateNestedManyWithoutPlayerInput
    reports_against?: reportCreateNestedManyWithoutProfile_targetInput
    player_tags?: player_tagCreateNestedManyWithoutPlayerInput
    featured_assignments?: featured_assignmentCreateNestedManyWithoutPlayerInput
  }

  export type profileUncheckedCreateWithoutNotesInput = {
    id?: string
    user_id: string
    username: string
    display_name: string
    bio?: string | null
    avatar_url?: string | null
    state: string
    city: string
    city_slug?: string | null
    contact_email?: string | null
    whatsapp?: string | null
    twitch?: string | null
    youtube?: string | null
    instagram?: string | null
    featured_media_id?: string | null
    tags_count?: number | null
    status?: $Enums.profile_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    media?: mediaUncheckedCreateNestedManyWithoutPlayerInput
    boosts?: boostUncheckedCreateNestedManyWithoutPlayerInput
    strikes?: strikeUncheckedCreateNestedManyWithoutPlayerInput
    contact_events?: contact_eventUncheckedCreateNestedManyWithoutPlayerInput
    reports_against?: reportUncheckedCreateNestedManyWithoutProfile_targetInput
    player_tags?: player_tagUncheckedCreateNestedManyWithoutPlayerInput
    featured_assignments?: featured_assignmentUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type profileCreateOrConnectWithoutNotesInput = {
    where: profileWhereUniqueInput
    create: XOR<profileCreateWithoutNotesInput, profileUncheckedCreateWithoutNotesInput>
  }

  export type userCreateWithoutNotes_authoredInput = {
    id?: string
    email: string
    password_hash: string
    role?: $Enums.user_role
    status?: $Enums.user_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    profile?: profileCreateNestedOneWithoutUserInput
    tickets?: support_ticketCreateNestedManyWithoutUserInput
    assigned_tickets?: support_ticketCreateNestedManyWithoutAssigneeInput
    reports_made?: reportCreateNestedManyWithoutReporter_userInput
    sessions?: sessionCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutNotes_authoredInput = {
    id?: string
    email: string
    password_hash: string
    role?: $Enums.user_role
    status?: $Enums.user_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    profile?: profileUncheckedCreateNestedOneWithoutUserInput
    tickets?: support_ticketUncheckedCreateNestedManyWithoutUserInput
    assigned_tickets?: support_ticketUncheckedCreateNestedManyWithoutAssigneeInput
    reports_made?: reportUncheckedCreateNestedManyWithoutReporter_userInput
    sessions?: sessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutNotes_authoredInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutNotes_authoredInput, userUncheckedCreateWithoutNotes_authoredInput>
  }

  export type profileUpsertWithoutNotesInput = {
    update: XOR<profileUpdateWithoutNotesInput, profileUncheckedUpdateWithoutNotesInput>
    create: XOR<profileCreateWithoutNotesInput, profileUncheckedCreateWithoutNotesInput>
    where?: profileWhereInput
  }

  export type profileUpdateToOneWithWhereWithoutNotesInput = {
    where?: profileWhereInput
    data: XOR<profileUpdateWithoutNotesInput, profileUncheckedUpdateWithoutNotesInput>
  }

  export type profileUpdateWithoutNotesInput = {
    username?: StringFieldUpdateOperationsInput | string
    display_name?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    city_slug?: NullableStringFieldUpdateOperationsInput | string | null
    contact_email?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    twitch?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    featured_media_id?: NullableStringFieldUpdateOperationsInput | string | null
    tags_count?: NullableIntFieldUpdateOperationsInput | number | null
    status?: Enumprofile_statusFieldUpdateOperationsInput | $Enums.profile_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneRequiredWithoutProfileNestedInput
    media?: mediaUpdateManyWithoutPlayerNestedInput
    boosts?: boostUpdateManyWithoutPlayerNestedInput
    strikes?: strikeUpdateManyWithoutPlayerNestedInput
    contact_events?: contact_eventUpdateManyWithoutPlayerNestedInput
    reports_against?: reportUpdateManyWithoutProfile_targetNestedInput
    player_tags?: player_tagUpdateManyWithoutPlayerNestedInput
    featured_assignments?: featured_assignmentUpdateManyWithoutPlayerNestedInput
  }

  export type profileUncheckedUpdateWithoutNotesInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    display_name?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    city_slug?: NullableStringFieldUpdateOperationsInput | string | null
    contact_email?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    twitch?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    featured_media_id?: NullableStringFieldUpdateOperationsInput | string | null
    tags_count?: NullableIntFieldUpdateOperationsInput | number | null
    status?: Enumprofile_statusFieldUpdateOperationsInput | $Enums.profile_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    media?: mediaUncheckedUpdateManyWithoutPlayerNestedInput
    boosts?: boostUncheckedUpdateManyWithoutPlayerNestedInput
    strikes?: strikeUncheckedUpdateManyWithoutPlayerNestedInput
    contact_events?: contact_eventUncheckedUpdateManyWithoutPlayerNestedInput
    reports_against?: reportUncheckedUpdateManyWithoutProfile_targetNestedInput
    player_tags?: player_tagUncheckedUpdateManyWithoutPlayerNestedInput
    featured_assignments?: featured_assignmentUncheckedUpdateManyWithoutPlayerNestedInput
  }

  export type userUpsertWithoutNotes_authoredInput = {
    update: XOR<userUpdateWithoutNotes_authoredInput, userUncheckedUpdateWithoutNotes_authoredInput>
    create: XOR<userCreateWithoutNotes_authoredInput, userUncheckedCreateWithoutNotes_authoredInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutNotes_authoredInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutNotes_authoredInput, userUncheckedUpdateWithoutNotes_authoredInput>
  }

  export type userUpdateWithoutNotes_authoredInput = {
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: Enumuser_roleFieldUpdateOperationsInput | $Enums.user_role
    status?: Enumuser_statusFieldUpdateOperationsInput | $Enums.user_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: profileUpdateOneWithoutUserNestedInput
    tickets?: support_ticketUpdateManyWithoutUserNestedInput
    assigned_tickets?: support_ticketUpdateManyWithoutAssigneeNestedInput
    reports_made?: reportUpdateManyWithoutReporter_userNestedInput
    sessions?: sessionUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutNotes_authoredInput = {
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: Enumuser_roleFieldUpdateOperationsInput | $Enums.user_role
    status?: Enumuser_statusFieldUpdateOperationsInput | $Enums.user_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: profileUncheckedUpdateOneWithoutUserNestedInput
    tickets?: support_ticketUncheckedUpdateManyWithoutUserNestedInput
    assigned_tickets?: support_ticketUncheckedUpdateManyWithoutAssigneeNestedInput
    reports_made?: reportUncheckedUpdateManyWithoutReporter_userNestedInput
    sessions?: sessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type profileCreateWithoutFeatured_assignmentsInput = {
    id?: string
    username: string
    display_name: string
    bio?: string | null
    avatar_url?: string | null
    state: string
    city: string
    city_slug?: string | null
    contact_email?: string | null
    whatsapp?: string | null
    twitch?: string | null
    youtube?: string | null
    instagram?: string | null
    featured_media_id?: string | null
    tags_count?: number | null
    status?: $Enums.profile_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    user: userCreateNestedOneWithoutProfileInput
    media?: mediaCreateNestedManyWithoutPlayerInput
    boosts?: boostCreateNestedManyWithoutPlayerInput
    strikes?: strikeCreateNestedManyWithoutPlayerInput
    notes?: user_noteCreateNestedManyWithoutPlayerInput
    contact_events?: contact_eventCreateNestedManyWithoutPlayerInput
    reports_against?: reportCreateNestedManyWithoutProfile_targetInput
    player_tags?: player_tagCreateNestedManyWithoutPlayerInput
  }

  export type profileUncheckedCreateWithoutFeatured_assignmentsInput = {
    id?: string
    user_id: string
    username: string
    display_name: string
    bio?: string | null
    avatar_url?: string | null
    state: string
    city: string
    city_slug?: string | null
    contact_email?: string | null
    whatsapp?: string | null
    twitch?: string | null
    youtube?: string | null
    instagram?: string | null
    featured_media_id?: string | null
    tags_count?: number | null
    status?: $Enums.profile_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    media?: mediaUncheckedCreateNestedManyWithoutPlayerInput
    boosts?: boostUncheckedCreateNestedManyWithoutPlayerInput
    strikes?: strikeUncheckedCreateNestedManyWithoutPlayerInput
    notes?: user_noteUncheckedCreateNestedManyWithoutPlayerInput
    contact_events?: contact_eventUncheckedCreateNestedManyWithoutPlayerInput
    reports_against?: reportUncheckedCreateNestedManyWithoutProfile_targetInput
    player_tags?: player_tagUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type profileCreateOrConnectWithoutFeatured_assignmentsInput = {
    where: profileWhereUniqueInput
    create: XOR<profileCreateWithoutFeatured_assignmentsInput, profileUncheckedCreateWithoutFeatured_assignmentsInput>
  }

  export type mediaCreateWithoutFeatured_assignmentsInput = {
    id?: string
    type: $Enums.media_type
    source?: $Enums.media_source
    url: string
    poster_url?: string | null
    blur_data_url?: string | null
    width?: number | null
    height?: number | null
    duration_sec?: number | null
    focal_point_x?: number | null
    focal_point_y?: number | null
    variants?: InputJsonValue | null
    hls_url?: string | null
    nsfw_score?: number | null
    nsfw_labels?: InputJsonValue | null
    title?: string | null
    tags_cache?: mediaCreatetags_cacheInput | string[]
    status?: $Enums.media_status
    moderation_history?: InputJsonValue | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    player: profileCreateNestedOneWithoutMediaInput
    reports_against?: reportCreateNestedManyWithoutMedia_targetInput
  }

  export type mediaUncheckedCreateWithoutFeatured_assignmentsInput = {
    id?: string
    player_id: string
    type: $Enums.media_type
    source?: $Enums.media_source
    url: string
    poster_url?: string | null
    blur_data_url?: string | null
    width?: number | null
    height?: number | null
    duration_sec?: number | null
    focal_point_x?: number | null
    focal_point_y?: number | null
    variants?: InputJsonValue | null
    hls_url?: string | null
    nsfw_score?: number | null
    nsfw_labels?: InputJsonValue | null
    title?: string | null
    tags_cache?: mediaCreatetags_cacheInput | string[]
    status?: $Enums.media_status
    moderation_history?: InputJsonValue | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    reports_against?: reportUncheckedCreateNestedManyWithoutMedia_targetInput
  }

  export type mediaCreateOrConnectWithoutFeatured_assignmentsInput = {
    where: mediaWhereUniqueInput
    create: XOR<mediaCreateWithoutFeatured_assignmentsInput, mediaUncheckedCreateWithoutFeatured_assignmentsInput>
  }

  export type profileUpsertWithoutFeatured_assignmentsInput = {
    update: XOR<profileUpdateWithoutFeatured_assignmentsInput, profileUncheckedUpdateWithoutFeatured_assignmentsInput>
    create: XOR<profileCreateWithoutFeatured_assignmentsInput, profileUncheckedCreateWithoutFeatured_assignmentsInput>
    where?: profileWhereInput
  }

  export type profileUpdateToOneWithWhereWithoutFeatured_assignmentsInput = {
    where?: profileWhereInput
    data: XOR<profileUpdateWithoutFeatured_assignmentsInput, profileUncheckedUpdateWithoutFeatured_assignmentsInput>
  }

  export type profileUpdateWithoutFeatured_assignmentsInput = {
    username?: StringFieldUpdateOperationsInput | string
    display_name?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    city_slug?: NullableStringFieldUpdateOperationsInput | string | null
    contact_email?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    twitch?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    featured_media_id?: NullableStringFieldUpdateOperationsInput | string | null
    tags_count?: NullableIntFieldUpdateOperationsInput | number | null
    status?: Enumprofile_statusFieldUpdateOperationsInput | $Enums.profile_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneRequiredWithoutProfileNestedInput
    media?: mediaUpdateManyWithoutPlayerNestedInput
    boosts?: boostUpdateManyWithoutPlayerNestedInput
    strikes?: strikeUpdateManyWithoutPlayerNestedInput
    notes?: user_noteUpdateManyWithoutPlayerNestedInput
    contact_events?: contact_eventUpdateManyWithoutPlayerNestedInput
    reports_against?: reportUpdateManyWithoutProfile_targetNestedInput
    player_tags?: player_tagUpdateManyWithoutPlayerNestedInput
  }

  export type profileUncheckedUpdateWithoutFeatured_assignmentsInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    display_name?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    city_slug?: NullableStringFieldUpdateOperationsInput | string | null
    contact_email?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    twitch?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    featured_media_id?: NullableStringFieldUpdateOperationsInput | string | null
    tags_count?: NullableIntFieldUpdateOperationsInput | number | null
    status?: Enumprofile_statusFieldUpdateOperationsInput | $Enums.profile_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    media?: mediaUncheckedUpdateManyWithoutPlayerNestedInput
    boosts?: boostUncheckedUpdateManyWithoutPlayerNestedInput
    strikes?: strikeUncheckedUpdateManyWithoutPlayerNestedInput
    notes?: user_noteUncheckedUpdateManyWithoutPlayerNestedInput
    contact_events?: contact_eventUncheckedUpdateManyWithoutPlayerNestedInput
    reports_against?: reportUncheckedUpdateManyWithoutProfile_targetNestedInput
    player_tags?: player_tagUncheckedUpdateManyWithoutPlayerNestedInput
  }

  export type mediaUpsertWithoutFeatured_assignmentsInput = {
    update: XOR<mediaUpdateWithoutFeatured_assignmentsInput, mediaUncheckedUpdateWithoutFeatured_assignmentsInput>
    create: XOR<mediaCreateWithoutFeatured_assignmentsInput, mediaUncheckedCreateWithoutFeatured_assignmentsInput>
    where?: mediaWhereInput
  }

  export type mediaUpdateToOneWithWhereWithoutFeatured_assignmentsInput = {
    where?: mediaWhereInput
    data: XOR<mediaUpdateWithoutFeatured_assignmentsInput, mediaUncheckedUpdateWithoutFeatured_assignmentsInput>
  }

  export type mediaUpdateWithoutFeatured_assignmentsInput = {
    type?: Enummedia_typeFieldUpdateOperationsInput | $Enums.media_type
    source?: Enummedia_sourceFieldUpdateOperationsInput | $Enums.media_source
    url?: StringFieldUpdateOperationsInput | string
    poster_url?: NullableStringFieldUpdateOperationsInput | string | null
    blur_data_url?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    duration_sec?: NullableIntFieldUpdateOperationsInput | number | null
    focal_point_x?: NullableIntFieldUpdateOperationsInput | number | null
    focal_point_y?: NullableIntFieldUpdateOperationsInput | number | null
    variants?: InputJsonValue | InputJsonValue | null
    hls_url?: NullableStringFieldUpdateOperationsInput | string | null
    nsfw_score?: NullableFloatFieldUpdateOperationsInput | number | null
    nsfw_labels?: InputJsonValue | InputJsonValue | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    tags_cache?: mediaUpdatetags_cacheInput | string[]
    status?: Enummedia_statusFieldUpdateOperationsInput | $Enums.media_status
    moderation_history?: InputJsonValue | InputJsonValue | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    player?: profileUpdateOneRequiredWithoutMediaNestedInput
    reports_against?: reportUpdateManyWithoutMedia_targetNestedInput
  }

  export type mediaUncheckedUpdateWithoutFeatured_assignmentsInput = {
    player_id?: StringFieldUpdateOperationsInput | string
    type?: Enummedia_typeFieldUpdateOperationsInput | $Enums.media_type
    source?: Enummedia_sourceFieldUpdateOperationsInput | $Enums.media_source
    url?: StringFieldUpdateOperationsInput | string
    poster_url?: NullableStringFieldUpdateOperationsInput | string | null
    blur_data_url?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    duration_sec?: NullableIntFieldUpdateOperationsInput | number | null
    focal_point_x?: NullableIntFieldUpdateOperationsInput | number | null
    focal_point_y?: NullableIntFieldUpdateOperationsInput | number | null
    variants?: InputJsonValue | InputJsonValue | null
    hls_url?: NullableStringFieldUpdateOperationsInput | string | null
    nsfw_score?: NullableFloatFieldUpdateOperationsInput | number | null
    nsfw_labels?: InputJsonValue | InputJsonValue | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    tags_cache?: mediaUpdatetags_cacheInput | string[]
    status?: Enummedia_statusFieldUpdateOperationsInput | $Enums.media_status
    moderation_history?: InputJsonValue | InputJsonValue | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reports_against?: reportUncheckedUpdateManyWithoutMedia_targetNestedInput
  }

  export type userCreateWithoutTicketsInput = {
    id?: string
    email: string
    password_hash: string
    role?: $Enums.user_role
    status?: $Enums.user_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    profile?: profileCreateNestedOneWithoutUserInput
    assigned_tickets?: support_ticketCreateNestedManyWithoutAssigneeInput
    reports_made?: reportCreateNestedManyWithoutReporter_userInput
    notes_authored?: user_noteCreateNestedManyWithoutAuthorInput
    sessions?: sessionCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutTicketsInput = {
    id?: string
    email: string
    password_hash: string
    role?: $Enums.user_role
    status?: $Enums.user_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    profile?: profileUncheckedCreateNestedOneWithoutUserInput
    assigned_tickets?: support_ticketUncheckedCreateNestedManyWithoutAssigneeInput
    reports_made?: reportUncheckedCreateNestedManyWithoutReporter_userInput
    notes_authored?: user_noteUncheckedCreateNestedManyWithoutAuthorInput
    sessions?: sessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutTicketsInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutTicketsInput, userUncheckedCreateWithoutTicketsInput>
  }

  export type userCreateWithoutAssigned_ticketsInput = {
    id?: string
    email: string
    password_hash: string
    role?: $Enums.user_role
    status?: $Enums.user_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    profile?: profileCreateNestedOneWithoutUserInput
    tickets?: support_ticketCreateNestedManyWithoutUserInput
    reports_made?: reportCreateNestedManyWithoutReporter_userInput
    notes_authored?: user_noteCreateNestedManyWithoutAuthorInput
    sessions?: sessionCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutAssigned_ticketsInput = {
    id?: string
    email: string
    password_hash: string
    role?: $Enums.user_role
    status?: $Enums.user_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    profile?: profileUncheckedCreateNestedOneWithoutUserInput
    tickets?: support_ticketUncheckedCreateNestedManyWithoutUserInput
    reports_made?: reportUncheckedCreateNestedManyWithoutReporter_userInput
    notes_authored?: user_noteUncheckedCreateNestedManyWithoutAuthorInput
    sessions?: sessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutAssigned_ticketsInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutAssigned_ticketsInput, userUncheckedCreateWithoutAssigned_ticketsInput>
  }

  export type userUpsertWithoutTicketsInput = {
    update: XOR<userUpdateWithoutTicketsInput, userUncheckedUpdateWithoutTicketsInput>
    create: XOR<userCreateWithoutTicketsInput, userUncheckedCreateWithoutTicketsInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutTicketsInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutTicketsInput, userUncheckedUpdateWithoutTicketsInput>
  }

  export type userUpdateWithoutTicketsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: Enumuser_roleFieldUpdateOperationsInput | $Enums.user_role
    status?: Enumuser_statusFieldUpdateOperationsInput | $Enums.user_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: profileUpdateOneWithoutUserNestedInput
    assigned_tickets?: support_ticketUpdateManyWithoutAssigneeNestedInput
    reports_made?: reportUpdateManyWithoutReporter_userNestedInput
    notes_authored?: user_noteUpdateManyWithoutAuthorNestedInput
    sessions?: sessionUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutTicketsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: Enumuser_roleFieldUpdateOperationsInput | $Enums.user_role
    status?: Enumuser_statusFieldUpdateOperationsInput | $Enums.user_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: profileUncheckedUpdateOneWithoutUserNestedInput
    assigned_tickets?: support_ticketUncheckedUpdateManyWithoutAssigneeNestedInput
    reports_made?: reportUncheckedUpdateManyWithoutReporter_userNestedInput
    notes_authored?: user_noteUncheckedUpdateManyWithoutAuthorNestedInput
    sessions?: sessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userUpsertWithoutAssigned_ticketsInput = {
    update: XOR<userUpdateWithoutAssigned_ticketsInput, userUncheckedUpdateWithoutAssigned_ticketsInput>
    create: XOR<userCreateWithoutAssigned_ticketsInput, userUncheckedCreateWithoutAssigned_ticketsInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutAssigned_ticketsInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutAssigned_ticketsInput, userUncheckedUpdateWithoutAssigned_ticketsInput>
  }

  export type userUpdateWithoutAssigned_ticketsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: Enumuser_roleFieldUpdateOperationsInput | $Enums.user_role
    status?: Enumuser_statusFieldUpdateOperationsInput | $Enums.user_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: profileUpdateOneWithoutUserNestedInput
    tickets?: support_ticketUpdateManyWithoutUserNestedInput
    reports_made?: reportUpdateManyWithoutReporter_userNestedInput
    notes_authored?: user_noteUpdateManyWithoutAuthorNestedInput
    sessions?: sessionUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutAssigned_ticketsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: Enumuser_roleFieldUpdateOperationsInput | $Enums.user_role
    status?: Enumuser_statusFieldUpdateOperationsInput | $Enums.user_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: profileUncheckedUpdateOneWithoutUserNestedInput
    tickets?: support_ticketUncheckedUpdateManyWithoutUserNestedInput
    reports_made?: reportUncheckedUpdateManyWithoutReporter_userNestedInput
    notes_authored?: user_noteUncheckedUpdateManyWithoutAuthorNestedInput
    sessions?: sessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type profileCreateWithoutContact_eventsInput = {
    id?: string
    username: string
    display_name: string
    bio?: string | null
    avatar_url?: string | null
    state: string
    city: string
    city_slug?: string | null
    contact_email?: string | null
    whatsapp?: string | null
    twitch?: string | null
    youtube?: string | null
    instagram?: string | null
    featured_media_id?: string | null
    tags_count?: number | null
    status?: $Enums.profile_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    user: userCreateNestedOneWithoutProfileInput
    media?: mediaCreateNestedManyWithoutPlayerInput
    boosts?: boostCreateNestedManyWithoutPlayerInput
    strikes?: strikeCreateNestedManyWithoutPlayerInput
    notes?: user_noteCreateNestedManyWithoutPlayerInput
    reports_against?: reportCreateNestedManyWithoutProfile_targetInput
    player_tags?: player_tagCreateNestedManyWithoutPlayerInput
    featured_assignments?: featured_assignmentCreateNestedManyWithoutPlayerInput
  }

  export type profileUncheckedCreateWithoutContact_eventsInput = {
    id?: string
    user_id: string
    username: string
    display_name: string
    bio?: string | null
    avatar_url?: string | null
    state: string
    city: string
    city_slug?: string | null
    contact_email?: string | null
    whatsapp?: string | null
    twitch?: string | null
    youtube?: string | null
    instagram?: string | null
    featured_media_id?: string | null
    tags_count?: number | null
    status?: $Enums.profile_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    media?: mediaUncheckedCreateNestedManyWithoutPlayerInput
    boosts?: boostUncheckedCreateNestedManyWithoutPlayerInput
    strikes?: strikeUncheckedCreateNestedManyWithoutPlayerInput
    notes?: user_noteUncheckedCreateNestedManyWithoutPlayerInput
    reports_against?: reportUncheckedCreateNestedManyWithoutProfile_targetInput
    player_tags?: player_tagUncheckedCreateNestedManyWithoutPlayerInput
    featured_assignments?: featured_assignmentUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type profileCreateOrConnectWithoutContact_eventsInput = {
    where: profileWhereUniqueInput
    create: XOR<profileCreateWithoutContact_eventsInput, profileUncheckedCreateWithoutContact_eventsInput>
  }

  export type profileUpsertWithoutContact_eventsInput = {
    update: XOR<profileUpdateWithoutContact_eventsInput, profileUncheckedUpdateWithoutContact_eventsInput>
    create: XOR<profileCreateWithoutContact_eventsInput, profileUncheckedCreateWithoutContact_eventsInput>
    where?: profileWhereInput
  }

  export type profileUpdateToOneWithWhereWithoutContact_eventsInput = {
    where?: profileWhereInput
    data: XOR<profileUpdateWithoutContact_eventsInput, profileUncheckedUpdateWithoutContact_eventsInput>
  }

  export type profileUpdateWithoutContact_eventsInput = {
    username?: StringFieldUpdateOperationsInput | string
    display_name?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    city_slug?: NullableStringFieldUpdateOperationsInput | string | null
    contact_email?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    twitch?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    featured_media_id?: NullableStringFieldUpdateOperationsInput | string | null
    tags_count?: NullableIntFieldUpdateOperationsInput | number | null
    status?: Enumprofile_statusFieldUpdateOperationsInput | $Enums.profile_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneRequiredWithoutProfileNestedInput
    media?: mediaUpdateManyWithoutPlayerNestedInput
    boosts?: boostUpdateManyWithoutPlayerNestedInput
    strikes?: strikeUpdateManyWithoutPlayerNestedInput
    notes?: user_noteUpdateManyWithoutPlayerNestedInput
    reports_against?: reportUpdateManyWithoutProfile_targetNestedInput
    player_tags?: player_tagUpdateManyWithoutPlayerNestedInput
    featured_assignments?: featured_assignmentUpdateManyWithoutPlayerNestedInput
  }

  export type profileUncheckedUpdateWithoutContact_eventsInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    display_name?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    city_slug?: NullableStringFieldUpdateOperationsInput | string | null
    contact_email?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    twitch?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    featured_media_id?: NullableStringFieldUpdateOperationsInput | string | null
    tags_count?: NullableIntFieldUpdateOperationsInput | number | null
    status?: Enumprofile_statusFieldUpdateOperationsInput | $Enums.profile_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    media?: mediaUncheckedUpdateManyWithoutPlayerNestedInput
    boosts?: boostUncheckedUpdateManyWithoutPlayerNestedInput
    strikes?: strikeUncheckedUpdateManyWithoutPlayerNestedInput
    notes?: user_noteUncheckedUpdateManyWithoutPlayerNestedInput
    reports_against?: reportUncheckedUpdateManyWithoutProfile_targetNestedInput
    player_tags?: player_tagUncheckedUpdateManyWithoutPlayerNestedInput
    featured_assignments?: featured_assignmentUncheckedUpdateManyWithoutPlayerNestedInput
  }

  export type userCreateWithoutSessionsInput = {
    id?: string
    email: string
    password_hash: string
    role?: $Enums.user_role
    status?: $Enums.user_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    profile?: profileCreateNestedOneWithoutUserInput
    tickets?: support_ticketCreateNestedManyWithoutUserInput
    assigned_tickets?: support_ticketCreateNestedManyWithoutAssigneeInput
    reports_made?: reportCreateNestedManyWithoutReporter_userInput
    notes_authored?: user_noteCreateNestedManyWithoutAuthorInput
  }

  export type userUncheckedCreateWithoutSessionsInput = {
    id?: string
    email: string
    password_hash: string
    role?: $Enums.user_role
    status?: $Enums.user_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    profile?: profileUncheckedCreateNestedOneWithoutUserInput
    tickets?: support_ticketUncheckedCreateNestedManyWithoutUserInput
    assigned_tickets?: support_ticketUncheckedCreateNestedManyWithoutAssigneeInput
    reports_made?: reportUncheckedCreateNestedManyWithoutReporter_userInput
    notes_authored?: user_noteUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type userCreateOrConnectWithoutSessionsInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutSessionsInput, userUncheckedCreateWithoutSessionsInput>
  }

  export type userUpsertWithoutSessionsInput = {
    update: XOR<userUpdateWithoutSessionsInput, userUncheckedUpdateWithoutSessionsInput>
    create: XOR<userCreateWithoutSessionsInput, userUncheckedCreateWithoutSessionsInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutSessionsInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutSessionsInput, userUncheckedUpdateWithoutSessionsInput>
  }

  export type userUpdateWithoutSessionsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: Enumuser_roleFieldUpdateOperationsInput | $Enums.user_role
    status?: Enumuser_statusFieldUpdateOperationsInput | $Enums.user_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: profileUpdateOneWithoutUserNestedInput
    tickets?: support_ticketUpdateManyWithoutUserNestedInput
    assigned_tickets?: support_ticketUpdateManyWithoutAssigneeNestedInput
    reports_made?: reportUpdateManyWithoutReporter_userNestedInput
    notes_authored?: user_noteUpdateManyWithoutAuthorNestedInput
  }

  export type userUncheckedUpdateWithoutSessionsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: Enumuser_roleFieldUpdateOperationsInput | $Enums.user_role
    status?: Enumuser_statusFieldUpdateOperationsInput | $Enums.user_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: profileUncheckedUpdateOneWithoutUserNestedInput
    tickets?: support_ticketUncheckedUpdateManyWithoutUserNestedInput
    assigned_tickets?: support_ticketUncheckedUpdateManyWithoutAssigneeNestedInput
    reports_made?: reportUncheckedUpdateManyWithoutReporter_userNestedInput
    notes_authored?: user_noteUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type support_ticketCreateManyUserInput = {
    id?: string
    email?: string | null
    subject: string
    message: string
    priority?: $Enums.ticket_priority
    status?: $Enums.ticket_status
    assigned_to?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type support_ticketCreateManyAssigneeInput = {
    id?: string
    user_id?: string | null
    email?: string | null
    subject: string
    message: string
    priority?: $Enums.ticket_priority
    status?: $Enums.ticket_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type reportCreateManyReporter_userInput = {
    id?: string
    target_type: string
    target_id: string
    reason: $Enums.report_reason
    details?: string | null
    severity?: $Enums.severity_level
    status?: $Enums.report_status
    resolution_note?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type user_noteCreateManyAuthorInput = {
    id?: string
    player_id: string
    note: string
    status?: $Enums.setting_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type sessionCreateManyUserInput = {
    id?: string
    session_token: string
    ip?: string | null
    user_agent?: string | null
    expires_at: Date | string
    status?: $Enums.setting_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type support_ticketUpdateWithoutUserInput = {
    email?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    priority?: Enumticket_priorityFieldUpdateOperationsInput | $Enums.ticket_priority
    status?: Enumticket_statusFieldUpdateOperationsInput | $Enums.ticket_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignee?: userUpdateOneWithoutAssigned_ticketsNestedInput
  }

  export type support_ticketUncheckedUpdateWithoutUserInput = {
    email?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    priority?: Enumticket_priorityFieldUpdateOperationsInput | $Enums.ticket_priority
    status?: Enumticket_statusFieldUpdateOperationsInput | $Enums.ticket_status
    assigned_to?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type support_ticketUncheckedUpdateManyWithoutUserInput = {
    email?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    priority?: Enumticket_priorityFieldUpdateOperationsInput | $Enums.ticket_priority
    status?: Enumticket_statusFieldUpdateOperationsInput | $Enums.ticket_status
    assigned_to?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type support_ticketUpdateWithoutAssigneeInput = {
    email?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    priority?: Enumticket_priorityFieldUpdateOperationsInput | $Enums.ticket_priority
    status?: Enumticket_statusFieldUpdateOperationsInput | $Enums.ticket_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneWithoutTicketsNestedInput
  }

  export type support_ticketUncheckedUpdateWithoutAssigneeInput = {
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    priority?: Enumticket_priorityFieldUpdateOperationsInput | $Enums.ticket_priority
    status?: Enumticket_statusFieldUpdateOperationsInput | $Enums.ticket_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type support_ticketUncheckedUpdateManyWithoutAssigneeInput = {
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    priority?: Enumticket_priorityFieldUpdateOperationsInput | $Enums.ticket_priority
    status?: Enumticket_statusFieldUpdateOperationsInput | $Enums.ticket_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type reportUpdateWithoutReporter_userInput = {
    target_type?: StringFieldUpdateOperationsInput | string
    reason?: Enumreport_reasonFieldUpdateOperationsInput | $Enums.report_reason
    details?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: Enumseverity_levelFieldUpdateOperationsInput | $Enums.severity_level
    status?: Enumreport_statusFieldUpdateOperationsInput | $Enums.report_status
    resolution_note?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    media_target?: mediaUpdateOneWithoutReports_againstNestedInput
    profile_target?: profileUpdateOneWithoutReports_againstNestedInput
  }

  export type reportUncheckedUpdateWithoutReporter_userInput = {
    target_type?: StringFieldUpdateOperationsInput | string
    target_id?: StringFieldUpdateOperationsInput | string
    reason?: Enumreport_reasonFieldUpdateOperationsInput | $Enums.report_reason
    details?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: Enumseverity_levelFieldUpdateOperationsInput | $Enums.severity_level
    status?: Enumreport_statusFieldUpdateOperationsInput | $Enums.report_status
    resolution_note?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type reportUncheckedUpdateManyWithoutReporter_userInput = {
    target_type?: StringFieldUpdateOperationsInput | string
    target_id?: StringFieldUpdateOperationsInput | string
    reason?: Enumreport_reasonFieldUpdateOperationsInput | $Enums.report_reason
    details?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: Enumseverity_levelFieldUpdateOperationsInput | $Enums.severity_level
    status?: Enumreport_statusFieldUpdateOperationsInput | $Enums.report_status
    resolution_note?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type user_noteUpdateWithoutAuthorInput = {
    note?: StringFieldUpdateOperationsInput | string
    status?: Enumsetting_statusFieldUpdateOperationsInput | $Enums.setting_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    player?: profileUpdateOneRequiredWithoutNotesNestedInput
  }

  export type user_noteUncheckedUpdateWithoutAuthorInput = {
    player_id?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    status?: Enumsetting_statusFieldUpdateOperationsInput | $Enums.setting_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type user_noteUncheckedUpdateManyWithoutAuthorInput = {
    player_id?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    status?: Enumsetting_statusFieldUpdateOperationsInput | $Enums.setting_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type sessionUpdateWithoutUserInput = {
    session_token?: StringFieldUpdateOperationsInput | string
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enumsetting_statusFieldUpdateOperationsInput | $Enums.setting_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type sessionUncheckedUpdateWithoutUserInput = {
    session_token?: StringFieldUpdateOperationsInput | string
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enumsetting_statusFieldUpdateOperationsInput | $Enums.setting_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type sessionUncheckedUpdateManyWithoutUserInput = {
    session_token?: StringFieldUpdateOperationsInput | string
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enumsetting_statusFieldUpdateOperationsInput | $Enums.setting_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type mediaCreateManyPlayerInput = {
    id?: string
    type: $Enums.media_type
    source?: $Enums.media_source
    url: string
    poster_url?: string | null
    blur_data_url?: string | null
    width?: number | null
    height?: number | null
    duration_sec?: number | null
    focal_point_x?: number | null
    focal_point_y?: number | null
    variants?: InputJsonValue | null
    hls_url?: string | null
    nsfw_score?: number | null
    nsfw_labels?: InputJsonValue | null
    title?: string | null
    tags_cache?: mediaCreatetags_cacheInput | string[]
    status?: $Enums.media_status
    moderation_history?: InputJsonValue | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type boostCreateManyPlayerInput = {
    id?: string
    status?: $Enums.boost_status
    starts_at: Date | string
    ends_at: Date | string
    provider?: $Enums.provider_kind
    external_id?: string | null
    amount_cents: number
    currency?: string
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type strikeCreateManyPlayerInput = {
    id?: string
    reason: string
    severity?: $Enums.severity_level
    expires_at?: Date | string | null
    status?: $Enums.setting_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type user_noteCreateManyPlayerInput = {
    id?: string
    author_id: string
    note: string
    status?: $Enums.setting_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type contact_eventCreateManyPlayerInput = {
    id?: string
    channel: $Enums.contact_channel
    requester_ip?: string | null
    user_agent?: string | null
    referrer?: string | null
    message?: string | null
    status?: $Enums.setting_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type reportCreateManyProfile_targetInput = {
    id?: string
    reporter_user_id?: string | null
    target_type: string
    reason: $Enums.report_reason
    details?: string | null
    severity?: $Enums.severity_level
    status?: $Enums.report_status
    resolution_note?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type player_tagCreateManyPlayerInput = {
    id?: string
    tag_id: string
    status?: $Enums.setting_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type featured_assignmentCreateManyPlayerInput = {
    id?: string
    slot_key: $Enums.feature_slot_key
    media_id?: string | null
    starts_at: Date | string
    ends_at: Date | string
    priority?: number
    status?: $Enums.setting_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type mediaUpdateWithoutPlayerInput = {
    type?: Enummedia_typeFieldUpdateOperationsInput | $Enums.media_type
    source?: Enummedia_sourceFieldUpdateOperationsInput | $Enums.media_source
    url?: StringFieldUpdateOperationsInput | string
    poster_url?: NullableStringFieldUpdateOperationsInput | string | null
    blur_data_url?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    duration_sec?: NullableIntFieldUpdateOperationsInput | number | null
    focal_point_x?: NullableIntFieldUpdateOperationsInput | number | null
    focal_point_y?: NullableIntFieldUpdateOperationsInput | number | null
    variants?: InputJsonValue | InputJsonValue | null
    hls_url?: NullableStringFieldUpdateOperationsInput | string | null
    nsfw_score?: NullableFloatFieldUpdateOperationsInput | number | null
    nsfw_labels?: InputJsonValue | InputJsonValue | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    tags_cache?: mediaUpdatetags_cacheInput | string[]
    status?: Enummedia_statusFieldUpdateOperationsInput | $Enums.media_status
    moderation_history?: InputJsonValue | InputJsonValue | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reports_against?: reportUpdateManyWithoutMedia_targetNestedInput
    featured_assignments?: featured_assignmentUpdateManyWithoutMedia_refNestedInput
  }

  export type mediaUncheckedUpdateWithoutPlayerInput = {
    type?: Enummedia_typeFieldUpdateOperationsInput | $Enums.media_type
    source?: Enummedia_sourceFieldUpdateOperationsInput | $Enums.media_source
    url?: StringFieldUpdateOperationsInput | string
    poster_url?: NullableStringFieldUpdateOperationsInput | string | null
    blur_data_url?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    duration_sec?: NullableIntFieldUpdateOperationsInput | number | null
    focal_point_x?: NullableIntFieldUpdateOperationsInput | number | null
    focal_point_y?: NullableIntFieldUpdateOperationsInput | number | null
    variants?: InputJsonValue | InputJsonValue | null
    hls_url?: NullableStringFieldUpdateOperationsInput | string | null
    nsfw_score?: NullableFloatFieldUpdateOperationsInput | number | null
    nsfw_labels?: InputJsonValue | InputJsonValue | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    tags_cache?: mediaUpdatetags_cacheInput | string[]
    status?: Enummedia_statusFieldUpdateOperationsInput | $Enums.media_status
    moderation_history?: InputJsonValue | InputJsonValue | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reports_against?: reportUncheckedUpdateManyWithoutMedia_targetNestedInput
    featured_assignments?: featured_assignmentUncheckedUpdateManyWithoutMedia_refNestedInput
  }

  export type mediaUncheckedUpdateManyWithoutPlayerInput = {
    type?: Enummedia_typeFieldUpdateOperationsInput | $Enums.media_type
    source?: Enummedia_sourceFieldUpdateOperationsInput | $Enums.media_source
    url?: StringFieldUpdateOperationsInput | string
    poster_url?: NullableStringFieldUpdateOperationsInput | string | null
    blur_data_url?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    duration_sec?: NullableIntFieldUpdateOperationsInput | number | null
    focal_point_x?: NullableIntFieldUpdateOperationsInput | number | null
    focal_point_y?: NullableIntFieldUpdateOperationsInput | number | null
    variants?: InputJsonValue | InputJsonValue | null
    hls_url?: NullableStringFieldUpdateOperationsInput | string | null
    nsfw_score?: NullableFloatFieldUpdateOperationsInput | number | null
    nsfw_labels?: InputJsonValue | InputJsonValue | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    tags_cache?: mediaUpdatetags_cacheInput | string[]
    status?: Enummedia_statusFieldUpdateOperationsInput | $Enums.media_status
    moderation_history?: InputJsonValue | InputJsonValue | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type boostUpdateWithoutPlayerInput = {
    status?: Enumboost_statusFieldUpdateOperationsInput | $Enums.boost_status
    starts_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ends_at?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: Enumprovider_kindFieldUpdateOperationsInput | $Enums.provider_kind
    external_id?: NullableStringFieldUpdateOperationsInput | string | null
    amount_cents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type boostUncheckedUpdateWithoutPlayerInput = {
    status?: Enumboost_statusFieldUpdateOperationsInput | $Enums.boost_status
    starts_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ends_at?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: Enumprovider_kindFieldUpdateOperationsInput | $Enums.provider_kind
    external_id?: NullableStringFieldUpdateOperationsInput | string | null
    amount_cents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type boostUncheckedUpdateManyWithoutPlayerInput = {
    status?: Enumboost_statusFieldUpdateOperationsInput | $Enums.boost_status
    starts_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ends_at?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: Enumprovider_kindFieldUpdateOperationsInput | $Enums.provider_kind
    external_id?: NullableStringFieldUpdateOperationsInput | string | null
    amount_cents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type strikeUpdateWithoutPlayerInput = {
    reason?: StringFieldUpdateOperationsInput | string
    severity?: Enumseverity_levelFieldUpdateOperationsInput | $Enums.severity_level
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumsetting_statusFieldUpdateOperationsInput | $Enums.setting_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type strikeUncheckedUpdateWithoutPlayerInput = {
    reason?: StringFieldUpdateOperationsInput | string
    severity?: Enumseverity_levelFieldUpdateOperationsInput | $Enums.severity_level
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumsetting_statusFieldUpdateOperationsInput | $Enums.setting_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type strikeUncheckedUpdateManyWithoutPlayerInput = {
    reason?: StringFieldUpdateOperationsInput | string
    severity?: Enumseverity_levelFieldUpdateOperationsInput | $Enums.severity_level
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumsetting_statusFieldUpdateOperationsInput | $Enums.setting_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type user_noteUpdateWithoutPlayerInput = {
    note?: StringFieldUpdateOperationsInput | string
    status?: Enumsetting_statusFieldUpdateOperationsInput | $Enums.setting_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    author?: userUpdateOneRequiredWithoutNotes_authoredNestedInput
  }

  export type user_noteUncheckedUpdateWithoutPlayerInput = {
    author_id?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    status?: Enumsetting_statusFieldUpdateOperationsInput | $Enums.setting_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type user_noteUncheckedUpdateManyWithoutPlayerInput = {
    author_id?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    status?: Enumsetting_statusFieldUpdateOperationsInput | $Enums.setting_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type contact_eventUpdateWithoutPlayerInput = {
    channel?: Enumcontact_channelFieldUpdateOperationsInput | $Enums.contact_channel
    requester_ip?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enumsetting_statusFieldUpdateOperationsInput | $Enums.setting_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type contact_eventUncheckedUpdateWithoutPlayerInput = {
    channel?: Enumcontact_channelFieldUpdateOperationsInput | $Enums.contact_channel
    requester_ip?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enumsetting_statusFieldUpdateOperationsInput | $Enums.setting_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type contact_eventUncheckedUpdateManyWithoutPlayerInput = {
    channel?: Enumcontact_channelFieldUpdateOperationsInput | $Enums.contact_channel
    requester_ip?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enumsetting_statusFieldUpdateOperationsInput | $Enums.setting_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type reportUpdateWithoutProfile_targetInput = {
    target_type?: StringFieldUpdateOperationsInput | string
    reason?: Enumreport_reasonFieldUpdateOperationsInput | $Enums.report_reason
    details?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: Enumseverity_levelFieldUpdateOperationsInput | $Enums.severity_level
    status?: Enumreport_statusFieldUpdateOperationsInput | $Enums.report_status
    resolution_note?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    media_target?: mediaUpdateOneWithoutReports_againstNestedInput
    reporter_user?: userUpdateOneWithoutReports_madeNestedInput
  }

  export type reportUncheckedUpdateWithoutProfile_targetInput = {
    reporter_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    target_type?: StringFieldUpdateOperationsInput | string
    reason?: Enumreport_reasonFieldUpdateOperationsInput | $Enums.report_reason
    details?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: Enumseverity_levelFieldUpdateOperationsInput | $Enums.severity_level
    status?: Enumreport_statusFieldUpdateOperationsInput | $Enums.report_status
    resolution_note?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type reportUncheckedUpdateManyWithoutProfile_targetInput = {
    reporter_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    target_type?: StringFieldUpdateOperationsInput | string
    reason?: Enumreport_reasonFieldUpdateOperationsInput | $Enums.report_reason
    details?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: Enumseverity_levelFieldUpdateOperationsInput | $Enums.severity_level
    status?: Enumreport_statusFieldUpdateOperationsInput | $Enums.report_status
    resolution_note?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type player_tagUpdateWithoutPlayerInput = {
    status?: Enumsetting_statusFieldUpdateOperationsInput | $Enums.setting_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tag_ref?: tagUpdateOneRequiredWithoutPlayer_tagsNestedInput
  }

  export type player_tagUncheckedUpdateWithoutPlayerInput = {
    tag_id?: StringFieldUpdateOperationsInput | string
    status?: Enumsetting_statusFieldUpdateOperationsInput | $Enums.setting_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type player_tagUncheckedUpdateManyWithoutPlayerInput = {
    tag_id?: StringFieldUpdateOperationsInput | string
    status?: Enumsetting_statusFieldUpdateOperationsInput | $Enums.setting_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type featured_assignmentUpdateWithoutPlayerInput = {
    slot_key?: Enumfeature_slot_keyFieldUpdateOperationsInput | $Enums.feature_slot_key
    starts_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ends_at?: DateTimeFieldUpdateOperationsInput | Date | string
    priority?: IntFieldUpdateOperationsInput | number
    status?: Enumsetting_statusFieldUpdateOperationsInput | $Enums.setting_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    media_ref?: mediaUpdateOneWithoutFeatured_assignmentsNestedInput
  }

  export type featured_assignmentUncheckedUpdateWithoutPlayerInput = {
    slot_key?: Enumfeature_slot_keyFieldUpdateOperationsInput | $Enums.feature_slot_key
    media_id?: NullableStringFieldUpdateOperationsInput | string | null
    starts_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ends_at?: DateTimeFieldUpdateOperationsInput | Date | string
    priority?: IntFieldUpdateOperationsInput | number
    status?: Enumsetting_statusFieldUpdateOperationsInput | $Enums.setting_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type featured_assignmentUncheckedUpdateManyWithoutPlayerInput = {
    slot_key?: Enumfeature_slot_keyFieldUpdateOperationsInput | $Enums.feature_slot_key
    media_id?: NullableStringFieldUpdateOperationsInput | string | null
    starts_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ends_at?: DateTimeFieldUpdateOperationsInput | Date | string
    priority?: IntFieldUpdateOperationsInput | number
    status?: Enumsetting_statusFieldUpdateOperationsInput | $Enums.setting_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type reportCreateManyMedia_targetInput = {
    id?: string
    reporter_user_id?: string | null
    target_type: string
    reason: $Enums.report_reason
    details?: string | null
    severity?: $Enums.severity_level
    status?: $Enums.report_status
    resolution_note?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type featured_assignmentCreateManyMedia_refInput = {
    id?: string
    slot_key: $Enums.feature_slot_key
    player_id: string
    starts_at: Date | string
    ends_at: Date | string
    priority?: number
    status?: $Enums.setting_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type reportUpdateWithoutMedia_targetInput = {
    target_type?: StringFieldUpdateOperationsInput | string
    reason?: Enumreport_reasonFieldUpdateOperationsInput | $Enums.report_reason
    details?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: Enumseverity_levelFieldUpdateOperationsInput | $Enums.severity_level
    status?: Enumreport_statusFieldUpdateOperationsInput | $Enums.report_status
    resolution_note?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile_target?: profileUpdateOneWithoutReports_againstNestedInput
    reporter_user?: userUpdateOneWithoutReports_madeNestedInput
  }

  export type reportUncheckedUpdateWithoutMedia_targetInput = {
    reporter_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    target_type?: StringFieldUpdateOperationsInput | string
    reason?: Enumreport_reasonFieldUpdateOperationsInput | $Enums.report_reason
    details?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: Enumseverity_levelFieldUpdateOperationsInput | $Enums.severity_level
    status?: Enumreport_statusFieldUpdateOperationsInput | $Enums.report_status
    resolution_note?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type reportUncheckedUpdateManyWithoutMedia_targetInput = {
    reporter_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    target_type?: StringFieldUpdateOperationsInput | string
    reason?: Enumreport_reasonFieldUpdateOperationsInput | $Enums.report_reason
    details?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: Enumseverity_levelFieldUpdateOperationsInput | $Enums.severity_level
    status?: Enumreport_statusFieldUpdateOperationsInput | $Enums.report_status
    resolution_note?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type featured_assignmentUpdateWithoutMedia_refInput = {
    slot_key?: Enumfeature_slot_keyFieldUpdateOperationsInput | $Enums.feature_slot_key
    starts_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ends_at?: DateTimeFieldUpdateOperationsInput | Date | string
    priority?: IntFieldUpdateOperationsInput | number
    status?: Enumsetting_statusFieldUpdateOperationsInput | $Enums.setting_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    player?: profileUpdateOneRequiredWithoutFeatured_assignmentsNestedInput
  }

  export type featured_assignmentUncheckedUpdateWithoutMedia_refInput = {
    slot_key?: Enumfeature_slot_keyFieldUpdateOperationsInput | $Enums.feature_slot_key
    player_id?: StringFieldUpdateOperationsInput | string
    starts_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ends_at?: DateTimeFieldUpdateOperationsInput | Date | string
    priority?: IntFieldUpdateOperationsInput | number
    status?: Enumsetting_statusFieldUpdateOperationsInput | $Enums.setting_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type featured_assignmentUncheckedUpdateManyWithoutMedia_refInput = {
    slot_key?: Enumfeature_slot_keyFieldUpdateOperationsInput | $Enums.feature_slot_key
    player_id?: StringFieldUpdateOperationsInput | string
    starts_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ends_at?: DateTimeFieldUpdateOperationsInput | Date | string
    priority?: IntFieldUpdateOperationsInput | number
    status?: Enumsetting_statusFieldUpdateOperationsInput | $Enums.setting_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type player_tagCreateManyTag_refInput = {
    id?: string
    player_id: string
    status?: $Enums.setting_status
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type player_tagUpdateWithoutTag_refInput = {
    status?: Enumsetting_statusFieldUpdateOperationsInput | $Enums.setting_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    player?: profileUpdateOneRequiredWithoutPlayer_tagsNestedInput
  }

  export type player_tagUncheckedUpdateWithoutTag_refInput = {
    player_id?: StringFieldUpdateOperationsInput | string
    status?: Enumsetting_statusFieldUpdateOperationsInput | $Enums.setting_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type player_tagUncheckedUpdateManyWithoutTag_refInput = {
    player_id?: StringFieldUpdateOperationsInput | string
    status?: Enumsetting_statusFieldUpdateOperationsInput | $Enums.setting_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}